 projects/dk_apps/demos/apu_demo/audio_task.c   |   4 +-
 sdk/bsp/peripherals/include/hw_pcm.h           | 319 +++++++++++++++++--------
 sdk/bsp/peripherals/src/hw_pcm.c               |  72 +++---
 sdk/bsp/system/sys_man/include/sys_audio_mgr.h |   2 +
 sdk/bsp/system/sys_man/sys_audio_mgr.c         | 228 +++++++++---------
 5 files changed, 372 insertions(+), 253 deletions(-)

diff --git a/projects/dk_apps/demos/apu_demo/audio_task.c b/projects/dk_apps/demos/apu_demo/audio_task.c
index cef7c15..aae7aac 100644
--- a/projects/dk_apps/demos/apu_demo/audio_task.c
+++ b/projects/dk_apps/demos/apu_demo/audio_task.c
@@ -133,7 +133,7 @@ static void mic_record_init()
 
 #if DEMO_PCM_RECORD_PLAYBACK
         /* Initialize default parameters for I2S input */
-        retval_in = sys_audio_mgr_default_pcm_data_init(&context_demo_apu.dev_in, 4,
+        retval_in = sys_audio_mgr_default_pcm_data_init(&context_demo_apu.dev_in, 2,
                                                         MODE_MASTER, I2S_MODE);
         OS_ASSERT(retval_in);
 
@@ -203,7 +203,7 @@ static void mic_playback_init()
         }
 
        /* Initialize default parameters for I2S output */
-       retval_out = sys_audio_mgr_default_pcm_data_init(&context_demo_apu.dev_out, 4,
+       retval_out = sys_audio_mgr_default_pcm_data_init(&context_demo_apu.dev_out, 2,
                                                         MODE_MASTER, I2S_MODE);
        OS_ASSERT(retval_out);
 
diff --git a/sdk/bsp/peripherals/include/hw_pcm.h b/sdk/bsp/peripherals/include/hw_pcm.h
index 97a5f66..62bf5a2 100644
--- a/sdk/bsp/peripherals/include/hw_pcm.h
+++ b/sdk/bsp/peripherals/include/hw_pcm.h
@@ -28,6 +28,85 @@
 
 #include "sdk_defs.h"
 
+/**
+ * \brief Get the value of a field of a PCM register of CRG.
+ *
+ * \param [in] reg is the register to access
+ * \param [in] field is the register field to read
+ *
+ * \return the value of the register field
+ *
+ */
+#define HW_PCM_CRG_REG_GETF(reg, field)         REG_GETF(CRG_PER, PCM_##reg##_REG, field)
+/**
+ * \brief Set the value of a field of a PCM register of CRG.
+ *
+ * \param [in] reg is the register to access
+ * \param [in] field is the register field to write
+ * \param [in] val is the value to write
+ *
+ */
+#define HW_PCM_CRG_REG_SETF(reg, field, val)    REG_SETF(CRG_PER, PCM_##reg##_REG, field, val)
+
+/**
+ * \brief Set a bit of a PCM register of CRG.
+ *
+ * \param [in] reg is the register to access
+ * \param [in] field is the register field to write
+ */
+#define HW_PCM_CRG_REG_SET_BIT(reg, field)      REG_SET_BIT(CRG_PER, PCM_##reg##_REG, field)
+
+/**
+ * \brief Clear a bit of a PCM register of CRG.
+ *
+ * \param [in] reg is the register to access
+ * \param [in] field is the register field to write
+ */
+#define HW_PCM_CRG_REG_CLR_BIT(reg, field)              REG_CLR_BIT(CRG_PER, PCM_##reg##_REG, field)
+/**
+ * \brief Get the value of a field of a PCM register of SRC.
+ *
+ * \param [in] reg is the register to access
+ * \param [in] field is the register field to read
+ *
+ * \return the value of the register field
+ *
+ */
+#define HW_PCM_SRC_REG_GETF(reg, field)         REG_GETF(APU, PCM1_##reg##_REG, field)
+/**
+ * \brief Set the value of a field of a PCM register of SRC.
+ *
+ * \param [in] reg is the register to access
+ * \param [in] field is the register field to write
+ * \param [in] val is the value to write
+ *
+ */
+#define HW_PCM_SRC_REG_SETF(reg, field, val)    REG_SETF(APU, PCM1_##reg##_REG, field, val)
+/**
+ * \brief Set a bit of a PCM register of SRC.
+ *
+ * \param [in] reg is the register to access
+ * \param [in] field is the register field to write
+ */
+#define HW_PCM_SRC_REG_SET_BIT(reg, field)      REG_SET_BIT(APU, PCM1_##reg##_REG, field)
+/**
+ * \brief Clear a bit of a PCM register of SRC.
+ *
+ * \param [in] reg is the register to access
+ * \param [in] field is the register field to write
+ */
+#define HW_PCM_SRC_REG_CLR_BIT(reg, field)      REG_CLR_BIT(APU, PCM1_##reg##_REG, field)
+/**
+ * \brief PCM error code
+ *
+ */
+typedef enum {
+        HW_PCM_ERROR_NO_ERROR,               /**< No error during pcm init */
+        HW_PCM_ERROR_INVALID_SAMPLE_RATE,    /**< Error related with not supported sampling rate */
+        HW_PCM_ERROR_INVALID_BIT_CLK,        /**< Error related with not supported calculated bit
+                                                        clock */
+}HW_PCM_ERROR_CODE;
+
 /**
  * \brief PCM master/slave mode
  *
@@ -43,7 +122,7 @@ typedef enum {
  */
 typedef enum {
         HW_PCM_CLK_DIVN,
-        HW_PCM_CLK_DIV1
+        HW_PCM_CLK_DIV1,                      /**< PCM clk to be used is DIV1*/
 } HW_PCM_CLOCK;
 
 /**
@@ -51,11 +130,11 @@ typedef enum {
  *
  */
 typedef enum {
-        HW_PCM_CLK_GEN_FRACTIONAL = 0,   /**< fractional option. Dividing the system clock by an
-                                              integer and a fractional part*/
-        HW_PCM_CLK_GEN_INTEGER_ONLY,     /**< integer only option. Approximate the sample rate
-                                              by adding more clock pulses than required bits.
-                                              These extra pulses are ignored */
+        HW_PCM_CLK_GEN_FRACTIONAL = 0,        /**< fractional option. Dividing the system clock
+                                                      by an integer and a fractional part*/
+        HW_PCM_CLK_GEN_INTEGER_ONLY,          /**< integer only option. Approximate the sample rate
+                                                      by adding more clock pulses than required bits.
+                                                      These extra pulses are ignored */
 } HW_PCM_CLK_GENERATION;
 
 /**
@@ -63,8 +142,8 @@ typedef enum {
  *
  */
 typedef enum {
-        HW_PCM_ONE_CYCLE_PER_BIT = 0,   /**< one clock cycle per data bit */
-        HW_PCM_TWO_CYCLE_PER_BIT,       /**< two clock cycles per data bit */
+        HW_PCM_ONE_CYCLE_PER_BIT = 0,         /**< one clock cycle per data bit */
+        HW_PCM_TWO_CYCLE_PER_BIT,             /**< two clock cycles per data bit */
 } HW_PCM_CYCLE_PER_BIT;
 
 /**
@@ -72,8 +151,8 @@ typedef enum {
  *
  */
 typedef enum {
-        HW_PCM_DO_OUTPUT_PUSH_PULL = 0,    /**< PCM DO push pull */
-        HW_PCM_DO_OUTPUT_OPEN_DRAIN,       /**< PCM DO open drain */
+        HW_PCM_DO_OUTPUT_PUSH_PULL = 0,       /**< PCM DO push pull */
+        HW_PCM_DO_OUTPUT_OPEN_DRAIN,          /**< PCM DO open drain */
 } HW_PCM_DO_OUTPUT_MODE;
 
 /**
@@ -81,7 +160,7 @@ typedef enum {
  *
  */
 typedef enum {
-        HW_PCM_FSC_EDGE_RISING = 0,             /**< shift channels 1-8 after PCM_FSC edge */
+        HW_PCM_FSC_EDGE_RISING = 0,            /**< shift channels 1-8 after PCM_FSC edge */
         HW_PCM_FSC_EDGE_RISING_AND_FALLING,     /**< shift channels 1-4 after PCM_FSC edge
                                                     and channels 5-8 after opposite PCM_FSC edge */
 } HW_PCM_FSC_EDGE;
@@ -91,8 +170,10 @@ typedef enum {
  *
  */
 typedef enum {
-        HW_PCM_FSC_STARTS_1_CYCLE_BEFORE_MSB_BIT = 0,/**< PCM FSC starts one cycle before MSB bit */
-        HW_PCM_FSC_STARTS_SYNCH_TO_MSB_BIT,      /**< PCM FSC starts at the same time as MSB bit */
+        HW_PCM_FSC_STARTS_1_CYCLE_BEFORE_MSB_BIT = 0,   /**< PCM FSC starts one cycle
+                                                                before MSB bit */
+        HW_PCM_FSC_STARTS_SYNCH_TO_MSB_BIT,             /**< PCM FSC starts at the same time
+                                                                as MSB bit */
 } HW_PCM_FSC_DELAY;
 
 /**
@@ -119,8 +200,10 @@ typedef enum {
  */
 typedef enum {
         HW_PCM_INPUT_MUX_OFF,          /**< PCM input is off */
-        HW_PCM_INPUT_MUX_SRC_OUT,      /**< PCM input set to SRC1_OUT_REG */
+        HW_PCM_INPUT_MUX_SRC1_OUT,     /**< PCM input set to SRC1_OUT_REG */
         HW_PCM_INPUT_MUX_PCM_OUT_REG,  /**< PCM input set to PCM_OUT_REG */
+        HW_PCM_INPUT_MUX_SRC2_OUT,     /**< PCM input set to SRC2_OUT_REG */
+        HW_PCM_INPUT_MUX_SIZE
 } HW_PCM_INPUT_MUX;
 
 /**
@@ -210,9 +293,10 @@ typedef enum {
  */
 typedef struct {
         /* PCM mode configuration is placed in mode specific structures */
-        HW_PCM_CONFIG_MODE config_mode;         /**< master/slave mode */
-        HW_PCM_MODE pcm_mode;                   /**< PCM output mode */
+        HW_PCM_CONFIG_MODE config_mode;         /**< PCM output mode */
+        HW_PCM_MODE pcm_mode;                   /**< master/slave mode */
         HW_PCM_DO_OUTPUT_MODE gpio_output_mode; /**< gpio pin output mode */
+        HW_PCM_CLK_GENERATION div;              /**< select PCM clock generation */
 
         union {
                 hw_pcm_config_generic_pcm_t pcm_param;
@@ -222,15 +306,43 @@ typedef struct {
         };
 } hw_pcm_config_t;
 
+/**
+ * \brief Enable the PCM interface clock source
+ */
+__STATIC_INLINE void hw_pcm_clk_enable(void)
+{
+        // Enable PCM interface clock source
+        HW_PCM_CRG_REG_SET_BIT(DIV, CLK_PCM_EN);
+}
+
+/**
+ * \brief Disable the PCM interface clock source
+ */
+__STATIC_INLINE void hw_pcm_clk_disable(void)
+{
+        // Disable PCM interface clock source
+        HW_PCM_CRG_REG_CLR_BIT(DIV, CLK_PCM_EN);
+}
+
+/**
+ * \brief Get the status of the PCM interface clock source
+ *
+ * \return
+ *              \li false if PCM interface clock source is disabled,
+ *              \li true otherwise
+ */
+__STATIC_INLINE bool hw_pcm_clk_is_enabled(void)
+{
+        return (HW_PCM_CRG_REG_GETF(DIV, CLK_PCM_EN));
+}
+
 /**
  * \brief Enable the PCM interface
  */
 __STATIC_INLINE void hw_pcm_enable(void)
 {
         // Enable PCM interface
-        REG_SET_BIT(APU, PCM1_CTRL_REG, PCM_EN);
-        // Enable PCM interface clock source
-        REG_SET_BIT(CRG_PER, PCM_DIV_REG, CLK_PCM_EN);
+        HW_PCM_SRC_REG_SET_BIT(CTRL, PCM_EN);
 }
 
 /**
@@ -239,19 +351,19 @@ __STATIC_INLINE void hw_pcm_enable(void)
 __STATIC_INLINE void hw_pcm_disable(void)
 {
         // Disable PCM interface
-        REG_CLR_BIT(APU, PCM1_CTRL_REG, PCM_EN);
-        // Disable PCM interface clock source
-        REG_CLR_BIT(CRG_PER, PCM_DIV_REG, CLK_PCM_EN);
+        HW_PCM_SRC_REG_CLR_BIT(CTRL, PCM_EN);
 }
 
 /**
  * \brief Get the status of the PCM interface
  *
- * \return false if PCM interface is disabled, true otherwise
+ * \return
+ *              \li false if PCM interface is disabled,
+ *              \li true otherwise
  */
 __STATIC_INLINE bool hw_pcm_is_enabled(void)
 {
-        return (REG_GETF(APU, PCM1_CTRL_REG, PCM_EN));
+        return (HW_PCM_SRC_REG_GETF(CTRL, PCM_EN));
 }
 
 /**
@@ -262,17 +374,19 @@ __STATIC_INLINE bool hw_pcm_is_enabled(void)
  */
 __STATIC_INLINE uint8_t hw_pcm_get_channel_delay()
 {
-       return (REG_GETF(APU, PCM1_CTRL_REG, PCM_CH_DEL));
+       return (HW_PCM_SRC_REG_GETF(CTRL, PCM_CH_DEL));
 }
 
 /**
  * \brief Get PCM FSC edge
  *
- * \return The FSC edge, HW_PCM_FSC_EDGE_RISING or HW_PCM_FSC_EDGE_RISING_AND_FALLING
+ * \return The FSC edge
+ *              \li HW_PCM_FSC_EDGE_RISING or
+ *              \li HW_PCM_FSC_EDGE_RISING_AND_FALLING
  */
-__STATIC_INLINE bool hw_pcm_get_fsc_edge()
+__STATIC_INLINE bool hw_pcm_get_fsc_edge(void)
 {
-       return (REG_GETF(APU, PCM1_CTRL_REG, PCM_FSC_EDGE));
+       return (HW_PCM_SRC_REG_GETF(CTRL, PCM_FSC_EDGE));
 }
 
 /**
@@ -280,9 +394,9 @@ __STATIC_INLINE bool hw_pcm_get_fsc_edge()
  *
  * \return  The FSC length in multiples of 8. if 0 then FSC length is equal to 1 data bit.
  */
-__STATIC_INLINE uint8_t hw_pcm_get_fsc_length()
+__STATIC_INLINE uint8_t hw_pcm_get_fsc_length(void)
 {
-       return (REG_GETF(APU, PCM1_CTRL_REG, PCM_FSCLEN));
+       return (HW_PCM_SRC_REG_GETF(CTRL, PCM_FSCLEN));
 }
 
 /**
@@ -291,9 +405,9 @@ __STATIC_INLINE uint8_t hw_pcm_get_fsc_length()
  * \return   The FSC divider.  Values must be in the range of 8..0x1000.
  *                If PCM_CLK_BIT=1, divider must always be even.
  */
-__STATIC_INLINE uint16_t hw_pcm_get_fsc_div()
+__STATIC_INLINE uint16_t hw_pcm_get_fsc_div(void)
 {
-       return (REG_GETF(APU, PCM1_CTRL_REG, PCM_FSC_DIV));
+       return (HW_PCM_SRC_REG_GETF(CTRL, PCM_FSC_DIV));
 }
 
 /**
@@ -304,57 +418,61 @@ __STATIC_INLINE uint16_t hw_pcm_get_fsc_div()
  *            first bit of channel 0. If delay is HW_PCM_FSC_STARTS_SYNCH_TO_MSB_BIT then FSC
  *            starts synchronously to the first bit of channel 0.
  */
-__STATIC_INLINE bool hw_pcm_get_fsc_delay()
+__STATIC_INLINE bool hw_pcm_get_fsc_delay(void)
 {
-       return (REG_GETF(APU, PCM1_CTRL_REG, PCM_FSCDEL));
+       return (HW_PCM_SRC_REG_GETF(CTRL, PCM_FSCDEL));
 }
 
 /**
  * \brief Get PCM clock polarity
  *
- * \return  Polarity of PCM_CLK, HW_PCM_CLK_POLARITY_NORMAL or HW_PCM_CLK_POLARITY_INVERTED
+ * \return  Polarity of PCM_CLK
+ *              \li HW_PCM_CLK_POLARITY_NORMAL or
+ *              \li HW_PCM_CLK_POLARITY_INVERTED
  *
  */
-__STATIC_INLINE bool hw_pcm_get_clk_polarity()
+__STATIC_INLINE bool hw_pcm_get_clk_polarity(void)
 {
 
-       return (REG_GETF(APU, PCM1_CTRL_REG, PCM_CLKINV));
+       return (HW_PCM_SRC_REG_GETF(CTRL, PCM_CLKINV));
 }
 
 /**
  * \brief Get PCM FSC polarity
  *
- * \return The polarity of FSC, HW_PCM_FSC_POLARITY_NORMAL or HW_PCM_FSC_POLARITY_INVERTED
+ * \return The polarity of FSC
+ *              \li HW_PCM_FSC_POLARITY_NORMAL or
+ *              \li HW_PCM_FSC_POLARITY_INVERTED
  *
  */
-__STATIC_INLINE bool hw_pcm_get_fsc_polarity()
+__STATIC_INLINE bool hw_pcm_get_fsc_polarity(void)
 {
 
-       return (REG_GETF(APU, PCM1_CTRL_REG, PCM_FSCINV));
+       return (HW_PCM_SRC_REG_GETF(CTRL, PCM_FSCINV));
 }
 
 /**
  * \brief Get PCM clock cycles per data bit
  *
  * \return cycles The number of clock cycles per data bit:
- *       HW_PCM_ONE_CYCLE_PER_BIT = One clock cycle per data bit
- *       HW_PCM_TWO_CYCLE_PER_BIT = Two clock cycles per data bit
+ *              \li HW_PCM_ONE_CYCLE_PER_BIT = One clock cycle per data bit
+ *              \li HW_PCM_TWO_CYCLE_PER_BIT = Two clock cycles per data bit
  */
-__STATIC_INLINE bool hw_pcm_get_clk_per_bit()
+__STATIC_INLINE bool hw_pcm_get_clk_per_bit(void)
 {
-
-       return (REG_GETF(APU, PCM1_CTRL_REG, PCM_CLK_BIT));
+       return (HW_PCM_SRC_REG_GETF(CTRL, PCM_CLK_BIT));
 }
 
 /**
  * \brief Get input for the PCM1_MUX_IN multiplexer
  *
  * \return The input for PCM:
- *      HW_PCM_INPUT_MUX_OFF           = PCM input is off
- *      HW_PCM_INPUT_MUX_SRC_OUT       = PCM input is set to SRC output
- *      HW_PCM_INPUT_MUX_PCM_OUT_REG   = PCM input is set to PCM output registers
+ *      \li HW_PCM_INPUT_MUX_OFF           = PCM input is off
+ *      \li HW_PCM_INPUT_MUX_SRC_OUT       = PCM input is set to SRC1 output
+ *      \li HW_PCM_INPUT_MUX_PCM_OUT_REG   = PCM input is set to PCM output registers
+ *      \li HW_PCM_INPUT_MUX_SRC2_OUT      = PCM input set to SRC2_OUT_REG
  */
-__STATIC_INLINE HW_PCM_INPUT_MUX hw_pcm_get_pcm_input_mux()
+__STATIC_INLINE HW_PCM_INPUT_MUX hw_pcm_get_pcm_input_mux(void)
 {
         // Set PCM1_MUX_IN field in APU MUX register
         return(REG_GETF(APU, APU_MUX_REG, PCM1_MUX_IN));
@@ -363,65 +481,59 @@ __STATIC_INLINE HW_PCM_INPUT_MUX hw_pcm_get_pcm_input_mux()
 /**
  * \brief Get PCM DO output mode
  *
- * \return Mode can be HW_PCM_DO_OUTPUT_PUSH_PULL or HW_PCM_DO_OUTPUT_OPEN_DRAIN
+ * \return output mode can be
+ *         \li HW_PCM_DO_OUTPUT_PUSH_PULL or
+ *         \li HW_PCM_DO_OUTPUT_OPEN_DRAIN
  *
  */
-__STATIC_INLINE HW_PCM_DO_OUTPUT_MODE hw_pcm_get_output_mode()
+__STATIC_INLINE HW_PCM_DO_OUTPUT_MODE hw_pcm_get_output_mode(void)
 {
         // Set PCM_PPOD field in PCM control register
-        return(REG_GETF(APU, PCM1_CTRL_REG, PCM_PPOD));
+        return(HW_PCM_SRC_REG_GETF(CTRL, PCM_PPOD));
 }
 
 /**
  * \brief Get PCM master/slave mode
  *
- * \return PCM mode, master or slave
+ * \return PCM mode
+ *              \li master or
+ *              \li slave
  *
  */
-__STATIC_INLINE HW_PCM_MODE hw_pcm_get_mode()
+__STATIC_INLINE HW_PCM_MODE hw_pcm_get_mode(void)
 {
-        return(REG_GETF(APU, PCM1_CTRL_REG, PCM_MASTER));
+        return(HW_PCM_SRC_REG_GETF(CTRL, PCM_MASTER));
 }
 
 /**
  * \brief Set PCM master/slave mode
  *
- * \param[in] mode PCM mode, master or slave
+ * \param[in] mode PCM mode
+ *              \li master or
+ *              \li slave
  *
  */
 __STATIC_INLINE void hw_pcm_set_mode(HW_PCM_MODE mode)
 {
-        if (hw_pcm_is_enabled()) {
-                hw_pcm_disable();// disable PCM block
-        }
-
-        REG_SETF(APU, PCM1_CTRL_REG, PCM_MASTER, mode); // set/reset PCM_MASTER bit
-
-        if (!hw_pcm_is_enabled()) {
-                hw_pcm_enable();// enable PCM block
-        }
+        HW_PCM_SRC_REG_SETF(CTRL, PCM_MASTER, mode); // set/reset PCM_MASTER bit
 }
 
 /**
  * \brief Initialize PCM clock registers
  *
- * \param[in] clock PCM clock source, either div1 or divN
- * \param[in] sample_rate sample rate in kHz
- * \param[in] bit_num bits number
- * \param[in] channel_num number of channels
- * \param[in] div desired divisor type, fractional or integer only
- */
-void hw_pcm_init_clk_reg(HW_PCM_CLOCK clock, uint8_t sample_rate, uint8_t bit_num, uint8_t channel_num,
-                                                                         HW_PCM_CLK_GENERATION div);
-
-/**
- * \brief Disable the PCM system clock source
+ * \param[in] clock             PCM clock source, either div1 or divN
+ * \param[in] sample_rate       sample rate in kHz
+ * \param[in] fsc_div           fsc divider equals with bits_depth * total_channel_num +
+ *                              channel_delay * 8 * slot
+ *                              where slot is 2 for fsc_length > 0 and 1 for fsc_length = 0
+ * \param[in] div               desired divisor type, fractional or integer only
+ *
+ * \return  the error code
+ *                              \li HW_PCM_ERROR_NO_ERROR on success, else
+ *                              \li error
+ *                              \sa HW_PCM_ERROR_CODE
  */
-__STATIC_INLINE void hw_pcm_clk_disable(void)
-{
-        // Reset CLK_PCM_EN bit in PCM DIV register
-        REG_CLR_BIT(CRG_PER, PCM_DIV_REG, CLK_PCM_EN);
-}
+HW_PCM_ERROR_CODE hw_pcm_init_clk_reg(HW_PCM_CLOCK clock, uint8_t sample_rate, uint16_t fsc_div, HW_PCM_CLK_GENERATION div);
 
 /**
  * \brief Set initialization of PCM interface
@@ -440,10 +552,10 @@ void hw_pcm_init(hw_pcm_config_t *config);
  */
 __STATIC_INLINE void hw_pcm_set_channel_delay(uint8_t delay)
 {
-        // Maximum 8 channels of 8bits each are supported
-        ASSERT_WARNING(delay < 8);
+        // Delay has a maximum value of 31
+        ASSERT_WARNING(delay <= 31);
         // Set PCM_CH_DEL field in PCM control register
-        REG_SETF(APU, PCM1_CTRL_REG, PCM_CH_DEL, delay);
+        HW_PCM_SRC_REG_SETF(CTRL, PCM_CH_DEL, delay);
 }
 
 /**
@@ -454,7 +566,7 @@ __STATIC_INLINE void hw_pcm_set_channel_delay(uint8_t delay)
 __STATIC_INLINE void hw_pcm_set_fsc_edge(HW_PCM_FSC_EDGE edge)
 {
         // Set PCM_FSC_EDGE field in PCM control register
-        REG_SETF(APU, PCM1_CTRL_REG, PCM_FSC_EDGE, edge);
+        HW_PCM_SRC_REG_SETF(CTRL, PCM_FSC_EDGE, edge);
 }
 
 /**
@@ -469,7 +581,7 @@ __STATIC_INLINE void hw_pcm_set_fsc_length(uint8_t length)
         ASSERT_WARNING(length <= 8);
 
         // Set PCM_FSCLEN field in PCM control register
-        REG_SETF(APU, PCM1_CTRL_REG, PCM_FSCLEN, length);
+        HW_PCM_SRC_REG_SETF(CTRL, PCM_FSCLEN, length);
 }
 
 /**
@@ -487,7 +599,7 @@ __STATIC_INLINE void hw_pcm_set_fsc_div(uint16_t div)
         }
 
         // Set PCM_FSC_DIV field in PCM control register
-        REG_SETF(APU, PCM1_CTRL_REG, PCM_FSC_DIV, div - 1);
+        HW_PCM_SRC_REG_SETF(CTRL, PCM_FSC_DIV, div - 1);
 }
 
 /**
@@ -501,26 +613,28 @@ __STATIC_INLINE void hw_pcm_set_fsc_div(uint16_t div)
 __STATIC_INLINE void hw_pcm_set_fsc_delay(HW_PCM_FSC_DELAY delay)
 {
         // Set PCM_FSCDEL field in PCM control register
-        REG_SETF(APU, PCM1_CTRL_REG, PCM_FSCDEL, delay);
+        HW_PCM_SRC_REG_SETF(CTRL, PCM_FSCDEL, delay);
 }
 
 /**
  * \brief Set PCM clock polarity
  *
- * \param[in] pol Polarity of PCM_CLK, HW_PCM_CLK_POLARITY_NORMAL or HW_PCM_CLK_POLARITY_INVERTED
+ * \param[in] pol Polarity of PCM_CLK,
+ *              \li HW_PCM_CLK_POLARITY_NORMAL or
+ *              \li  HW_PCM_CLK_POLARITY_INVERTED
  *
  */
 __STATIC_INLINE void hw_pcm_set_clk_polarity(HW_PCM_CLK_POLARITY pol)
 {
         // Set PCM_CLKINV field in PCM control register
-        REG_SETF(APU, PCM1_CTRL_REG, PCM_CLKINV, pol);
+        HW_PCM_SRC_REG_SETF(CTRL, PCM_CLKINV, pol);
 }
 
 /**
  * \brief Set input for the PCM1_MUX_IN multiplexer
  *
  * \param[in] input The input for PCM:
- *      HW_PCM_INPUT_MUX_OFF           = PCM input is off
+ *      \li HW_PCM_INPUT_MUX_OFF           = PCM input is off
  *      HW_PCM_INPUT_MUX_SRC_OUT       = PCM input is set to SRC output
  *      HW_PCM_INPUT_MUX_PCM_OUT_REG   = PCM input is set to PCM output registers
  */
@@ -533,38 +647,42 @@ __STATIC_INLINE void hw_pcm_set_pcm_input_mux(HW_PCM_INPUT_MUX input)
 /**
  * \brief Set PCM FSC polarity
  *
- * \param[in] pol The polarity of FSC, HW_PCM_FSC_POLARITY_NORMAL or HW_PCM_FSC_POLARITY_INVERTED
+ * \param[in] pol The polarity of FSC,
+ *              \li HW_PCM_FSC_POLARITY_NORMAL or
+ *              \li HW_PCM_FSC_POLARITY_INVERTED
  *
  */
 __STATIC_INLINE void hw_pcm_set_fsc_polarity(HW_PCM_FSC_POLARITY pol)
 {
         // Set PCM_FSCINV field in PCM control register
-        REG_SETF(APU, PCM1_CTRL_REG, PCM_FSCINV, pol);
+        HW_PCM_SRC_REG_SETF(CTRL, PCM_FSCINV, pol);
 }
 
 /**
  * \brief Set PCM clock cycles per data bit
  *
  * \param[in] cycles The number of clock cycles per data bit:
- *       HW_PCM_ONE_CYCLE_PER_BIT = One clock cycle per data bit
- *       HW_PCM_TWO_CYCLE_PER_BIT = Two clock cycles per data bit
+ *       \li HW_PCM_ONE_CYCLE_PER_BIT = One clock cycle per data bit
+ *       \li HW_PCM_TWO_CYCLE_PER_BIT = Two clock cycles per data bit
  */
 __STATIC_INLINE void hw_pcm_set_clk_per_bit(HW_PCM_CYCLE_PER_BIT cycles)
 {
         // Set PCM_CLK_BIT field in PCM control register
-        REG_SETF(APU, PCM1_CTRL_REG, PCM_CLK_BIT, cycles);
+        HW_PCM_SRC_REG_SETF(CTRL, PCM_CLK_BIT, cycles);
 }
 
 /**
  * \brief Set PCM DO output mode
  *
- * \param[in] mode can be HW_PCM_DO_OUTPUT_PUSH_PULL or HW_PCM_DO_OUTPUT_OPEN_DRAIN
+ * \param[in] mode      output mode can be
+ *              \li HW_PCM_DO_OUTPUT_PUSH_PULL or
+ *              \li HW_PCM_DO_OUTPUT_OPEN_DRAIN
  *
  */
 __STATIC_INLINE void hw_pcm_set_output_mode(HW_PCM_DO_OUTPUT_MODE mode)
 {
         // Set PCM_PPOD field in PCM control register
-        REG_SETF(APU, PCM1_CTRL_REG, PCM_PPOD, mode);
+        HW_PCM_SRC_REG_SETF(CTRL, PCM_PPOD, mode);
 }
 
 /**
@@ -585,12 +703,15 @@ __STATIC_INLINE uint32_t hw_pcm_input_read(HW_PCM_INPUT input)
         default:
                 ASSERT_WARNING(0);
         }
+        return 0;
 }
 
 /**
  * \brief Write PCM output (TX) register
  *
- * \param[in] output The output register, HW_PCM_OUTPUT_REG_1 or HW_PCM_OUTPUT_REG_2
+ * \param[in] output The output register,
+ *                      \li HW_PCM_OUTPUT_REG_1 or
+ *                      \li HW_PCM_OUTPUT_REG_2
  * \param[in] data data to write to output register
  *
  */
diff --git a/sdk/bsp/peripherals/src/hw_pcm.c b/sdk/bsp/peripherals/src/hw_pcm.c
index e9dc35a..01c9e12 100644
--- a/sdk/bsp/peripherals/src/hw_pcm.c
+++ b/sdk/bsp/peripherals/src/hw_pcm.c
@@ -14,7 +14,8 @@
 #if dg_configUSE_HW_PCM
 
 #include "hw_pcm.h"
-#include <hw_clk.h>
+#include "hw_clk.h"
+
 
 #define FDIV_1_2 (0x2)       /* 1/2 */
 #define FDIV_1_3 (0x4)       /* 1/3 */
@@ -35,6 +36,7 @@
 #define FDIV_3_9 (0x111)     /* 3/9 */
 #define FDIV_7_9 (0x13F)     /* 7/9 */
 #define FDIV_8_9 (0x1FE)     /* 8/9 */
+#define FDIV_5_12 (0xA49)    /* 5/12 */
 
 typedef struct {
         uint16_t bit_clock;
@@ -63,10 +65,9 @@ static const hw_pcm_divisors_t divisors_xtal32[] = {
         { 1792,  17, FDIV_6_7,  10},
         { 1920,  16, FDIV_2_3,   0},
         { 2048,  15, FDIV_5_8,  10},
-        { 1152,  27, FDIV_7_9,   0},
         { 2304,  13, FDIV_8_9,   0},
         { 2560,  12, FDIV_1_2,  10},
-        { 3072,  10, FDIV_2_5,   0},
+        { 3072,  10, FDIV_5_12,  0},
         { 6144,  5,  FDIV_1_5,   0},
 };
 
@@ -84,73 +85,81 @@ static const hw_pcm_divisors_t divisors_pll96[] = {
         {  768,  125,        0,  125},
         {  896,  107, FDIV_1_7,  100},
         { 1024,   93, FDIV_3_4,   75},
-        { 1152,   83, FDIV_3_9,   80},
+        { 1152,   83, FDIV_1_3,   80},
         { 1280,   75,        0,   25},
         { 1536,   62, FDIV_1_2,   50},
         { 1792,   53, FDIV_4_7,   50},
         { 1920,   50,        0,   50},
         { 2048,   46, FDIV_7_8,   25},
-        { 1152,   83, FDIV_1_3,   80},
         { 2304,   41, FDIV_2_3,   40},
         { 2560,   37, FDIV_1_2,   30},
         { 3072,   31, FDIV_1_4,   25},
+        { 4608,   20, FDIV_5_6,   20},
         { 6144,   15, FDIV_5_8,   12},
 };
 
-void hw_pcm_init_clk_reg(HW_PCM_CLOCK clock, uint8_t sample_rate, uint8_t bit_num, uint8_t channel_num,
-                                                                          HW_PCM_CLK_GENERATION div)
+HW_PCM_ERROR_CODE hw_pcm_init_clk_reg(HW_PCM_CLOCK clock, uint8_t sample_rate, uint16_t fsc_div, HW_PCM_CLK_GENERATION div)
 {
         const hw_pcm_divisors_t *pdiv;
         uint8_t i;
         uint16_t bit_clock;
-        uint8_t bit_clock_num_max =  sizeof(divisors_xtal32) / sizeof(divisors_xtal32[0]);
+        uint8_t bit_clock_num_max;
 
         /* verify sample rate is supported */
-        ASSERT_WARNING((sample_rate == 8)  || (sample_rate == 16) ||
-                     (sample_rate == 32) || (sample_rate == 48) || (sample_rate == 96));
-
-        /* verify bits number is supported */
-        ASSERT_WARNING((bit_num == 8) || (bit_num == 16) || (bit_num == 24) || (bit_num == 32));
-
-        /* verify total number of channels */
-        ASSERT_WARNING((channel_num != 0) && (channel_num <= 8));
+        if (!((sample_rate == 8)  || (sample_rate == 16) ||
+                     (sample_rate == 32) || (sample_rate == 48) || (sample_rate == 96))) {
+                return HW_PCM_ERROR_INVALID_SAMPLE_RATE;
+        }
 
+#if (DEVICE_FAMILY == DA1469X)
         if (clock == HW_PCM_CLK_DIV1) {
                 /*  DIV1 clock is used so make sure system clock is set to PLL96 */
-                ASSERT_WARNING(hw_clk_get_sysclk() == SYS_CLK_IS_PLL);
-                REG_SET_BIT(CRG_PER, PCM_DIV_REG, PCM_SRC_SEL);
+                HW_PCM_CRG_REG_SET_BIT(DIV, PCM_SRC_SEL);
+                bit_clock_num_max =  sizeof(divisors_pll96) / sizeof(divisors_pll96[0]);
                 pdiv = divisors_pll96;
-        } else {
+        } else
+#endif
+        {
                 /* DIVN clock used (XTAL32M) */
-                REG_CLR_BIT(CRG_PER, PCM_DIV_REG, PCM_SRC_SEL);
+                HW_PCM_CRG_REG_CLR_BIT(DIV, PCM_SRC_SEL);
+
                 /* integer only option for sample rate 48ksps and 96ksps is not supported */
                 if (div == HW_PCM_CLK_GEN_INTEGER_ONLY) {
-                        ASSERT_WARNING(sample_rate != 48 && sample_rate != 96);
+                        if(sample_rate == 48 || sample_rate == 96){
+                                return HW_PCM_ERROR_INVALID_SAMPLE_RATE;
+                        }
                 }
+
+                bit_clock_num_max =  sizeof(divisors_xtal32) / sizeof(divisors_xtal32[0]);
                 pdiv = divisors_xtal32;
         }
 
         /* is the bit clock supported? */
-        bit_clock = sample_rate * bit_num * channel_num;
+        bit_clock = sample_rate * fsc_div;
+
         for (i = 0; i < bit_clock_num_max; i++) {
                 if (pdiv[i].bit_clock == bit_clock) {
                         break;
                 }
         }
 
-        ASSERT_WARNING(i != bit_clock_num_max);
+        if (i == bit_clock_num_max) {
+                return HW_PCM_ERROR_INVALID_BIT_CLK;
+        }
 
         if (div == HW_PCM_CLK_GEN_FRACTIONAL) {
-                REG_SETF(CRG_PER, PCM_DIV_REG, PCM_DIV, pdiv[i].div_fractional);
-                REG_SETF(CRG_PER, PCM_FDIV_REG, PCM_FDIV, pdiv[i].fdiv_fractional);
+                HW_PCM_CRG_REG_SETF(DIV, PCM_DIV, pdiv[i].div_fractional);
+                HW_PCM_CRG_REG_SETF(FDIV, PCM_FDIV, pdiv[i].fdiv_fractional);
+
         } else {
                 /* HW_PCM_CLK_GEN_INTEGER_ONLY */
-                ASSERT_WARNING(((hw_clk_get_sysclk() == SYS_CLK_IS_PLL ?
-                                         dg_configPLL96M_FREQ : dg_configXTAL32M_FREQ) /
-                                         pdiv[i].div_integer_only % sample_rate ) == 0);
-                REG_SETF(CRG_PER, PCM_DIV_REG, PCM_DIV, pdiv[i].div_integer_only);
-                REG_SETF(CRG_PER, PCM_FDIV_REG, PCM_FDIV, 0);
+                HW_PCM_CRG_REG_SETF(DIV, PCM_DIV, pdiv[i].div_integer_only);
+                HW_PCM_CRG_REG_SETF(FDIV, PCM_FDIV, 0);
         }
+
+        hw_pcm_clk_enable();
+
+        return HW_PCM_ERROR_NO_ERROR;
 }
 
 static void hw_pcm_init_generic_pcm(hw_pcm_config_generic_pcm_t *config)
@@ -173,8 +182,7 @@ static void hw_pcm_init_generic_pcm(hw_pcm_config_generic_pcm_t *config)
         hw_pcm_set_fsc_length(config->fsc_length);
 
         /* Set PCM edge */
-        hw_pcm_set_fsc_edge((config->fsc_length == 0) ? HW_PCM_FSC_EDGE_RISING :
-                                                                HW_PCM_FSC_EDGE_RISING_AND_FALLING);
+        hw_pcm_set_fsc_edge(HW_PCM_FSC_EDGE_RISING);
 
         /* For 2 clock cycles per bit fsc_div must be even */
         ASSERT_WARNING((config->cycle_per_bit == HW_PCM_ONE_CYCLE_PER_BIT) ||
diff --git a/sdk/bsp/system/sys_man/include/sys_audio_mgr.h b/sdk/bsp/system/sys_man/include/sys_audio_mgr.h
index a123170..f71c5c2 100644
--- a/sdk/bsp/system/sys_man/include/sys_audio_mgr.h
+++ b/sdk/bsp/system/sys_man/include/sys_audio_mgr.h
@@ -101,6 +101,8 @@ typedef struct {
         bool enable_dithering;                            /**< This is used to enable the dithering feature of
                                                                  the sample rate converter. */
 
+        HW_PCM_CLK_GENERATION clk_generation;
+
         HW_PCM_FSC_DELAY fsc_delay;                       /**< PCM FSC starts one cycle before MSB bit otherwise
                                                                 at the same time as MSB bit */
 
diff --git a/sdk/bsp/system/sys_man/sys_audio_mgr.c b/sdk/bsp/system/sys_man/sys_audio_mgr.c
index c22a48c..2739a53 100644
--- a/sdk/bsp/system/sys_man/sys_audio_mgr.c
+++ b/sdk/bsp/system/sys_man/sys_audio_mgr.c
@@ -21,19 +21,19 @@
 #include "sys_power_mgr.h"
 #include "resmgmt.h"
 
-#define APU_DEFAULT_SAMPLING_RATE 8000
-#define APU_DEFAULT_BITS_DEPTH 16
-#define APU_DEFAULT_PDM_FREQUENCY 4000000
-#define APU_DEFAULT_SRC_CLK 32000000
-
-/*PCM defaults */
-#define APU_DEFAULT_OUTPUT_MODE         HW_PCM_DO_OUTPUT_PUSH_PULL
-#define APU_DEFAULT_PCM_CYCLE_PER_BIT   HW_PCM_ONE_CYCLE_PER_BIT
-#define APU_DEFAULT_FSC_DELAY           HW_PCM_FSC_STARTS_SYNCH_TO_MSB_BIT
-
+#define DEFAULT_SAMPLING_RATE           8000
+#define DEFAULT_BIT_DEPTH               16
+#define DEFAULT_PDM_FREQUENCY           4000000
+#define DEFAULT_SRC_CLK                 32000000
+/* PCM Defaults */
+#define DEFAULT_PCM_OUTPUT_MODE         HW_PCM_DO_OUTPUT_PUSH_PULL
+#define DEFAULT_PCM_CYCLE_PER_BIT       HW_PCM_ONE_CYCLE_PER_BIT
+#define DEFAULT_PCM_FSC_DELAY           HW_PCM_FSC_STARTS_SYNCH_TO_MSB_BIT
+
+#define BIT_DEPTH_MAX            32
 typedef enum {
         DIRECTION_INPUT,
-        DIRECTION_OUTPUT
+        DIRECTION_OUTPUT,
 } SYS_AUDIO_MGR_DIRECTION;
 
 
@@ -57,7 +57,7 @@ bool sys_audio_mgr_default_pdm_data_init(sys_audio_device_t *dev_id, bool stereo
 
         dev_id->device_type = AUDIO_PDM;
         dev_id->pdm_param.mode = mode;
-        dev_id->pdm_param.clk_frequency = APU_DEFAULT_PDM_FREQUENCY;
+        dev_id->pdm_param.clk_frequency = DEFAULT_PDM_FREQUENCY;
         dev_id->pdm_param.channel = (stereo ? HW_PDM_CHANNEL_LR : HW_PDM_CHANNEL_R);
         dev_id->pdm_param.in_delay = HW_PDM_DI_NO_DELAY;
         dev_id->pdm_param.out_delay = HW_PDM_DO_NO_DELAY;
@@ -68,7 +68,7 @@ bool sys_audio_mgr_default_pdm_data_init(sys_audio_device_t *dev_id, bool stereo
 bool sys_audio_mgr_default_pcm_data_init(sys_audio_device_t *dev_id, uint8_t channel_total,
                                               SYS_AUDIO_MGR_MODE mode, SYS_AUDIO_MGR_PCM_FORMATS format)
 {
-        OS_ASSERT(channel_total <= 8);
+        OS_ASSERT(channel_total <= 2);
 
         memset(dev_id, 0, sizeof(sys_audio_device_t));
 
@@ -76,25 +76,28 @@ bool sys_audio_mgr_default_pcm_data_init(sys_audio_device_t *dev_id, uint8_t cha
         dev_id->pcm_param.mode = mode;
         dev_id->pcm_param.format = format;
         dev_id->pcm_param.clock = HW_PCM_CLK_DIVN;
-        dev_id->pcm_param.sample_rate = APU_DEFAULT_SAMPLING_RATE;
+        dev_id->pcm_param.sample_rate = DEFAULT_SAMPLING_RATE;
 
         dev_id->pcm_param.total_channel_num = channel_total;
         dev_id->pcm_param.channel_delay = 0;
-        dev_id->pcm_param.bits_depth = APU_DEFAULT_BITS_DEPTH;
-        dev_id->pcm_param.enable_dithering = true;
-        dev_id->pcm_param.output_mode = APU_DEFAULT_OUTPUT_MODE;
-        dev_id->pcm_param.cycle_per_bit = APU_DEFAULT_PCM_CYCLE_PER_BIT;
+        dev_id->pcm_param.bits_depth = DEFAULT_BIT_DEPTH;
+        dev_id->pcm_param.enable_dithering = false;
+        dev_id->pcm_param.clk_generation = HW_PCM_CLK_GEN_FRACTIONAL;
+        dev_id->pcm_param.output_mode = DEFAULT_PCM_OUTPUT_MODE;
+        dev_id->pcm_param.cycle_per_bit = DEFAULT_PCM_CYCLE_PER_BIT;
 
         /* Note: ignored, except for format==PCM_MODE */
-        dev_id->pcm_param.fsc_delay = APU_DEFAULT_FSC_DELAY;
+        dev_id->pcm_param.fsc_delay = DEFAULT_PCM_FSC_DELAY;
 
-        dev_id->pcm_param.inverted_fsc_polarity = false;
-        dev_id->pcm_param.inverted_clk_polarity = true;
-        /* Use default fsc_length, remember that fsc length time need to lower than fsc_div time */
-        if (channel_total > 1) {
-                dev_id->pcm_param.fsc_length = dev_id->pcm_param.total_channel_num / 2;
-        } else {
+        dev_id->pcm_param.inverted_fsc_polarity = HW_PCM_FSC_POLARITY_NORMAL;
+        dev_id->pcm_param.inverted_clk_polarity = HW_PCM_CLK_POLARITY_INVERTED;
+
+        /* Use default fsc_length in case of 1 channel and duty cycle 50% in case of two channels */
+        if (dev_id->pcm_param.total_channel_num == 1) {
                 dev_id->pcm_param.fsc_length = 0;
+        } else {
+                dev_id->pcm_param.fsc_length = (dev_id->pcm_param.bits_depth / 8) +
+                                                        dev_id->pcm_param.channel_delay;
         }
 
         return true;
@@ -114,7 +117,7 @@ bool sys_audio_mgr_default_memory_data_init(sys_audio_device_t *dev_id, bool ste
         dev_id->device_type = AUDIO_MEMORY;
         dev_id->memory_param.dma_channel[0] = HW_DMA_CHANNEL_INVALID;
         dev_id->memory_param.dma_channel[1] = HW_DMA_CHANNEL_INVALID;
-        dev_id->memory_param.bits_depth = APU_DEFAULT_BITS_DEPTH;
+        dev_id->memory_param.bits_depth = DEFAULT_BIT_DEPTH;
 
         dev_id->memory_param.buff_addr[0] = 0;
         dev_id->memory_param.buff_addr[1] = 0;
@@ -125,7 +128,7 @@ bool sys_audio_mgr_default_memory_data_init(sys_audio_device_t *dev_id, bool ste
         dev_id->memory_param.cb = cb;
         dev_id->memory_param.app_ud = ud;
         dev_id->memory_param.stereo = stereo;
-        dev_id->memory_param.sample_rate = APU_DEFAULT_SAMPLING_RATE;
+        dev_id->memory_param.sample_rate = DEFAULT_SAMPLING_RATE;
 
         internal_data[0] = 0;
         internal_data[1] = 0;
@@ -199,23 +202,27 @@ static void initialize_pdm_reg(sys_audio_path_t* path, sys_audio_pdm_specific_t
 
 __STATIC_INLINE uint16_t calculate_fsc_div(sys_audio_pcm_specific_t *param)
 {
-        return (param->bits_depth * param->total_channel_num);
-}
+        /* Channel delays are added as follow:
+         * - fsc_edge = 0 which means fsc_length = 0
+         *      after rising edge (1 time)
+         *  - fsc_edge = 1 which means fsc_length > 0
+         *      after rising and falling edge (two times)
+         *  So slot is used to count how many times channel delay is added
+         */
+        uint8_t slot = 1;
 
-static void update_pcm_params(sys_audio_pcm_specific_t *param)
-{
-        param->channel_delay = hw_pcm_get_channel_delay();
-        param->cycle_per_bit = hw_pcm_get_clk_per_bit();
-        param->fsc_delay = hw_pcm_get_fsc_delay();
-        param->fsc_length = hw_pcm_get_fsc_length();
-        param->inverted_clk_polarity = hw_pcm_get_clk_polarity();
-        param->inverted_fsc_polarity = hw_pcm_get_fsc_polarity();
+        if (param->fsc_length > 0) {
+                slot = 2;
+        }
+
+        return ((param->bits_depth * param->total_channel_num) +
+                (param->channel_delay * 8 * slot));
 }
 
-static void initialize_pcm_reg(sys_audio_pcm_specific_t *param, SYS_AUDIO_MGR_DIRECTION direction)
+static void initialize_pcm_reg(sys_audio_pcm_specific_t *param)
 {
         hw_pcm_config_t config = {0};
-        HW_PCM_CLK_GENERATION div = {0};
+        //HW_PCM_CLK_GENERATION div = {0};
 
         config.gpio_output_mode = param->output_mode;
 
@@ -225,39 +232,52 @@ static void initialize_pcm_reg(sys_audio_pcm_specific_t *param, SYS_AUDIO_MGR_DI
                 config.pcm_mode = HW_PCM_MODE_MASTER;
         }
 
+        /* verify channel number is supported */
+        OS_ASSERT(param->total_channel_num <= 2);
+
+        /* The value of bit depth must be an integer multiplier of bytes */
+        OS_ASSERT(param->bits_depth % 8 == 0);
+
+        /* The value of bit depth must not exceed the size of single pcm register */
+        OS_ASSERT(param->bits_depth <= BIT_DEPTH_MAX);
+
+        /* Maximum 2 channels of 32bits are supported */
+        OS_ASSERT(param->total_channel_num * param->bits_depth <= BIT_DEPTH_MAX * 2);
+
+        /* verify channel delay number is supported */
+        OS_ASSERT( param->channel_delay <= 31);
+
+        /* TODO: To be add to circe datasheet:
+         *  If PCM_CLK_BIT = HW_PCM_TWO_CYCLE_PER_BIT then FSCLEN = 0,
+         * else src can not operate */
+        if (param->cycle_per_bit == HW_PCM_TWO_CYCLE_PER_BIT) {
+                ASSERT_ERROR(param->fsc_length == 0);
+        }
+        uint16_t fsc_div = calculate_fsc_div(param);
+
         switch (param->format) {
         case PCM_MODE:
-                /* Maximum 8 channels of 8bits are supported */
-                OS_ASSERT(param->total_channel_num * param->bits_depth / 8 <= 64);
 
                 config.config_mode = HW_PCM_CONFIG_GENERIC_PCM_MODE;
                 config.pcm_param.cycle_per_bit = param->cycle_per_bit;
 
-                config.pcm_param.channel_delay = param->channel_delay * param->bits_depth / 8;
-
-                if (param->inverted_fsc_polarity) {
-                        config.pcm_param.fsc_polarity = HW_PCM_CLK_POLARITY_INVERTED;
-                } else {
-                        config.pcm_param.fsc_polarity = HW_PCM_CLK_POLARITY_NORMAL;
-                }
+                config.pcm_param.channel_delay = param->channel_delay;
 
-                if (param->inverted_clk_polarity) {
-                        config.pcm_param.clock_polarity = HW_PCM_CLK_POLARITY_INVERTED;
-                } else {
-                        config.pcm_param.clock_polarity = HW_PCM_CLK_POLARITY_NORMAL;
-                }
+                config.pcm_param.fsc_polarity = param->inverted_fsc_polarity;
+                config.pcm_param.clock_polarity = param->inverted_clk_polarity;
                 config.pcm_param.fsc_delay = param->fsc_delay;
-                config.pcm_param.fsc_div = calculate_fsc_div(param);
-                config.pcm_param.fsc_length = param->fsc_length * param->bits_depth / 8;
+                config.pcm_param.fsc_div = fsc_div;
+                config.pcm_param.fsc_length = param->fsc_length;
                 break;
         case I2S_MODE:
-                OS_ASSERT(param->total_channel_num * param->bits_depth / 8 <= 64);
-                ASSERT_WARNING(param->total_channel_num == 2 * param->bits_depth / 8 );
+                OS_ASSERT(param->total_channel_num == 2);
+                OS_ASSERT(param->channel_delay == 0);
+                param->fsc_length = param->bits_depth / 8;
 
                 config.config_mode = HW_PCM_CONFIG_I2S_MODE;
                 config.i2s_param.cycle_per_bit = param->cycle_per_bit;
-                config.i2s_param.fsc_length = param->bits_depth / 8;
-                config.i2s_param.fsc_div = calculate_fsc_div(param);
+                config.i2s_param.fsc_length = param->fsc_length;
+                config.i2s_param.fsc_div = fsc_div;
                 break;
         case IOM2_MODE:
                 config.config_mode = HW_PCM_CONFIG_IOM_MODE;
@@ -303,28 +323,27 @@ static void initialize_pcm_reg(sys_audio_pcm_specific_t *param, SYS_AUDIO_MGR_DI
                 break;
         }
 
-        /* When fsc_edge == HW_PCM_FSC_EDGE_RISING_AND_FALLING then the bits of the second
-         * channel begin at the falling edge of FSC. In this case the FSC length must be
-         * greater or equal to the bit_depth plus the channel offset.
+        /* The FSC length must be smaller or equal to the bit_depth plus the channel offset,
+         *  which is fsc_div
          */
 
-        OS_ASSERT(!(param->fsc_length != 0 && (param->fsc_length < (1 + param->channel_delay)) ));
+        if (param->fsc_length > 0) {
 
-        hw_pcm_init(&config);
+                OS_ASSERT((param->fsc_length <= 8)  &&
+                                        param->fsc_length * 8 <= fsc_div - 8);
 
-        if (param->enable_dithering) {
-                div = HW_PCM_CLK_GEN_FRACTIONAL;
-        } else {
-                div = HW_PCM_CLK_GEN_INTEGER_ONLY;
+                if (param->cycle_per_bit) {
+
+                        OS_ASSERT(param->cycle_per_bit > 2 * param->fsc_length);
+
+                }
         }
 
-        hw_pcm_init_clk_reg(param->clock, param->sample_rate/1000, param->bits_depth, param->total_channel_num,
-                                                                                               div);
-        /*
-         *  Update pcm user's parameters as there are pcm formats (I2S, TDM etc.) which
-         *  change some pcm parameters
-         */
-        update_pcm_params(param);
+        config.div = param->enable_dithering;
+
+        hw_pcm_init_clk_reg(param->clock, param->sample_rate/1000, fsc_div, param->clk_generation);
+        hw_pcm_init(&config);
+        hw_pcm_enable();
 }
 
 static void dma_transfer_cb(void *user_data, dma_size_t len)
@@ -588,7 +607,7 @@ static void initialize_reg(sys_audio_path_t* path, sys_audio_device_t *dev_id,
                 initialize_pdm_reg(path, &(dev_id->pdm_param), direction);
                 break;
         case AUDIO_PCM:
-                initialize_pcm_reg(&(dev_id->pcm_param), direction);
+                initialize_pcm_reg(&(dev_id->pcm_param));
                 break;
         case AUDIO_MEMORY:
                 dma_resource_mng(true, dev_id);
@@ -623,7 +642,6 @@ static uint32_t get_sampling_rate(sys_audio_device_t *dev)
 
 static void validate_config(sys_audio_device_t *dev_id_in, sys_audio_device_t *dev_id_out)
 {
-        uint8_t byte_depth;
         sys_audio_device_t *pcm_dev;
         sys_audio_device_t *mem_dev;
 
@@ -637,61 +655,31 @@ static void validate_config(sys_audio_device_t *dev_id_in, sys_audio_device_t *d
                 return;
         }
 
-        byte_depth = (pcm_dev->pcm_param.bits_depth / 8);
-
         switch (pcm_dev->pcm_param.format) {
         case PCM_MODE:
                 /* PCM mode - mono */
-               if ((pcm_dev->pcm_param.fsc_length == 0)) {
-                       OS_ASSERT(!( (mem_dev->memory_param.stereo == false) &&
-                               (pcm_dev->pcm_param.total_channel_num * byte_depth <
-                                       byte_depth * (1 + pcm_dev->pcm_param.channel_delay))
-                                       ));
-
+               if ((pcm_dev->pcm_param.total_channel_num == 1)){
+                       ASSERT_ERROR((mem_dev->memory_param.stereo == false));
+               } else {
                        /* PCM mode - stereo */
-                       OS_ASSERT(!((mem_dev->memory_param.stereo == true) &&
-                               (pcm_dev->pcm_param.total_channel_num * byte_depth <
-                                       4 + byte_depth * (1 + pcm_dev->pcm_param.channel_delay))
-                                       ));
+                       ASSERT_ERROR((mem_dev->memory_param.stereo == true));
                }
 
                break;
        case I2S_MODE:
                /* I2S mode */
-               OS_ASSERT(!(mem_dev->memory_param.stereo == false));
-
-               OS_ASSERT(!(pcm_dev->pcm_param.channel_delay > 0));
-
-               OS_ASSERT(pcm_dev->pcm_param.total_channel_num <= 8);
-               break;
        case TDM_MODE:
                /* TDM mode */
-               OS_ASSERT(!(mem_dev->memory_param.stereo == false));
 
-               OS_ASSERT(!(pcm_dev->pcm_param.fsc_length == 0));
+               OS_ASSERT(mem_dev->memory_param.stereo == true);
 
-               OS_ASSERT(!((pcm_dev->pcm_param.fsc_length != 0) &&
-                           (pcm_dev->memory_param.stereo == true) &&
-                           (pcm_dev->pcm_param.total_channel_num * byte_depth <
-                                   2 * byte_depth * (1 + pcm_dev->pcm_param.channel_delay))
-                                   ));
                break;
        case IOM2_MODE:
                /* IOM mode */
 
-               OS_ASSERT(!(pcm_dev->pcm_param.fsc_length != 0));
 
-               OS_ASSERT(!(pcm_dev->pcm_param.channel_delay > 0));
+               OS_ASSERT(mem_dev->memory_param.stereo == false);
 
-               if (dev_id_in->device_type == AUDIO_PCM) {
-                       OS_ASSERT(!((pcm_dev->pcm_param.format == IOM2_MODE) &&
-                               pcm_dev->pcm_param.total_channel_num !=
-                                       2 * (mem_dev->memory_param.stereo ? 2 : 1)
-                                       ));
-               } else {
-                       OS_ASSERT(!(mem_dev->memory_param.stereo == true));
-                       OS_ASSERT(!(pcm_dev->pcm_param.total_channel_num != 1));
-               }
                break;
        default:
                break;
@@ -704,7 +692,7 @@ sys_audio_path_t* sys_audio_mgr_open(sys_audio_device_t *dev_id_in, sys_audio_de
 {
         sys_audio_path_t* path;
 
-        if (!dev_id_in || !dev_id_out) {
+        if (!dev_id_in || !dev_id_out){
                 return NULL;
         }
 
@@ -739,7 +727,7 @@ sys_audio_path_t* sys_audio_mgr_open(sys_audio_device_t *dev_id_in, sys_audio_de
 
                 /* Initialize src */
                 /* Set src clk at kHz divide Hz by 1000 */
-                uint16_t src_clk = APU_DEFAULT_SRC_CLK/1000;
+                uint16_t src_clk = DEFAULT_SRC_CLK/1000;
 
                 /* Interfaces with sample rate (PCM/MEMORY)
                  * initialize the fsc and iir setting in apu_src
@@ -780,7 +768,7 @@ sys_audio_path_t* sys_audio_mgr_open(sys_audio_device_t *dev_id_in, sys_audio_de
                 switch (dev_id_out->device_type) {
                 case AUDIO_PCM:
                         hw_pdm_set_output_channel_config(HW_PDM_CHANNEL_NONE);
-                        hw_pcm_set_pcm_input_mux(HW_PCM_INPUT_MUX_SRC_OUT);
+                        hw_pcm_set_pcm_input_mux(HW_PCM_INPUT_MUX_SRC1_OUT);
                         break;
                 case AUDIO_PDM:
                         hw_pdm_set_output_channel_config(dev_id_out->pdm_param.channel);
@@ -829,7 +817,9 @@ static bool audio_mgr_close_device(sys_audio_device_t *dev)
         if (dev->device_type == AUDIO_MEMORY) {
                 return(close_audio_memory(&dev->memory_param));
         }
-
+        if (dev->device_type == AUDIO_PCM) {
+                hw_pcm_disable();
+        }
         return(true);
 }
 
@@ -873,7 +863,6 @@ static bool start_device(sys_audio_device_t *dev)
                 }
                 break;
         case AUDIO_PCM:
-                hw_pcm_enable();
                 ret = hw_pcm_is_enabled();
                 break;
         case AUDIO_MEMORY:
@@ -906,7 +895,6 @@ static bool  stop_device(sys_audio_path_t* path, sys_audio_device_t *dev,  SYS_A
                 }
                 break;
         case AUDIO_PCM:
-                hw_pcm_disable();
                 ret = hw_pcm_is_enabled();
                 break;
         case AUDIO_MEMORY:
@@ -931,7 +919,7 @@ static bool  stop_device(sys_audio_path_t* path, sys_audio_device_t *dev,  SYS_A
 
 bool sys_audio_mgr_start(sys_audio_path_t* path)
 {
-        bool ret;
+        bool ret = true;
 
         if (!path) {
                 return (false);

/**
 ****************************************************************************************
 *
 * @file usb_cdc_vmsd.c
 *
 * @brief USB CDC and VirtualMSD app implementation
 *
 * Copyright (C) 2016-2022 Dialog Semiconductor.
 * This computer program includes Confidential, Proprietary Information
 * of Dialog Semiconductor. All Rights Reserved.
 *
 ****************************************************************************************
 */
#include "ad_nvms.h"
#include "sys_charger.h"
#include "sys_power_mgr.h"
#include "sys_watchdog.h"
#include "hw_usb.h"
#include "USB_CDC.h"
#include "USB_MSD.h"
#include "USB_VirtualMSD.h"
#include "sys_tcs.h"

/*********************************************************************
 *
 *       Defines, configurable
 *
 **********************************************************************
 */
#define usb_main_TASK_PRIORITY              ( OS_TASK_PRIORITY_NORMAL )
#define usb_higher_TASK_PRIORITY            ( OS_TASK_PRIORITY_NORMAL+1 )

__RETAINED_RW volatile static bool run_usb_task = false;

/*********************************************************************
 *       For CDC
 **********************************************************************
 */
__RETAINED static OS_TASK usb_cdc_rx_task_handle;
__RETAINED static OS_TASK usb_cdc_tx_task_handle;
__RETAINED static OS_EVENT wait_for_rx_task_to_finish;
__RETAINED USB_CDC_HANDLE hCDC_Inst;
__RETAINED static OS_QUEUE usb_queue;

typedef struct {
        int32_t len;
        void*    pdata;
}__q_item;

static OS_TASK usb_init_task_handle;
/*********************************************************************
 *       For VMSD
 **********************************************************************
 */
#define _VIRTUALMSD_NUM_SECTORS         ( 64 )
__RETAINED_RW static OS_TASK usb_vmsd_task_handle = NULL;
static USB_HOOK UsbpHook;

//
//  Information that is used during enumeration.
//
static const USB_DEVICE_INFO _DeviceInfo = {
        0x2DCF,                                   // VendorId
        0x6003,                                   // ProductId
        "Dialog Semiconductor",                   // VendorName
        "DA1469x CDC/VirtualMSD device",          // ProductName
        "0123456789AB"                            // SerialNumber. Should be 12 character or more for compliance with Mass Storage Device Bootability spec.
};

//
// String information used when inquiring the volume 0.
//
static const USB_MSD_LUN_INFO _Lun0Info = {
        "Vendor",     // MSD VendorName
        "MSD Volume", // MSD ProductName
        "1.00",       // MSD ProductVer
        "134657890"   // MSD SerialNo
};

/*
 * readme.txt constant file content
 *
 * This is an example of a constant file.
 * The content of a constant file remains the same after each unplug-plug of the USB device.
 * Even if the file is marked as writable and the content changed and saved, those changes will be lost after the device is unplugged.
 * The use of the constant files is to provide always a file with specific content on every plugin and not allow the modification of its content, like this readme.txt file.
 */
static const uint8_t readme_txt[] = {
        0x55, 0x53, 0x42, 0x20, 0x43, 0x44, 0x43, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x20, 0x4D, 0x53, 0x44, 0x20, 0x61, 0x70, 0x70,
        0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x0A, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D,
        0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D,
        0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x0A, 0x23,
        0x4F, 0x76, 0x65, 0x72, 0x76, 0x69, 0x65, 0x77, 0x0A, 0x54, 0x68, 0x69, 0x73, 0x20, 0x61, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69,
        0x73, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x20, 0x61, 0x70, 0x70, 0x20, 0x61, 0x62, 0x6F, 0x75, 0x74, 0x20, 0x68, 0x6F, 0x77, 0x20,
        0x74, 0x6F, 0x20, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x55, 0x53, 0x42, 0x20, 0x43, 0x44, 0x43, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x56, 0x69,
        0x72, 0x74, 0x75, 0x61, 0x6C, 0x4D, 0x53, 0x44, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x2E, 0x0A,
        0x0A, 0x23, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x4D, 0x53, 0x44, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x0A, 0x56, 0x69,
        0x72, 0x74, 0x75, 0x61, 0x6C, 0x4D, 0x53, 0x44, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x77, 0x72, 0x61, 0x70, 0x70,
        0x65, 0x72, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6F,
        0x75, 0x74, 0x20, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x75, 0x6C, 0x6C, 0x20, 0x4D, 0x53,
        0x44, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x69, 0x74, 0x79, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x75, 0x67, 0x68, 0x20, 0x56, 0x69, 0x72,
        0x74, 0x75, 0x61, 0x6C, 0x4D, 0x53, 0x44, 0x27, 0x73, 0x20, 0x61, 0x62, 0x73, 0x74, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6C, 0x61, 0x79, 0x65, 0x72,
        0x20, 0x62, 0x79, 0x20, 0x72, 0x65, 0x74, 0x72, 0x69, 0x65, 0x76, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x6D, 0x61, 0x6E, 0x69, 0x70, 0x75, 0x6C, 0x61,
        0x74, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69,
        0x63, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6F, 0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x65, 0x64, 0x20, 0x74, 0x6F,
        0x20, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x20, 0x69, 0x6E, 0x20,
        0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2E, 0x0A, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x4D, 0x53, 0x44, 0x20, 0x69, 0x73, 0x20, 0x6E,
        0x6F, 0x74, 0x20, 0x61, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4D, 0x53, 0x44,
        0x2C, 0x20, 0x6A, 0x75, 0x73, 0x74, 0x20, 0x61, 0x20, 0x77, 0x72, 0x61, 0x70, 0x70, 0x65, 0x72, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x70, 0x20, 0x6F, 0x66, 0x20,
        0x74, 0x68, 0x65, 0x20, 0x4D, 0x53, 0x44, 0x2E, 0x20, 0x4D, 0x53, 0x44, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x69, 0x74, 0x79, 0x20,
        0x61, 0x6E, 0x64, 0x20, 0x41, 0x50, 0x49, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6C, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x77,
        0x69, 0x74, 0x68, 0x20, 0x56, 0x4D, 0x53, 0x44, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x76, 0x6F, 0x6C,
        0x75, 0x6D, 0x65, 0x2E, 0x0A, 0x0A, 0x3E, 0x4E, 0x6F, 0x74, 0x65, 0x3A, 0x20, 0x4E, 0x65, 0x77, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x20, 0x63, 0x72, 0x65, 0x61,
        0x74, 0x65, 0x64, 0x20, 0x61, 0x72, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x6C, 0x79, 0x20, 0x70, 0x61, 0x73, 0x73, 0x65, 0x64, 0x20, 0x74, 0x68, 0x72,
        0x6F, 0x75, 0x67, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x5F, 0x63, 0x62, 0x4F, 0x6E, 0x57, 0x72, 0x69, 0x74, 0x65, 0x28, 0x29, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x5F,
        0x63, 0x62, 0x4F, 0x6E, 0x52, 0x65, 0x61, 0x64, 0x28, 0x29, 0x20, 0x65, 0x6E, 0x61, 0x62, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x70, 0x70,
        0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x73, 0x61, 0x76, 0x65, 0x20, 0x74, 0x68, 0x65, 0x69, 0x72, 0x20, 0x63, 0x6F, 0x6E, 0x74,
        0x65, 0x6E, 0x74, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x72, 0x69, 0x65, 0x76, 0x65, 0x20, 0x69, 0x74, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x70, 0x65,
        0x72, 0x6D, 0x61, 0x6E, 0x65, 0x6E, 0x74, 0x20, 0x73, 0x74, 0x6F, 0x72, 0x61, 0x67, 0x65, 0x20, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x0A, 0x3E,
        0x6F, 0x72, 0x20, 0x72, 0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x74, 0x68,
        0x72, 0x6F, 0x75, 0x67, 0x68, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x77, 0x68, 0x69, 0x6C, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65,
        0x76, 0x69, 0x63, 0x65, 0x20, 0x69, 0x73, 0x20, 0x70, 0x6C, 0x75, 0x67, 0x67, 0x65, 0x64, 0x2E, 0x20, 0x0A, 0x3E, 0x43, 0x6F, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x74,
        0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x65, 0x78, 0x74, 0x72, 0x61,
        0x63, 0x74, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76,
        0x69, 0x63, 0x65, 0x20, 0x62, 0x79, 0x20, 0x61, 0x64, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x61,
        0x20, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79,
        0x20, 0x6F, 0x66, 0x20, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65,
        0x20, 0x70, 0x44, 0x61, 0x74, 0x61, 0x20, 0x3D, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x46, 0x69, 0x6C, 0x65, 0x53,
        0x69, 0x7A, 0x65, 0x3D, 0x3C, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x68, 0x6F, 0x73, 0x74,
        0x20, 0x69, 0x6E, 0x20, 0x3E, 0x74, 0x68, 0x65, 0x20, 0x55, 0x53, 0x42, 0x5F, 0x56, 0x4D, 0x53, 0x44, 0x5F, 0x43, 0x4F, 0x4E, 0x53, 0x54, 0x5F, 0x46, 0x49, 0x4C,
        0x45, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x20, 0x62,
        0x65, 0x66, 0x6F, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x75, 0x6D, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x0A, 0x3E, 0x46, 0x6F, 0x72,
        0x20, 0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x20, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x61,
        0x6E, 0x74, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x73,
        0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x61, 0x64, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x74, 0x72, 0x69, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68,
        0x65, 0x20, 0x55, 0x53, 0x42, 0x5F, 0x56, 0x4D, 0x53, 0x44, 0x5F, 0x43, 0x4F, 0x4E, 0x53, 0x54, 0x5F, 0x46, 0x49, 0x4C, 0x45, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79,
        0x20, 0x6F, 0x66, 0x20, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x6E,
        0x20, 0x63, 0x61, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x55, 0x53, 0x42, 0x44, 0x5F, 0x56, 0x4D, 0x53, 0x44, 0x5F, 0x52, 0x65, 0x49, 0x6E, 0x69, 0x74, 0x28,
        0x29, 0x3B, 0x20, 0x0A, 0x3E, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x2D, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x69, 0x7A, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x56,
        0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x20, 0x53, 0x74, 0x6F, 0x72, 0x61, 0x67, 0x65, 0x20, 0x61, 0x72, 0x65, 0x61, 0x2E, 0x0A, 0x3E, 0x54, 0x6F, 0x20, 0x65, 0x78,
        0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x75, 0x67, 0x68, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x2C, 0x20,
        0x74, 0x68, 0x65, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x75, 0x6C, 0x6C, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x69, 0x74, 0x79,
        0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4D, 0x53, 0x44, 0x20, 0x69, 0x73, 0x20, 0x73, 0x75, 0x67, 0x67, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 0x75, 0x73,
        0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4E, 0x56, 0x4D, 0x53, 0x20, 0x61, 0x73, 0x20, 0x6C, 0x6F, 0x77, 0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x20, 0x6D,
        0x65, 0x64, 0x69, 0x75, 0x6D, 0x20, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20,
        0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6E, 0x61, 0x6C, 0x20, 0x46, 0x41, 0x54, 0x2D, 0x46, 0x53, 0x20, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E,
        0x74, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x46, 0x41,
        0x54, 0x2D, 0x46, 0x53, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x27, 0x73, 0x20,
        0x73, 0x74, 0x6F, 0x72, 0x61, 0x67, 0x65, 0x2E, 0x0A, 0x0A, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2E, 0x0A, 0x0A, 0x46, 0x6F, 0x72,
        0x20, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6C, 0x73, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20,
        0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x4D, 0x53, 0x44, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x4D, 0x53, 0x44, 0x20, 0x70, 0x6C, 0x65, 0x61, 0x73, 0x65, 0x20, 0x72,
        0x65, 0x66, 0x65, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x53, 0x45, 0x47, 0x47, 0x45, 0x52, 0x20, 0x64, 0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x61, 0x74, 0x69, 0x6F,
        0x6E, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x53, 0x45, 0x47, 0x47, 0x45, 0x52, 0x20, 0x73, 0x75, 0x70, 0x70, 0x6F, 0x72, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68,
        0x65, 0x20, 0x65, 0x6D, 0x55, 0x53, 0x42, 0x2D, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x55, 0x53, 0x42, 0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x2E, 0x0A, 0x23,
        0x23, 0x20, 0x55, 0x53, 0x42, 0x20, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x0A, 0x2D, 0x20, 0x55, 0x53, 0x42, 0x20, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x65, 0x6E, 0x61, 0x62, 0x6C, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x62, 0x65, 0x6C, 0x6F, 0x77, 0x20,
        0x64, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x63, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x5C, 0x5F, 0x63, 0x6F, 0x6E, 0x66, 0x69, 0x67, 0x5C, 0x5F,
        0x71, 0x73, 0x70, 0x69, 0x2E, 0x68, 0x2E, 0x0A, 0x60, 0x60, 0x60, 0x63, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x23, 0x64, 0x65, 0x66, 0x69, 0x6E,
        0x65, 0x20, 0x64, 0x67, 0x5F, 0x63, 0x6F, 0x6E, 0x66, 0x69, 0x67, 0x55, 0x53, 0x45, 0x5F, 0x53, 0x59, 0x53, 0x5F, 0x43, 0x48, 0x41, 0x52, 0x47, 0x45, 0x52, 0x20,
        0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x0A, 0x09, 0x20, 0x20, 0x20, 0x20, 0x23, 0x64, 0x65, 0x66,
        0x69, 0x6E, 0x65, 0x20, 0x64, 0x67, 0x5F, 0x63, 0x6F, 0x6E, 0x66, 0x69, 0x67, 0x55, 0x53, 0x45, 0x5F, 0x55, 0x53, 0x42, 0x5F, 0x45, 0x4E, 0x55, 0x4D, 0x45, 0x52,
        0x41, 0x54, 0x49, 0x4F, 0x4E, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x0A, 0x60, 0x60, 0x60, 0x0A, 0x2D, 0x20, 0x55,
        0x53, 0x42, 0x20, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x77, 0x6F, 0x72, 0x6B, 0x20, 0x69, 0x73, 0x20, 0x62, 0x61, 0x73, 0x65, 0x64, 0x20, 0x6F, 0x6E, 0x20, 0x53, 0x65,
        0x67, 0x67, 0x65, 0x72, 0x20, 0x65, 0x6D, 0x55, 0x53, 0x42, 0x2D, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x66, 0x65, 0x72, 0x20, 0x74, 0x6F,
        0x20, 0x62, 0x65, 0x6C, 0x6F, 0x77, 0x20, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x72, 0x6D,
        0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x0A, 0x09, 0x2D, 0x20, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x73, 0x65, 0x67, 0x67, 0x65,
        0x72, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x65, 0x6D, 0x75, 0x73, 0x62, 0x2E, 0x68, 0x74, 0x6D, 0x6C, 0x0A, 0x0A, 0x4E, 0x6F, 0x74, 0x65, 0x3A, 0x0A, 0x0A, 0x20, 0x20,
        0x20, 0x20, 0x2D, 0x20, 0x64, 0x67, 0x5F, 0x63, 0x6F, 0x6E, 0x66, 0x69, 0x67, 0x55, 0x53, 0x45, 0x5F, 0x53, 0x59, 0x53, 0x5F, 0x43, 0x48, 0x41, 0x52, 0x47, 0x45,
        0x52, 0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x31, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x69, 0x66, 0x20, 0x63, 0x68, 0x61, 0x72, 0x67,
        0x65, 0x72, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x69, 0x74, 0x79, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x65, 0x65, 0x64, 0x65, 0x64, 0x2E,
        0x0A, 0x20, 0x20, 0x20, 0x20, 0x2D, 0x20, 0x73, 0x64, 0x6B, 0x2F, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x73, 0x2F, 0x75, 0x73, 0x62, 0x20, 0x6C,
        0x69, 0x62, 0x72, 0x61, 0x72, 0x79, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x62, 0x75,
        0x69, 0x6C, 0x74, 0x2E, 0x0A, 0x0A, 0x23, 0x23, 0x20, 0x43, 0x6F, 0x6E, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6D,
        0x65, 0x74, 0x65, 0x72, 0x73, 0x0A, 0x2D, 0x20, 0x54, 0x68, 0x65, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20,
        0x66, 0x6F, 0x72, 0x20, 0x75, 0x73, 0x62, 0x20, 0x50, 0x49, 0x44, 0x2F, 0x56, 0x49, 0x44, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64,
        0x20, 0x64, 0x75, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x64, 0x65, 0x76, 0x65, 0x6C, 0x6F, 0x70, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x70, 0x65, 0x72, 0x69, 0x6F, 0x64, 0x2E,
        0x20, 0x49, 0x74, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x79, 0x6F,
        0x75, 0x72, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x6E, 0x79, 0x27, 0x73, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x2E, 0x0A, 0x09, 0x2D, 0x20, 0x55, 0x53, 0x42,
        0x20, 0x50, 0x49, 0x44, 0x2F, 0x56, 0x49, 0x44, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x63, 0x6F, 0x6D, 0x20, 0x70, 0x6F, 0x72, 0x74, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20,
        0x69, 0x6E, 0x20, 0x75, 0x73, 0x62, 0x5F, 0x63, 0x64, 0x63, 0x5F, 0x76, 0x6D, 0x73, 0x64, 0x2E, 0x63, 0x2E, 0x0A, 0x09, 0x2D, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F,
        0x77, 0x73, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x28, 0x64, 0x69, 0x61, 0x6C, 0x6F, 0x67, 0x5F, 0x75, 0x73, 0x62, 0x2E, 0x69, 0x6E, 0x66, 0x29, 0x2E, 0x0A,
        0x2D, 0x20, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x4D, 0x53, 0x44, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x6D, 0x75, 0x6C, 0x61, 0x74, 0x65, 0x64,
        0x20, 0x46, 0x41, 0x54, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20,
        0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x73, 0x74, 0x6F, 0x72, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x52, 0x41, 0x4D, 0x20, 0x6F, 0x72, 0x20, 0x4E, 0x56, 0x4D,
        0x53, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0x20, 0x62, 0x65, 0x6C, 0x6F, 0x77,
        0x20, 0x64, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x75, 0x73, 0x62, 0x5C, 0x5F, 0x63, 0x64, 0x63, 0x5C, 0x5F, 0x76, 0x6D, 0x73, 0x64, 0x2E, 0x63,
        0x2E, 0x0A, 0x0A, 0x60, 0x60, 0x60, 0x63, 0x0A, 0x09, 0x23, 0x64, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x20, 0x56, 0x4D, 0x53, 0x44, 0x5F, 0x55, 0x53, 0x45, 0x5F, 0x4E,
        0x56, 0x4D, 0x53, 0x0A, 0x60, 0x60, 0x60, 0x0A, 0x2D, 0x20, 0x53, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x46, 0x41,
        0x54, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x61, 0x64, 0x6A, 0x75, 0x73, 0x74, 0x65, 0x64, 0x2E, 0x0A, 0x0A, 0x60, 0x60, 0x60, 0x63, 0x0A, 0x09, 0x23,
        0x64, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x20, 0x56, 0x49, 0x52, 0x54, 0x55, 0x41, 0x4C, 0x4D, 0x53, 0x44, 0x5F, 0x4E, 0x55, 0x4D, 0x5F, 0x53, 0x45, 0x43, 0x54, 0x4F,
        0x52, 0x53, 0x20, 0x28, 0x36, 0x34, 0x29, 0x0A, 0x60, 0x60, 0x60, 0x0A, 0x0A, 0x23, 0x23, 0x20, 0x4F, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F,
        0x66, 0x20, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x4D, 0x53, 0x44, 0x0A, 0x2D, 0x20, 0x43, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20,
        0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x70, 0x6F, 0x77, 0x65, 0x72, 0x20, 0x55, 0x53, 0x42, 0x20, 0x28, 0x20, 0x55, 0x53, 0x42, 0x32, 0x28, 0x44, 0x42, 0x47, 0x29,
        0x20, 0x6F, 0x6E, 0x20, 0x61, 0x20, 0x70, 0x72, 0x6F, 0x44, 0x4B, 0x20, 0x29, 0x2E, 0x0A, 0x2D, 0x20, 0x52, 0x75, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78,
        0x61, 0x6D, 0x70, 0x6C, 0x65, 0x20, 0x61, 0x70, 0x70, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x0A, 0x2D, 0x20,
        0x43, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x20, 0x55, 0x53, 0x42, 0x20, 0x28, 0x20, 0x55, 0x53, 0x42, 0x31, 0x28, 0x43, 0x48, 0x47, 0x29, 0x20, 0x6F, 0x6E, 0x20,
        0x61, 0x20, 0x50, 0x72, 0x6F, 0x44, 0x4B, 0x20, 0x29, 0x20, 0x74, 0x6F, 0x20, 0x48, 0x6F, 0x73, 0x74, 0x28, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x29, 0x2E, 0x0A,
        0x2D, 0x20, 0x4E, 0x6F, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x61, 0x6C, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x71, 0x75,
        0x69, 0x72, 0x65, 0x64, 0x2E, 0x0A, 0x2D, 0x20, 0x43, 0x6F, 0x6E, 0x66, 0x69, 0x72, 0x6D, 0x20, 0x61, 0x20, 0x70, 0x6F, 0x72, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20,
        0x73, 0x74, 0x6F, 0x72, 0x61, 0x67, 0x65, 0x20, 0x64, 0x69, 0x73, 0x6B, 0x20, 0x69, 0x73, 0x20, 0x61, 0x74, 0x74, 0x61, 0x63, 0x68, 0x65, 0x64, 0x20, 0x74, 0x6F,
        0x20, 0x48, 0x6F, 0x73, 0x74, 0x2E, 0x0A, 0x2D, 0x20, 0x31, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x69, 0x73, 0x20, 0x73, 0x68, 0x6F, 0x77, 0x6E, 0x20, 0x61, 0x74,
        0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x6F, 0x72, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x73, 0x74, 0x6F, 0x72, 0x61, 0x67, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x48, 0x6F,
        0x73, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x27, 0x52, 0x45, 0x41, 0x44, 0x4D, 0x45, 0x2E, 0x74, 0x78,
        0x74, 0x27, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x61, 0x64, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x0A, 0x2D, 0x20, 0x41, 0x20, 0x6E, 0x65, 0x77,
        0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x64, 0x20, 0x60, 0x60, 0x46, 0x57, 0x2E, 0x42, 0x49, 0x4E, 0x60, 0x60, 0x20, 0x28, 0x63, 0x61, 0x73,
        0x65, 0x20, 0x73, 0x65, 0x6E, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65, 0x29, 0x20, 0x73, 0x68, 0x61, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74,
        0x65, 0x64, 0x2F, 0x63, 0x6F, 0x70, 0x69, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x56, 0x4D, 0x53, 0x44, 0x20, 0x73, 0x74, 0x6F, 0x72, 0x61,
        0x67, 0x65, 0x2C, 0x0A, 0x20, 0x20, 0x69, 0x74, 0x73, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20,
        0x77, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4C, 0x4F, 0x47, 0x20, 0x70, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6F,
        0x6E, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x46, 0x4C, 0x41, 0x53, 0x48, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x77,
        0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x69, 0x62, 0x6C, 0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20,
        0x61, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x0A, 0x20, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6F, 0x75, 0x74,
        0x20, 0x61, 0x6E, 0x79, 0x20, 0x6E, 0x65, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D,
        0x20, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x75, 0x6E, 0x70, 0x6C, 0x75, 0x67, 0x20,
        0x74, 0x68, 0x65, 0x20, 0x55, 0x53, 0x42, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2E, 0x0A, 0x20, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74,
        0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x65, 0x78, 0x61, 0x6D, 0x70,
        0x6C, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4E, 0x56, 0x4D, 0x53, 0x5F, 0x50, 0x41,
        0x52, 0x54, 0x20, 0x74, 0x68, 0x6F, 0x75, 0x67, 0x68, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x2C, 0x20, 0x6F, 0x72, 0x20,
        0x65, 0x76, 0x65, 0x6E, 0x20, 0x70, 0x65, 0x72, 0x66, 0x6F, 0x72, 0x6D, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 0x46, 0x57, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65,
        0x20, 0x62, 0x79, 0x20, 0x6A, 0x75, 0x73, 0x74, 0x20, 0x64, 0x72, 0x61, 0x67, 0x20, 0x27, 0x6E, 0x27, 0x20, 0x64, 0x72, 0x6F, 0x70, 0x20, 0x74, 0x68, 0x65, 0x20,
        0x6E, 0x65, 0x77, 0x20, 0x46, 0x57, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x56, 0x4D, 0x53, 0x44, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2E, 0x0A,
        0x2D, 0x20, 0x41, 0x66, 0x74, 0x65, 0x72, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x2F, 0x63, 0x6F, 0x70, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x60,
        0x60, 0x46, 0x57, 0x2E, 0x42, 0x49, 0x4E, 0x60, 0x60, 0x66, 0x69, 0x6C, 0x65, 0x2C, 0x20, 0x65, 0x6A, 0x65, 0x63, 0x74, 0x2F, 0x64, 0x69, 0x73, 0x63, 0x6F, 0x6E,
        0x6E, 0x65, 0x63, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x55, 0x53, 0x42, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x6C,
        0x79, 0x2C, 0x20, 0x75, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4F, 0x2F, 0x53, 0x20, 0x69, 0x6E, 0x66, 0x72, 0x61, 0x73, 0x74, 0x72, 0x75, 0x63,
        0x74, 0x75, 0x72, 0x65, 0x20, 0x28, 0x63, 0x6C, 0x69, 0x63, 0x6B, 0x20, 0x74, 0x6F, 0x3A, 0x20, 0x22, 0x53, 0x61, 0x66, 0x65, 0x6C, 0x79, 0x20, 0x52, 0x65, 0x6D,
        0x6F, 0x76, 0x65, 0x20, 0x48, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x45, 0x6A, 0x65, 0x63, 0x74, 0x20, 0x4D, 0x65, 0x64, 0x69,
        0x61, 0x22, 0x29, 0x0A, 0x2D, 0x20, 0x52, 0x65, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x55, 0x53, 0x42, 0x20, 0x64, 0x65, 0x76,
        0x69, 0x63, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x60, 0x60, 0x52, 0x45, 0x41, 0x44,
        0x4D, 0x45, 0x2E, 0x74, 0x78, 0x74, 0x60, 0x60, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x69, 0x73, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x61, 0x70, 0x70, 0x65, 0x61,
        0x72, 0x65, 0x64, 0x2E, 0x0A, 0x0A, 0x23, 0x23, 0x20, 0x4F, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x55, 0x53, 0x42, 0x20, 0x43,
        0x44, 0x43, 0x0A, 0x2D, 0x20, 0x20, 0x52, 0x65, 0x66, 0x65, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x52, 0x45, 0x41, 0x44, 0x4D, 0x45, 0x2E, 0x6D, 0x64, 0x20, 0x69, 0x6E,
        0x20, 0x75, 0x73, 0x62, 0x5F, 0x63, 0x64, 0x63, 0x20, 0x70, 0x72, 0x6F, 0x6A, 0x65, 0x63, 0x74, 0x2E, 0x0A,
       };

/* Constant files definition which should be displayed on the virtual volume. */
static USB_VMSD_CONST_FILE _aConstFiles[] = {
        // sName        pData           FileSize                Flags
        { "readme.txt", readme_txt,     sizeof(readme_txt),     0, },
};

static int usb_read_from_nvms(nvms_partition_id_t nv_id, uint8* pData, uint32 Off, uint32 Numbytes)
{
        nvms_t nvms;

        nvms = ad_nvms_open(nv_id);

        if (nvms) {
                ad_nvms_read(nvms, Off, pData, Numbytes);
                return 0;
        }
        return -1;
}

static int usb_write_to_nvms(nvms_partition_id_t nv_id, uint8* pData, uint32 Off, uint32 Numbytes)
{
        nvms_t nvms;

        nvms = ad_nvms_open(nv_id);

        if (nvms) {
                ad_nvms_write(nvms, Off, pData, Numbytes);
                ad_nvms_flush(nvms, true);
                return 0;
        }
        return -1;
}

/*********************************************************************
 *
 *       _cbOnWrite
 *
 *  Parameters
 *    Lun       LUN ID
 *    pData     Data to be written
 *    Off       Offset into current file to be written
 *    NumBytes  Number of bytes to write into the file
 *    pFile     *Optional* Additional information about the file being written (RootDir entry etc.)
 *
 * Note : The contents written in a constant file are not passed to the _cbOnWrite()
 *        to allow the application to save them to an alternative and probably permanent storage.
 ***********************************************************************/
static int _cbOnWrite(unsigned Lun, const U8* pData, U32 Off, U32 NumBytes, const USB_VMSD_FILE_INFO* pFile)
{
       if (pFile != NULL
                && (strncmp("FW ", (char *)pFile->pDirEntry->acFilename, 3) == 0)
                && (strncmp("BIN", (char *)pFile->pDirEntry->acExt, 3) == 0)
                && pData != NULL) {
                usb_write_to_nvms(NVMS_LOG_PART, (uint8_t *)pData, Off, NumBytes);
        }

        return 0;
}

/*********************************************************************
 *
 *       _cbOnRead
 *
 *  Parameters
 *    Lun       LUN ID
 *    pData     Data which will be sent to the host
 *    Off       Offset of the current file requested by the host
 *    NumBytes  Number of bytes to read
 *    pFile     *Optional* Additional information about the file being written (RootDir entry etc.)
 *
 ***********************************************************************/
static int _cbOnRead(unsigned Lun, U8* pData, U32 Off, U32 NumBytes, const USB_VMSD_FILE_INFO* pFile)
{
        (void)Lun;
        (void)Off;
        (void)NumBytes;
        (void)pFile;

        if (pFile != NULL
            && (strncmp("FW ", (char *)pFile->pDirEntry->acFilename, 3) == 0)
            && (strncmp("BIN", (char *)pFile->pDirEntry->acExt, 3) == 0)
            && pData != NULL) {
                usb_read_from_nvms(NVMS_LOG_PART, (uint8_t *)pData, Off, NumBytes);
        }

        return 0;
}

static void *_memAlloc(U32 size)
{
        return OS_MALLOC(size);
}

static void _memFree(void *p)
{
        OS_FREE(p);
}

static const USB_VMSD_USER_FUNC_API _UserFuncAPI = {
        _cbOnRead,     // pfOnRead    -> Is called when a sector of a given file is read.
        _cbOnWrite,    // pfOnWrite   -> Is called when a sector of a given file is written.
        _memAlloc,     // pfMemAlloc  -> Optional, can be set in order to allow the VirtualMSD to share the mem alloc function of a system.
        _memFree       // pfMemFree   -> Optional, can be set in order to allow the VirtualMSD to share the mem free function of a system.
};

/*********************************************************************
 *
 *       USB_VMSD_X_Config
 *
 *  Function description
 *    This function is called by the USB MSD Module during
 *    USB_VirtualMSD_Add() and initializes the VirtualMSD volume.
 *********************************************************************/
void USB_VMSD_X_Config(void)
{
        //
        // Global configuration
        //
        USBD_VMSD_SetUserAPI(&_UserFuncAPI);

        //
        // Setup LUN0
        //
        USBD_VMSD_SetNumSectors(0, _VIRTUALMSD_NUM_SECTORS);
        USBD_VMSD_SetSectorsPerCluster(0, 1); // Anywhere from 1 ... 128, but needs to be a Power of 2
        USBD_VMSD_SetNumRootDirSectors(0, 1); // 1 sectors --> up to 15 files/folders
        USBD_VMSD_SetVolumeInfo(0, "VMSD", &_Lun0Info);   // Add volume ID

        USBD_VMSD_AddConstFiles(0, _aConstFiles, SEGGER_COUNTOF(_aConstFiles)); // Push const file to the volume
}

static void usb_vmsd_task(void *params)
{
        volatile unsigned state;

        /* VMSD interface */
        while (run_usb_task) {

                /* check for device configuration or suspend state */
                state = USBD_GetState();

                if (((state & USB_STAT_CONFIGURED) == USB_STAT_CONFIGURED) &&
                    !(state & USB_STAT_SUSPENDED)) {
                        /* USB device is configured and not in suspend state
                         * Start the MSD polling task*/
                        USBD_MSD_Task();
                } else {
                        /* USB device is not configured or in suspend state
                         * wait to become configured and then use it */
                        OS_DELAY_MS(50);
                }
        }

        usb_vmsd_task_handle = NULL;
        OS_TASK_DELETE(OS_GET_CURRENT_TASK());
}

uint32_t USB_VMSD_FS_BootSector_VolID_Config(void)
{
        /* Use product info as volume id of the VMSD device */
        uint32_t *variant = NULL;
        uint8_t size = 0;

        sys_tcs_get_custom_values(SYS_TCS_GROUP_PROD_INFO, &variant, &size);

        // If the Device Variant entry has been successfully retrieved
        if ((size == 3) && (variant != NULL)) {
                return *variant;
        }

        return 0;
}
/*********************************************************************
 *
 *       usb_cdc_vmsd_state_cb
 *
 *  Function description
 *    This is the callback that will be called bu the emUSB stack
 *    to inform the application about the USB device state.
 *
 *********************************************************************/
void usb_cdc_vmsd_state_cb(void * pContext, U8 NewState)
{
        if (NewState & USB_STAT_ATTACHED) {
                //Attached
        }

        if (NewState & USB_STAT_READY) {
                //Ready
        }

        if (NewState & USB_STAT_ADDRESSED) {
                //Addressed
        }

        if (NewState & USB_STAT_CONFIGURED) {
                //Configured
        }

        if (NewState & USB_STAT_SUSPENDED) {
                //Suspended
        }
}

/*********************************************************************
 *
 *       _AddCDC
 *
 *  Function description
 *    Add communication device class to USB stack
 *
 *********************************************************************/
static USB_CDC_HANDLE _AddCDC(void)
{
        static U8 _abOutBuffer[USB_MAX_PACKET_SIZE];
        USB_CDC_INIT_DATA InitData;
        USB_CDC_HANDLE hInst;

        InitData.EPIn = USBD_AddEP(USB_DIR_IN, USB_TRANSFER_TYPE_BULK, 0, NULL, 0);
        InitData.EPOut = USBD_AddEP(USB_DIR_OUT, USB_TRANSFER_TYPE_BULK, 0, _abOutBuffer,
                USB_MAX_PACKET_SIZE);
        InitData.EPInt = USBD_AddEP(USB_DIR_IN, USB_TRANSFER_TYPE_INT, 8, NULL, 0);
        hInst = USBD_CDC_Add(&InitData);

        return hInst;
}

/*********************************************************************
 *
 *       usb_cdc_RX_task
 *
 *  Function description
 *    Waits for bytes to come from the USB-UART and push then in the \
 *    internal data queue
 *********************************************************************/
static void usb_cdc_RX_task(void *params)
{
        volatile unsigned state;
        static __q_item q_item;

#if dg_configUSE_WDOG
        static int8_t usb_cdc_task_wdog_id = -1;

        /* register usb_cdc_task task to be monitored by watchdog */
        usb_cdc_task_wdog_id = sys_watchdog_register(false);
#endif

        while (run_usb_task) {
#if dg_configUSE_WDOG
                /* notify watchdog on each loop */
                sys_watchdog_notify(usb_cdc_task_wdog_id);
#endif

                /* check for device configuration or suspend state */
                state = USBD_GetState();

                /* USB device is configured and not in suspend state */
                if (((state & USB_STAT_CONFIGURED) == USB_STAT_CONFIGURED) && !(state & USB_STAT_SUSPENDED)) {
                        /* Allocate space for one buffer */
                        /* Memory allocation failure is handled by the respective OS hook function */
                        q_item.pdata = OS_MALLOC(USB_MAX_PACKET_SIZE);
#if dg_configUSE_WDOG
                        /* suspend watchdog while blocking on USBD_CDC_Receive */
                        sys_watchdog_suspend(usb_cdc_task_wdog_id);
#endif
                        /* Receive at maximum of USB_MAX_PACKET_SIZE bytes
                         * If less data has been received, should be OK.
                         * If zero or negative is returned then there is a problem */
                        q_item.len = USBD_CDC_Receive(hCDC_Inst, q_item.pdata, USB_MAX_PACKET_SIZE, 0);
#if dg_configUSE_WDOG
                        /* resume watchdog */
                        sys_watchdog_notify_and_resume(usb_cdc_task_wdog_id);
#endif

                        if (q_item.len > 0 && q_item.len <= USB_MAX_PACKET_SIZE) {
                                /* put the received data in the queue
                                 * at this point it can be useful to choose what to do when
                                 * the queue is full.
                                 * Options:
                                 *      - No wait and drop the received data (0)
                                 *        Need to free also the RAM for the q_item.prt in this case if fails to enqueue
                                 *      - Wait for some timeout for the queue to free some space (timeout).
                                 *        Need to free also the RAM for the q_item.prt in this case if fails to enqueue
                                 *      - Block forever until the queue gets some free space */
                                OS_QUEUE_PUT(usb_queue, &q_item, OS_QUEUE_FOREVER);
                        } else {
                                /* if nothing received or an error occurred, then release the RAM allocated
                                 * for the buffer */
                                OS_FREE(q_item.pdata);
                        }
                } else {
                        /* if device is not ready, give it a time and retry */
                        OS_DELAY_MS(50);
                }
        }

        /* signal the TX task that we are done with the queue
         * so it has to exit and clean the queue */
        q_item.len = 0;
        q_item.pdata = NULL;
        OS_QUEUE_PUT(usb_queue, &q_item, OS_QUEUE_FOREVER);

        /* Rx task gives the semaphore to allow the TX task to delete the queue */
        OS_EVENT_SIGNAL(wait_for_rx_task_to_finish);

#if dg_configUSE_WDOG
        /* unregister the watchdog */
        sys_watchdog_unregister(usb_cdc_task_wdog_id);
        /* invalidate the WD ID for the task */
        usb_cdc_task_wdog_id = -1;
#endif

        usb_cdc_rx_task_handle = NULL;

        /* terminate the task */
        OS_TASK_DELETE(OS_GET_CURRENT_TASK());
}

/*********************************************************************
 *
 *       usb_cdc_TX_task
 *
 *  Function Description
 *    Received bytes form the from the internal OS Queue and sends
 *    them back  to the USB-UART
 *
 *********************************************************************/
static void usb_cdc_TX_task(void *params)
{
        volatile unsigned state;
        static __q_item q_item;

#if dg_configUSE_WDOG
        static int8_t usb_cdc_task_wdog_id = -1;

        /* register usb_cdc_task task to be monitored by watchdog */
        usb_cdc_task_wdog_id = sys_watchdog_register(false);
#endif

        while (run_usb_task) {
#if dg_configUSE_WDOG
                /* suspend watchdog while blocking on USBD_CDC_Receive */
                sys_watchdog_suspend(usb_cdc_task_wdog_id);
#endif
                /* Receive the next item from the queue */
                if (OS_QUEUE_GET(usb_queue, &q_item, OS_QUEUE_FOREVER) == OS_QUEUE_OK) {
#if dg_configUSE_WDOG
                        /* resume watchdog */
                        sys_watchdog_notify_and_resume(usb_cdc_task_wdog_id);
#endif

                        if (q_item.len > 0) {
                                /* check for device configuration or suspend state */
                                do {
                                        state = USBD_GetState();

                                        if (((state & USB_STAT_CONFIGURED) == USB_STAT_CONFIGURED) &&     /* device is configured */
                                                ((state & USB_STAT_SUSPENDED) != USB_STAT_SUSPENDED)) {         /* device is NOT in suspend state */
                                                /* send to CDC interface the received pointer */
                                                USBD_CDC_Write(hCDC_Inst, q_item.pdata, q_item.len, 0);
                                                break;
                                        } else {
                                                /* if device is not ready, give it a time and retry */
                                                OS_DELAY_MS(50);
                                        }
                                } while (run_usb_task);
                                /* free the used RAM */
                                OS_FREE(q_item.pdata);
                        } else {
                                /* Receiving a queue item with zero length is the signal to end the task
                                 * This is application specific. The developer can choose any exit
                                 * condition is most suitable for their application. */
                                break;
                        }

                } else {
#if dg_configUSE_WDOG
                        /* resume watchdog */
                        sys_watchdog_notify_and_resume(usb_cdc_task_wdog_id);
#endif
                }
        }

        /* TX task takes the semaphore to make sure the RX task is terminated and done with the queue */
        OS_EVENT_WAIT(wait_for_rx_task_to_finish, OS_EVENT_FOREVER);

        /* release the space allocated for the queue items q_item.ptr */
        uint32_t q_items = OS_QUEUE_MESSAGES_WAITING(usb_queue);
        for (uint32_t i = 0; i < q_items; i++) {
                /* It is safe to call with NULL pointer
                 * so there is no problem with the
                 * NULL entry from RX task used for
                 * signaling that we need to exit the task */
                OS_FREE(q_item.pdata);
        }

        /* delete the queue */
        OS_QUEUE_DELETE(usb_queue);
        /* invalidate the queue handler */
        usb_queue = NULL;

        /* Delete the semaphore. It will be created again on the next USB-plugin */
        OS_EVENT_DELETE(wait_for_rx_task_to_finish);

#if dg_configUSE_WDOG
        /* unregister the watchdog */
        sys_watchdog_unregister(usb_cdc_task_wdog_id);
        /* invalidate the WD ID for the task */
        usb_cdc_task_wdog_id = -1;
#endif

        usb_cdc_tx_task_handle = NULL;

        /* terminate the task */
        OS_TASK_DELETE(OS_GET_CURRENT_TASK());
}

/*********************************************************************
 *
 *       usb_init_task
 *
 *  Function Description
 *    This is the initialization stack of the whole USB functionality
 *    The Tasks, Queues, and SEGGER initialization should happen here.
 *    When everything is ready this task should exit and delete itself.
 *
 *********************************************************************/
static void usb_init_task(void *params)
{
        OS_BASE_TYPE status;

        /* Configuration of USB */
        USBD_Init();
        USBD_EnableIAD();
        USBD_CDC_Init();
        USBD_VMSD_Init();
        hCDC_Inst = _AddCDC();
        USBD_VMSD_Add();
        USBD_SetDeviceInfo(&_DeviceInfo);
        /* Interrupt handling in application level */
        USBD_RegisterSCHook(&UsbpHook, usb_cdc_vmsd_state_cb, NULL);
#if ( dg_configUSE_SYS_CHARGER == 1 )
        /* Request the minimum guaranteed current budget. */
        USBD_SetMaxPower(hw_charger_i_level_to_miliamp(HW_CHARGER_I_LEVEL_500));
#endif
        /* Start USB */
        USBD_Start();

        /* CDC interface */
        /* Create the queue to use for passing the RX to TX for the simple loopback */
        OS_QUEUE_CREATE(usb_queue, sizeof(__q_item), 20);
        OS_ASSERT(usb_queue != NULL);

        OS_EVENT_CREATE(wait_for_rx_task_to_finish);

        /* Start the USB CDC RX application task. */
        status = OS_TASK_CREATE("USB CDC RX Task",      /* The text name assigned to the task, for
                                                         * debug only; not used by the kernel.      */
                usb_cdc_RX_task,                        /* The function that implements the task.   */
                NULL,                                   /* The parameter passed to the task.        */
                512,                                    /* The number of bytes to allocate to the
                                                         * stack of the task.                       */
                usb_main_TASK_PRIORITY,                 /* The priority assigned to the task.       */
                usb_cdc_rx_task_handle);                /* The task handle.                         */

        OS_ASSERT(status == OS_TASK_CREATE_SUCCESS);

        /* Start the USB CDC TX application task. */
        status = OS_TASK_CREATE("USB CDC TX Task",      /* The text name assigned to the task, for
                                                         * debug only; not used by the kernel.      */
                usb_cdc_TX_task,                        /* The function that implements the task.   */
                NULL,                                   /* The parameter passed to the task.        */
                512,                                    /* The number of bytes to allocate to the
                                                         * stack of the task.                       */
                usb_main_TASK_PRIORITY,                 /* The priority assigned to the task.       */
                usb_cdc_tx_task_handle);                /* The task handle.                         */

        OS_ASSERT(status == OS_TASK_CREATE_SUCCESS);

        /* Start the USB VirtualMSD application task. */
        status = OS_TASK_CREATE("USB vmsd Task",        /* The text name assigned to the task, for
                                                         * debug only; not used by the kernel.          */
                usb_vmsd_task,                          /* The function that implements the task.       */
                NULL,                                   /* The parameter passed to the task.            */
                1024,                                   /* The number of bytes to allocate to the
                                                         * stack of the task.                           */
                usb_main_TASK_PRIORITY,                 /* The priority assigned to the task.           */
                usb_vmsd_task_handle);                  /* The task handle.                             */

        OS_ASSERT(status == OS_TASK_CREATE_SUCCESS);

        usb_init_task_handle = NULL;

        /* terminate the task */
        OS_TASK_DELETE(OS_GET_CURRENT_TASK());
}

/*********************************************************************
 *
 *       usb_cdc_vmsd_start
 *
 *  Function description
 *    Create the USB functionality initialization task and exit.
 *    Keep this as minimal as possible due to limittes stack from the
 *    caller process.
 *
 *********************************************************************/
void usb_cdc_vmsd_start()
{
        OS_BASE_TYPE status;

        /* Start the USB VirtualMSD application task. */
        status = OS_TASK_CREATE("USB init Task",        /* The text name assigned to the task, for
                                                         * debug only; not used by the kernel.          */
                usb_init_task,                          /* The function that implements the task.       */
                NULL,                                   /* The parameter passed to the task.            */
                1024,                                   /* The number of bytes to allocate to the
                                                         * stack of the task.                           */
                usb_higher_TASK_PRIORITY,               /* Higher priority assigned to the task to make
                                                         * sure it will run as early as possible        */
                usb_init_task_handle);                  /* The task handle.                             */

        OS_ASSERT(status == OS_TASK_CREATE_SUCCESS);
}

/*********************************************************************
 *
 *       usb_cdc_vmsd_stop
 *
 *  Function description
 *    Disable the USB initialized functionality and SEGGER stack
 *    Keep this as minimal as possible due to limittes stack from the
 *    caller process.
 *
 *********************************************************************/
void usb_cdc_vmsd_stop()
{
        run_usb_task = false;
        USBD_DeInit(); /* This will call also the USBD_Stop(); */
        USBD_UnregisterSCHook(&UsbpHook);
}

/*********************************************************************
 *
 *       sys_usb_ext_hook_begin_enumeration
 *
 *  Function description
 *    Event callback called from the VBUS event to notify
 *    the application that need to proceed with enumeration.
 *
 *********************************************************************/
void sys_usb_ext_hook_begin_enumeration(void)
{
        if (!run_usb_task) {
                run_usb_task = true;
                usb_cdc_vmsd_start();
        }
}

/*********************************************************************
 *
 *       sys_usb_ext_hook_detach
 *
 *  Function description
 *    Event callback called from the VBUS event to notify
 *    the application that the USB cable was removed and need to
 *    detach.
 *
 *********************************************************************/
void  sys_usb_ext_hook_detach(void)
{
        usb_cdc_vmsd_stop();
}

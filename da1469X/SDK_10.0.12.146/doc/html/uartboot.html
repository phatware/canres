<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>SmartSnippets DA1469x SDK: UART/SWD bootloader application</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1469x SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Board&#160;and&#160;Applications&#160;General&#160;Info</span></a></li>
      <li><a href="modules.html"><span>SDK&#160;Architecture</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">UART/SWD bootloader application </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Overview</h2>
<p>Application features:</p><ul>
<li>booting to another application and on-demand code execution</li>
<li>reading and writing<ul>
<li>RAM</li>
<li>QSPI</li>
<li>OTP</li>
<li>Registers</li>
</ul>
</li>
<li>QSPI FLASH memory management</li>
<li>custom protocol for UART or SWD communication</li>
</ul>
<p>It is used as a default target application by:</p><ul>
<li>libprogrammer</li>
<li>cli_programmer</li>
<li>SmartSnippets Toolbox</li>
</ul>
<h2>Vocabulary and notes</h2>
<p>uartboot protocols use few terms:</p><ul>
<li><em>SOH</em> - Start of Heading (0x01 value)</li>
<li><em>STX</em> - Start of Text (0x02 value)</li>
<li><em>ACK</em> - Acknowledge (0x06 value)</li>
<li><em>NAK</em> - Negative Acknowledge (0x15 value)</li>
<li><em>CRC</em> - 16-bits value calculated from data using CRC16-CCITT algorithm</li>
</ul>
<p>uartboot uses 32-bits addressing.</p>
<h3>Byte order</h3>
<p>The data length, CRC, address, bytes in OTP words should be sent using little-endian (LSB-first).</p>
<h2>UART configuration</h2>
<p>The application can be controlled using the serial console exposed over UART2.</p>
<p>GPIO pins configuration is as follows:</p>
<table class="doxtable">
<tr>
<th>DA1469x GPIO pin </th><th>DA1468x GPIO pin </th><th>Function  </th></tr>
<tr>
<td>P0.9 </td><td>P1.3 </td><td>UART2 TX </td></tr>
<tr>
<td>P0.8 </td><td>P2.3 </td><td>UART2 RX </td></tr>
</table>
<p>UART settings are as follows:</p>
<table class="doxtable">
<tr>
<th>Setting </th><th>DA1469x </th><th>DA1468x  </th></tr>
<tr>
<td>Baudrate </td><td>115200 </td><td>57600 </td></tr>
<tr>
<td>Data bits </td><td>8 </td><td>8 </td></tr>
<tr>
<td>Stop bits </td><td>1 </td><td>1 </td></tr>
<tr>
<td>Parity </td><td>None </td><td>None </td></tr>
<tr>
<td>Flow control </td><td>None </td><td>None </td></tr>
</table>
<p>This configuration can be changed, by modifying uartboot.bin binary at specific offsets:</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Description </th><th>Format  </th></tr>
<tr>
<td>0x0200 </td><td>TX port number </td><td>(4 bytes LE) </td></tr>
<tr>
<td>0x0204 </td><td>TX pin number </td><td>(4 bytes LE) </td></tr>
<tr>
<td>0x0208 </td><td>RX port number </td><td>(4 bytes LE) </td></tr>
<tr>
<td>0x020C </td><td>RX pin number </td><td>(4 bytes LE) </td></tr>
<tr>
<td>0x0210 </td><td>UART's baudrate value </td><td>(4 bytes LE) </td></tr>
</table>
<p>By default, all values are set to 0xFFFFFFFF.</p>
<h3>UART transmisison flow</h3>
<p>A complete flow for command transmission handling (including in/out data) is as follows: </p><pre class="fragment">&lt;= &lt;STX&gt; &lt;SOH&gt; (ver1) (ver2)
=&gt; &lt;SOH&gt;
=&gt; (type) (len1) (len2)
call HOP_INIT
&lt;= &lt;ACK&gt; / &lt;NAK&gt;
if len &gt; 0
     call HOP_HEADER
     =&gt; (data...)
     call HOP_DATA
     &lt;= &lt;ACK&gt; / &lt;NAK&gt;
     &lt;= (crc1) (crc2)
     =&gt; &lt;ACK&gt; / &lt;NAK&gt;
call HOP_EXEC
call HOP_SEND_LEN
if len &gt; 0
     &lt;= (len1) (len2)
     =&gt; &lt;ACK&gt; / &lt;NAK&gt;
     call HOP_SEND_DATA
     &lt;= (data...)
     =&gt; (crc1) (crc2)
     &lt;= &lt;ACK&gt; / &lt;NAK&gt;

  '&lt;=' - data sent by uartboot.
  '=&gt;' - data sent to uartboot by host application.
</pre><p>In case, error occures at any step (HOP_*), uartboot will send 'NAK', which shall terminate the transmission.</p>
<h2>SWD (debugger) interface</h2>
<p>The application can be also controlled using the SWD interface (debugger commands), this can be done by performing the following actions:</p>
<ul>
<li>find <em>DBGP</em> string marker in uartboot binary (it is aligned to 4 bytes) and mark the fields as follows:</li>
</ul>
<table class="doxtable">
<tr>
<th>Offset </th><th>Field </th><th>Description </th><th>Format  </th></tr>
<tr>
<td>0x00 </td><td><em>DBGP</em> </td><td><code>DBGP</code> bytes </td><td>(4 bytes) </td></tr>
<tr>
<td>0x04 </td><td><em>RUN_SWD</em> </td><td>SWD interface usage marker (0: SWD is not used, other: SWD if is used) </td><td>(4 bytes LE) </td></tr>
<tr>
<td>0x08 </td><td><em>NUM_ADDRESS</em> </td><td>Current index of the command </td><td>(4 bytes LE) </td></tr>
<tr>
<td>0x0C </td><td><em>CMD_BUF_ADDRESS</em> </td><td>Current command buffer address </td><td>(4 bytes LE / pointer) </td></tr>
<tr>
<td>0x10 </td><td><em>BUF_ADDRESS</em> </td><td>Input/output payload buffer address </td><td>(4 bytes LE / pointer) </td></tr>
<tr>
<td>0x14 </td><td><em>ACK_NAK_ADDRESS</em> </td><td>Input/output <em>ACK/NAK</em> value </td><td>(4 bytes LE) </td></tr>
</table>
<ul>
<li>write '0x01' to <em>RUN_SWD</em> field in the application binary</li>
<li>load application binary to the device RAM memory and execute it - application should start in SWD mode and stop at the breakpoint</li>
<li>write input data at <em>BUF_ADDRESS</em> (if needed)</li>
<li>write command header at <em>CMD_BUF_ADDRESS</em></li>
<li>increase value at <em>NUM_ADDRESS</em></li>
<li>set field at <em>ACK_NAK_ADDRESS</em> to NAK value</li>
<li>continue the application (leave the breakpoint)</li>
<li>uartboot executes given command then stops at the breakpoint again.</li>
<li>read field at <em>ACK_NAK_ADDRESS</em> - if command executed correctly it will contain ACK value</li>
<li>read output data from buffer at <em>CMD_BUF_ADDRESS</em> (if needed)</li>
</ul>
<p>Note: Detaching the debugger from board will cause a hardfault and it will be not possible to communicate with uartboot anymore until application restart.</p>
<h2>Commands overwiev</h2>
<p>uartboot application supports the following commands:</p>
<table class="doxtable">
<tr>
<th>Command </th><th>Name </th><th>Description  </th></tr>
<tr>
<td>0x01 </td><td>Write </td><td>Write data to RAM </td></tr>
<tr>
<td>0x02 </td><td>Read </td><td>Read data from RAM </td></tr>
<tr>
<td>0x03 </td><td>Copy to QSPI </td><td>Copy data from RAM to QSPI memory </td></tr>
<tr>
<td>0x04 </td><td>Erase QSPI </td><td>Erase a part of the QSPI memory </td></tr>
<tr>
<td>0x05 </td><td>Run </td><td>Execute a part of code </td></tr>
<tr>
<td>0x06 </td><td>Write OTP </td><td>Write data to OTP memory </td></tr>
<tr>
<td>0x07 </td><td>Read OTP </td><td>Read data from OTP memory </td></tr>
<tr>
<td>0x08 </td><td>Read QSPI </td><td>Read data from QSPI memory </td></tr>
<tr>
<td>0x09 </td><td>Customer specific </td><td>Perform customer specific action </td></tr>
<tr>
<td>0x0A </td><td>Read partition table </td><td>Read partition table from QSPI memory </td></tr>
<tr>
<td>0x0B </td><td>Get version </td><td>Get uartboot's version </td></tr>
<tr>
<td>0x0C </td><td>Chip erase QSPI </td><td>Erase whole QSPI FLASH memory </td></tr>
<tr>
<td>0x0D </td><td>Is empty QSPI </td><td>Check that a part of QSPI memory is empty </td></tr>
<tr>
<td>0x0E </td><td>Read partition </td><td>Read data from QSPI FLASH partion </td></tr>
<tr>
<td>0x0F </td><td>Write partition </td><td>Write data to QSPI FLASH partion </td></tr>
<tr>
<td>0x10 </td><td>Get QSPI state </td><td>Get QSPI controller state </td></tr>
<tr>
<td>0x11 </td><td>GPIO WD </td><td>Enable external watchdog notifying </td></tr>
<tr>
<td>0x12 </td><td>QSPI direct write </td><td>Write data directly to QSPI memory </td></tr>
<tr>
<td>0x30 </td><td>Change baudrate </td><td>Change communication UART's baudrate </td></tr>
<tr>
<td>0xFF </td><td>Dummy </td><td>Write 'Live' marker to data buffer </td></tr>
</table>
<h2>Supported commands</h2>
<p>Supported commands' description.</p>
<h3>Write</h3>
<p>Write data to RAM memory.</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>SOH </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode </td><td>0x01 </td></tr>
<tr>
<td>Length LSB </td><td>(0x04 + N) </td></tr>
<tr>
<td>Length MSB </td><td>(0x04 + N) &gt;&gt; 8 </td></tr>
<tr>
<td>Destination address LSB </td><td>0xXX </td></tr>
<tr>
<td>Destination address </td><td>0xXX </td></tr>
<tr>
<td>Destination address </td><td>0xXX </td></tr>
<tr>
<td>Destination address MSB </td><td>0xXX </td></tr>
<tr>
<td>Data 0 </td><td>Data byte 0 </td></tr>
<tr>
<td>… </td><td>… </td></tr>
<tr>
<td>Data n </td><td>Data byte N </td></tr>
</table>
<p>Note: SWD interface is able to write directly into RAM memory, which is suggested way for performing this operation. This command can be also used for writing values to registers.</p>
<hr/>
<h3>Read</h3>
<p>Read data from RAM memory.</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>SOH </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode </td><td>0x02 </td></tr>
<tr>
<td>Length LSB </td><td>0x06 </td></tr>
<tr>
<td>Length MSB </td><td>0x00 </td></tr>
<tr>
<td>Source address LSB </td><td>0xXX </td></tr>
<tr>
<td>Source address </td><td>0xXX </td></tr>
<tr>
<td>Source address </td><td>0xXX </td></tr>
<tr>
<td>Source address MSB </td><td>0xXX </td></tr>
<tr>
<td>Data length LSB </td><td>0xXX </td></tr>
<tr>
<td>Data length MSB </td><td>0xXX </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>Data 0 </td><td>Data byte 0 </td></tr>
<tr>
<td>… </td><td>… </td></tr>
<tr>
<td>Data n </td><td>Data byte N </td></tr>
</table>
<p>Note: SWD interface is able to read directly from RAM memory, which is suggested way for performing this operation. This command can be also used for reading values from registers.</p>
<hr/>
<h3>Copy to QSPI</h3>
<p>Copy data from RAM to QSPI FLASH memory.</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>SOH </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode </td><td>0x03 </td></tr>
<tr>
<td>Length LSB </td><td>0x0A </td></tr>
<tr>
<td>Length MSB </td><td>0x00 </td></tr>
<tr>
<td>Source address LSB </td><td>0xXX </td></tr>
<tr>
<td>Source address </td><td>0xXX </td></tr>
<tr>
<td>Source address </td><td>0xXX </td></tr>
<tr>
<td>Source address MSB </td><td>0xXX </td></tr>
<tr>
<td>Data length LSB </td><td>0xXX </td></tr>
<tr>
<td>Data length MSB </td><td>0xXX </td></tr>
<tr>
<td>Destination address LSB </td><td>0xXX </td></tr>
<tr>
<td>Destination address </td><td>0xXX </td></tr>
<tr>
<td>Destination address </td><td>0xXX </td></tr>
<tr>
<td>Destination address MSB </td><td>0xXX </td></tr>
</table>
<p>Note: Data stored in the same FLASH sector will be erased if the write cannot be performed directly.</p>
<hr/>
<h3>Erase QSPI</h3>
<p>Erase a part of the QSPI FLASH memory.</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>SOH </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode </td><td>0x04 </td></tr>
<tr>
<td>Length LSB </td><td>0x08 </td></tr>
<tr>
<td>Length MSB </td><td>0x00 </td></tr>
<tr>
<td>QSPI address LSB </td><td>0xXX </td></tr>
<tr>
<td>QSPI address </td><td>0xXX </td></tr>
<tr>
<td>QSPI address </td><td>0xXX </td></tr>
<tr>
<td>QSPI address MSB </td><td>0xXX </td></tr>
<tr>
<td>Size LSB </td><td>0xXX </td></tr>
<tr>
<td>Size </td><td>0xXX </td></tr>
<tr>
<td>Size </td><td>0xXX </td></tr>
<tr>
<td>Size MSB </td><td>0xXX </td></tr>
</table>
<p>Note: All QSPI FLASH sectors which include given area (specified by address + size) will be erased (erase operation is sector aligned).</p>
<hr/>
<h3>Run</h3>
<p>Execute a part of the code.</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>SOH </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode </td><td>0x05 </td></tr>
<tr>
<td>Length LSB </td><td>0x04 </td></tr>
<tr>
<td>Length MSB </td><td>0x00 </td></tr>
<tr>
<td>Memory address LSB </td><td>0xXX </td></tr>
<tr>
<td>Memory address </td><td>0xXX </td></tr>
<tr>
<td>Memory address </td><td>0xXX </td></tr>
<tr>
<td>Memory address MSB </td><td>0xXX </td></tr>
</table>
<p>Note: Code can be executed from different memories e.g. RAM, QSPI, OTP, ROM. If the memory address is the same as the input buffer then uartboot will copy all data from input buffer at RAM 0 address and perform the SW Reset. This feature can be used for booting application from RAM which are too big for handling by ROM bootlaoder.</p>
<hr/>
<h3>Write OTP</h3>
<p>Write data to the OTP memory.</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>SOH </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode </td><td>0x06 </td></tr>
<tr>
<td>Length LSB </td><td>(0x04 + N * 4) </td></tr>
<tr>
<td>Length MSB </td><td>(0x04 + N * 4) &gt;&gt; 8 </td></tr>
<tr>
<td>OTP cell offset LSB </td><td>0xXX </td></tr>
<tr>
<td>OTP cell offset </td><td>0xXX </td></tr>
<tr>
<td>OTP cell offset </td><td>0xXX </td></tr>
<tr>
<td>OTP cell offset MSB </td><td>0xXX </td></tr>
<tr>
<td>Word 0 LSB </td><td>0xXX </td></tr>
<tr>
<td>Word 0 </td><td>0xXX </td></tr>
<tr>
<td>Word 0 </td><td>0xXX </td></tr>
<tr>
<td>Word 0 MSB </td><td>0xXX </td></tr>
<tr>
<td>… </td><td>… </td></tr>
<tr>
<td>Word n LSB </td><td>0xXX </td></tr>
<tr>
<td>Word n </td><td>0xXX </td></tr>
<tr>
<td>Word n </td><td>0xXX </td></tr>
<tr>
<td>Word n MSB </td><td>0xXX </td></tr>
</table>
<p>Note: Cell size is 64-bits for DA1468x and 32-bits for DA1469x.</p>
<hr/>
<h3>Read OTP</h3>
<p>Read data from the OTP memory.</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>SOH </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode </td><td>0x07 </td></tr>
<tr>
<td>Length LSB </td><td>0x06 </td></tr>
<tr>
<td>Length MSB </td><td>0x00 </td></tr>
<tr>
<td>OTP cell offset LSB </td><td>0xXX </td></tr>
<tr>
<td>OTP cell offset </td><td>0xXX </td></tr>
<tr>
<td>OTP cell offset </td><td>0xXX </td></tr>
<tr>
<td>OTP cell offset MSB </td><td>0xXX </td></tr>
<tr>
<td>Data length LSB </td><td>0xXX </td></tr>
<tr>
<td>Data length MSB </td><td>0xXX </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>Word 0 LSB </td><td>0xXX </td></tr>
<tr>
<td>Word 0 </td><td>0xXX </td></tr>
<tr>
<td>Word 0 </td><td>0xXX </td></tr>
<tr>
<td>Word 0 MSB </td><td>0xXX </td></tr>
<tr>
<td>… </td><td>… </td></tr>
<tr>
<td>Word n LSB </td><td>0xXX </td></tr>
<tr>
<td>Word n </td><td>0xXX </td></tr>
<tr>
<td>Word n </td><td>0xXX </td></tr>
<tr>
<td>Word n MSB </td><td>0xXX </td></tr>
</table>
<p>Note: Cell size is 64-bits for DA1468x and 32-bits for DA1469x. Data length is a number of 32-bits words.</p>
<hr/>
<h3>Read QSPI</h3>
<p>Read data from QSPI memory.</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>SOH </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode </td><td>0x08 </td></tr>
<tr>
<td>Length LSB </td><td>0x06 </td></tr>
<tr>
<td>Length MSB </td><td>0x00 </td></tr>
<tr>
<td>Source address LSB </td><td>0xXX </td></tr>
<tr>
<td>Source address </td><td>0xXX </td></tr>
<tr>
<td>Source address </td><td>0xXX </td></tr>
<tr>
<td>Source address MSB </td><td>0xXX </td></tr>
<tr>
<td>Data length LSB </td><td>0xXX </td></tr>
<tr>
<td>Data length MSB </td><td>0xXX </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>Data 0 </td><td>Data byte 0 </td></tr>
<tr>
<td>… </td><td>… </td></tr>
<tr>
<td>Data n </td><td>Data byte N </td></tr>
</table>
<hr/>
<h3>Customer specific</h3>
<p>Perform customer specific action.</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>SOH </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode </td><td>0x09 </td></tr>
<tr>
<td>Length LSB </td><td>0x00 </td></tr>
<tr>
<td>Length MSB </td><td>0x00 </td></tr>
</table>
<p>Note: Behavior and input/output messages are implemented by the customer.</p>
<hr/>
<h3>Read partition table</h3>
<p>Read partition table from QSPI memory.</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>SOH </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode </td><td>0x0A </td></tr>
<tr>
<td>Length LSB </td><td>0x00 </td></tr>
<tr>
<td>Length MSB </td><td>0x00 </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>Length LSB </td><td>0xXX </td></tr>
<tr>
<td>Length MSB </td><td>0xXX </td></tr>
<tr>
<td>Sector size LSB </td><td>0xXX </td></tr>
<tr>
<td>Sector size MSB </td><td>0xXX </td></tr>
<tr>
<td>Start sector 0 LSB </td><td>0xXX </td></tr>
<tr>
<td>Start sector 0 MSB </td><td>0xXX </td></tr>
<tr>
<td>Start count 0 LSB </td><td>0xXX </td></tr>
<tr>
<td>Start count 0 MSB </td><td>0xXX </td></tr>
<tr>
<td>Partition ID 0 </td><td>0xXX </td></tr>
<tr>
<td>Partition name length 0 LSB </td><td>0xXX </td></tr>
<tr>
<td>Partition name length 0 MSB </td><td>0xXX </td></tr>
<tr>
<td>Partition name 0 START </td><td>0xXX </td></tr>
<tr>
<td>… </td><td>… </td></tr>
<tr>
<td>Partition name 0 END </td><td>0x00 </td></tr>
<tr>
<td>… </td><td>… </td></tr>
<tr>
<td>Start sector N LSB </td><td>0xXX </td></tr>
<tr>
<td>Start sector N MSB </td><td>0xXX </td></tr>
<tr>
<td>Start count N LSB </td><td>0xXX </td></tr>
<tr>
<td>Start count N MSB </td><td>0xXX </td></tr>
<tr>
<td>Partition ID N </td><td>0xXX </td></tr>
<tr>
<td>Partition name length N LSB </td><td>0xXX </td></tr>
<tr>
<td>Partition name length N MSB </td><td>0xXX </td></tr>
<tr>
<td>Partition name N START </td><td>0xXX </td></tr>
<tr>
<td>… </td><td>… </td></tr>
<tr>
<td>Partition name N END </td><td>0x00 </td></tr>
</table>
<p>Note: Check uartboot_types.h file for more details.</p>
<hr/>
<h3>Get version</h3>
<p>Get uartboot's version.</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>SOH </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode </td><td>0x0B </td></tr>
<tr>
<td>Length LSB </td><td>0x00 </td></tr>
<tr>
<td>Length MSB </td><td>0x00 </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>Version character 0 </td><td>'0' </td></tr>
<tr>
<td>Version character 1 </td><td>'.' </td></tr>
<tr>
<td>Version character 2 </td><td>'0' </td></tr>
<tr>
<td>Version character 3 </td><td>'.' </td></tr>
<tr>
<td>Version character 4 </td><td>'0' </td></tr>
<tr>
<td>Version character 5 </td><td>'.' </td></tr>
<tr>
<td>Version character 6 </td><td>'3' </td></tr>
</table>
<p>Note: Response string is sent without the '\0' character at the end. Its length is sent before the payload.</p>
<hr/>
<h3>Chip erase QSPI</h3>
<p>Erase whole QSPI FLASH memory.</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>SOH </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode </td><td>0x0C </td></tr>
<tr>
<td>Length LSB </td><td>0x00 </td></tr>
<tr>
<td>Length MSB </td><td>0x00 </td></tr>
</table>
<p>Note: Execution time for this command is slightly longer than for the other commands.</p>
<hr/>
<h3>Is empty QSPI</h3>
<p>Check that the part of the QSPI FLASH memory is empty.</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>SOH </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode </td><td>0x0D </td></tr>
<tr>
<td>Length LSB </td><td>0x08 </td></tr>
<tr>
<td>Length MSB </td><td>0x00 </td></tr>
<tr>
<td>Size LSB </td><td>0xXX </td></tr>
<tr>
<td>Size </td><td>0xXX </td></tr>
<tr>
<td>Size </td><td>0xXX </td></tr>
<tr>
<td>Size MSB </td><td>0xXX </td></tr>
<tr>
<td>Start address LSB </td><td>0xXX </td></tr>
<tr>
<td>Start address </td><td>0xXX </td></tr>
<tr>
<td>Start address </td><td>0xXX </td></tr>
<tr>
<td>Start address MSB </td><td>0xXX </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>Number LSB </td><td>0xXX </td></tr>
<tr>
<td>Number </td><td>0xXX </td></tr>
<tr>
<td>Number </td><td>0xXX </td></tr>
<tr>
<td>Number MSB </td><td>0xXX </td></tr>
</table>
<p>Note: If Number represents positive value, than it is a number of bytes that were checked to be erased. Otherwise, it represents position of first non-empty byte multiplied by -1.</p>
<hr/>
<h3>Read partition</h3>
<p>Read data from QSPI FLASH partition.</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>SOH </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode </td><td>0x0E </td></tr>
<tr>
<td>Length LSB </td><td>0x07 </td></tr>
<tr>
<td>Length MSB </td><td>0x00 </td></tr>
<tr>
<td>Source address LSB </td><td>0xXX </td></tr>
<tr>
<td>Source address </td><td>0xXX </td></tr>
<tr>
<td>Source address </td><td>0xXX </td></tr>
<tr>
<td>Source address MSB </td><td>0xXX </td></tr>
<tr>
<td>Data length LSB </td><td>0xXX </td></tr>
<tr>
<td>Data length MSB </td><td>0xXX </td></tr>
<tr>
<td>Partition ID </td><td>0xXX </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>Data 0 </td><td>Data byte 0 </td></tr>
<tr>
<td>… </td><td>… </td></tr>
<tr>
<td>Data n </td><td>Data byte N </td></tr>
</table>
<p>Note: Source address should be an offset from the partition beginning.</p>
<hr/>
<h3>Write partition</h3>
<p>Copy data from RAM to QSPI FLASH partition.</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>SOH </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode </td><td>0x0F </td></tr>
<tr>
<td>Length LSB </td><td>0x0B </td></tr>
<tr>
<td>Length MSB </td><td>0x00 </td></tr>
<tr>
<td>Source address LSB </td><td>0xXX </td></tr>
<tr>
<td>Source address </td><td>0xXX </td></tr>
<tr>
<td>Source address </td><td>0xXX </td></tr>
<tr>
<td>Source address MSB </td><td>0xXX </td></tr>
<tr>
<td>Data length LSB </td><td>0xXX </td></tr>
<tr>
<td>Data length MSB </td><td>0xXX </td></tr>
<tr>
<td>Destination address LSB </td><td>0xXX </td></tr>
<tr>
<td>Destination address </td><td>0xXX </td></tr>
<tr>
<td>Destination address </td><td>0xXX </td></tr>
<tr>
<td>Destination address MSB </td><td>0xXX </td></tr>
<tr>
<td>Partition ID </td><td>0xXX </td></tr>
</table>
<p>Note: Destination address should be an offset from the partition beginning.</p>
<hr/>
<h3>Get QPSI state</h3>
<p>Get QSPI controller state</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>SOH </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode </td><td>0x10 </td></tr>
<tr>
<td>Length LSB </td><td>0x01 </td></tr>
<tr>
<td>Length MSB </td><td>0x00 </td></tr>
<tr>
<td>QSPI Controller ID </td><td>0xXX </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>Driver configured </td><td>0x01 / 0x00 </td></tr>
<tr>
<td>Manufacture ID </td><td>0xXX </td></tr>
<tr>
<td>Device type </td><td>0xXX </td></tr>
<tr>
<td>Density </td><td>0xXX </td></tr>
</table>
<p>Note: DA1468x supports only one QSPI controller, DA1469x can support 2. Manufacture ID, Device type and Density depends on connected QSPI memory.</p>
<hr/>
<h3>GPIO WD</h3>
<p>Enable external watchdog notifying. Start square wave on QPIO pin: 15ms high state, 2s low state.</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>SOH </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode </td><td>0x11 </td></tr>
<tr>
<td>Length LSB </td><td>0x02 </td></tr>
<tr>
<td>Length MSB </td><td>0x00 </td></tr>
<tr>
<td>GPIO pad </td><td>(PORT &lt;&lt; 5) + PIN </td></tr>
<tr>
<td>GPIO level </td><td>0x00: 3.3V, 0x01: 1.8V </td></tr>
</table>
<hr/>
<h3>QSPI direct write</h3>
<p>Write data directly to QSPI memory.</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>SOH </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode </td><td>0x12 </td></tr>
<tr>
<td>Length LSB </td><td>(0x05 + N) </td></tr>
<tr>
<td>Length MSB </td><td>(0x05 + N) &gt;&gt; 8 </td></tr>
<tr>
<td>Verify write </td><td>0x00 / 0x01 </td></tr>
<tr>
<td>Destination address LSB </td><td>0xXX </td></tr>
<tr>
<td>Destination address </td><td>0xXX </td></tr>
<tr>
<td>Destination address </td><td>0xXX </td></tr>
<tr>
<td>Destination address MSB </td><td>0xXX </td></tr>
<tr>
<td>Data 0 </td><td>Data byte 0 </td></tr>
<tr>
<td>… </td><td>… </td></tr>
<tr>
<td>Data n </td><td>Data byte N </td></tr>
</table>
<hr/>
<h3>Change baudrate</h3>
<p>Change communication UART's baudrate.</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>SOH </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode </td><td>0x30 </td></tr>
<tr>
<td>Length LSB </td><td>0x04 </td></tr>
<tr>
<td>Length MSB </td><td>0x00 </td></tr>
<tr>
<td>Baudrate LSB </td><td>0xXX </td></tr>
<tr>
<td>Baudrate </td><td>0xXX </td></tr>
<tr>
<td>Baudrate </td><td>0xXX </td></tr>
<tr>
<td>Baudrate MSB </td><td>0xXX </td></tr>
</table>
<p>Note: 'ACK' after command execution is sent using the new baudrate. This command has no effect in SWD mode. Allowed baudrates: 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200, 230400, 500000, 1000000.</p>
<hr/>
<h3>Dummy</h3>
<p>Write Live marker to the data buffer.</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>SOH </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode </td><td>0xFF </td></tr>
<tr>
<td>Length LSB </td><td>0x00 </td></tr>
<tr>
<td>Length MSB </td><td>0x00 </td></tr>
</table>
<p>Note: This command writes 'Live' at the beginning of the data buffer.</p>
<hr/>
 </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 15 2022 14:13:47 for SmartSnippets DA1469x SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>

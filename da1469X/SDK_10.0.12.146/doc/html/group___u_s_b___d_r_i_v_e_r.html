<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>SmartSnippets DA1469x SDK: USB Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1469x SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Board&#160;and&#160;Applications&#160;General&#160;Info</span></a></li>
      <li><a href="modules.html"><span>SDK&#160;Architecture</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">USB Driver<div class="ingroups"><a class="el" href="group___p_l_a_t_f_o_r_m___d_e_v_i_c_e.html">Platform/Device</a> &raquo; <a class="el" href="group___p_l_a___d_r_i_v_e_r_s.html">Drivers</a> &raquo; <a class="el" href="group___p_l_a___d_r_i___p_e_r_p_h_e_r_a_l_s.html">Peripheral LLD's</a> &raquo; <a class="el" href="group___p_l_a___d_r_i___p_e_r___c_o_m_m.html">Comm Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>USB Driver Controller.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:hw__usb__da1469x_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__usb__da1469x_8h.html">hw_usb_da1469x.h</a></td></tr>
<tr class="memdesc:hw__usb__da1469x_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">header for low level USB driver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhw__usb__ep__regs__t.html">hw_usb_ep_regs_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB EP registers.  <a href="structhw__usb__ep__regs__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhw__usb__ep__flags__t.html">hw_usb_ep_flags_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB EP transfer flags.  <a href="structhw__usb__ep__flags__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhw__usb__ep__buffer__t.html">hw_usb_ep_buffer_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB EP info structure Can be used for EP0, IN or OUT EP.  <a href="structhw__usb__ep__buffer__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhw__usb__ep__data__t.html">hw_usb_ep_data_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB EP structure to use with the driver Can be used for IN and OUT EP.  <a href="structhw__usb__ep__data__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa151065ff93a5856f2c50553ece4411f"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#gaa151065ff93a5856f2c50553ece4411f">hw_usb_vbus_cb_t</a>) (<a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga78ea82c2917d7d2c6c5e0422a5378cbf">HW_USB_VBUS_IRQ_STAT</a> status)</td></tr>
<tr class="memdesc:gaa151065ff93a5856f2c50553ece4411f"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB VBUS callback.  <a href="#gaa151065ff93a5856f2c50553ece4411f">More...</a><br /></td></tr>
<tr class="separator:gaa151065ff93a5856f2c50553ece4411f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga146895cd4fed03f51411478d01895bca"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga146895cd4fed03f51411478d01895bca">hw_usb_usb_cb_t</a>) (uint32_t status)</td></tr>
<tr class="memdesc:ga146895cd4fed03f51411478d01895bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB callback.  <a href="#ga146895cd4fed03f51411478d01895bca">More...</a><br /></td></tr>
<tr class="separator:ga146895cd4fed03f51411478d01895bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gad06910566d26e8fa42e92c845de8a128"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad06910566d26e8fa42e92c845de8a128"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#gad06910566d26e8fa42e92c845de8a128">HW_USB_NFSR_TYPE</a> </td></tr>
<tr class="memdesc:gad06910566d26e8fa42e92c845de8a128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node Functional State Register. <br /></td></tr>
<tr class="separator:gad06910566d26e8fa42e92c845de8a128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78ea82c2917d7d2c6c5e0422a5378cbf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga78ea82c2917d7d2c6c5e0422a5378cbf">HW_USB_VBUS_IRQ_STAT</a> { <a class="el" href="group___u_s_b___d_r_i_v_e_r.html#gga78ea82c2917d7d2c6c5e0422a5378cbfacf17686c9cb608b4cd759a0f4d631652">HW_USB_VBUS_IRQ_STAT_FALL</a>, 
<a class="el" href="group___u_s_b___d_r_i_v_e_r.html#gga78ea82c2917d7d2c6c5e0422a5378cbfa8b9e0def605250082bf1a7934e7b8e97">HW_USB_VBUS_IRQ_STAT_RISE</a> =
 }</td></tr>
<tr class="memdesc:ga78ea82c2917d7d2c6c5e0422a5378cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">VBUS IRQ status.  <a href="group___u_s_b___d_r_i_v_e_r.html#ga78ea82c2917d7d2c6c5e0422a5378cbf">More...</a><br /></td></tr>
<tr class="separator:ga78ea82c2917d7d2c6c5e0422a5378cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga67ac5b853cb459d93667b94facb48471"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga67ac5b853cb459d93667b94facb48471"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga67ac5b853cb459d93667b94facb48471">hw_usb_interrupt_handler</a> (uint32_t status)</td></tr>
<tr class="memdesc:ga67ac5b853cb459d93667b94facb48471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be called when an USB interrupt is handled. <br /></td></tr>
<tr class="separator:ga67ac5b853cb459d93667b94facb48471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6c7b9c3d6ec6d4c8c2a633db86580df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad6c7b9c3d6ec6d4c8c2a633db86580df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#gad6c7b9c3d6ec6d4c8c2a633db86580df">hw_usb_sd3_event</a> (void)</td></tr>
<tr class="memdesc:gad6c7b9c3d6ec6d4c8c2a633db86580df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process SD3 interrupt. <br /></td></tr>
<tr class="separator:gad6c7b9c3d6ec6d4c8c2a633db86580df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4211d1c3bbd6b6caca7f65037484eb9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4211d1c3bbd6b6caca7f65037484eb9a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga4211d1c3bbd6b6caca7f65037484eb9a">hw_usb_request_remote_wakeup</a> (void)</td></tr>
<tr class="memdesc:ga4211d1c3bbd6b6caca7f65037484eb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send Remote-Wakeup Signal to Host. <br /></td></tr>
<tr class="separator:ga4211d1c3bbd6b6caca7f65037484eb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2a6afe26d4165001ed6af2fc1f6da79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa2a6afe26d4165001ed6af2fc1f6da79"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#gaa2a6afe26d4165001ed6af2fc1f6da79">hw_usb_reset_event</a> (void)</td></tr>
<tr class="memdesc:gaa2a6afe26d4165001ed6af2fc1f6da79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process reset interrupt. <br /></td></tr>
<tr class="separator:gaa2a6afe26d4165001ed6af2fc1f6da79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6a7be1c1f290fa01c525448c82decbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae6a7be1c1f290fa01c525448c82decbe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#gae6a7be1c1f290fa01c525448c82decbe">hw_usb_resume_event</a> (void)</td></tr>
<tr class="memdesc:gae6a7be1c1f290fa01c525448c82decbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process resume interrupt. <br /></td></tr>
<tr class="separator:gae6a7be1c1f290fa01c525448c82decbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc614d9a7f80d60eb94060014d05835c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadc614d9a7f80d60eb94060014d05835c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#gadc614d9a7f80d60eb94060014d05835c">hw_usb_frame_event</a> (void)</td></tr>
<tr class="memdesc:gadc614d9a7f80d60eb94060014d05835c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process frame interrupt. <br /></td></tr>
<tr class="separator:gadc614d9a7f80d60eb94060014d05835c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea1d3371535162ed32689dd78e082790"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaea1d3371535162ed32689dd78e082790"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#gaea1d3371535162ed32689dd78e082790">hw_usb_nak_event</a> (void)</td></tr>
<tr class="memdesc:gaea1d3371535162ed32689dd78e082790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for NAK interrupt from all endpoints. <br /></td></tr>
<tr class="separator:gaea1d3371535162ed32689dd78e082790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a55efbaa9be7c083cf6a4b808e01c11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6a55efbaa9be7c083cf6a4b808e01c11"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga6a55efbaa9be7c083cf6a4b808e01c11">hw_usb_tx_event</a> (void)</td></tr>
<tr class="memdesc:ga6a55efbaa9be7c083cf6a4b808e01c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for interrupt from TX endpoints. <br /></td></tr>
<tr class="separator:ga6a55efbaa9be7c083cf6a4b808e01c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7516a95e9e00449e7a40e0ea9a301aaa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7516a95e9e00449e7a40e0ea9a301aaa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga7516a95e9e00449e7a40e0ea9a301aaa">hw_usb_rx_event</a> (void)</td></tr>
<tr class="memdesc:ga7516a95e9e00449e7a40e0ea9a301aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for interrupt from RX endpoints. <br /></td></tr>
<tr class="separator:ga7516a95e9e00449e7a40e0ea9a301aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac768317ff7ec3e70893862a9a9548920"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac768317ff7ec3e70893862a9a9548920"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#gac768317ff7ec3e70893862a9a9548920">hw_usb_nak_event_ep0</a> (void)</td></tr>
<tr class="memdesc:gac768317ff7ec3e70893862a9a9548920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for NAK interrupt from endpoints 0. <br /></td></tr>
<tr class="separator:gac768317ff7ec3e70893862a9a9548920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6ccffbd41ef012123f6c9d5fc4775ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab6ccffbd41ef012123f6c9d5fc4775ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#gab6ccffbd41ef012123f6c9d5fc4775ae">hw_usb_rx_ep0</a> (void)</td></tr>
<tr class="memdesc:gab6ccffbd41ef012123f6c9d5fc4775ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive on endpoint zero. <br /></td></tr>
<tr class="separator:gab6ccffbd41ef012123f6c9d5fc4775ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68215a09be5668f33392a0c524dd1b59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga68215a09be5668f33392a0c524dd1b59">hw_usb_tx_ep</a> (uint8_t ep_nr)</td></tr>
<tr class="memdesc:ga68215a09be5668f33392a0c524dd1b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Continue or complete TX for the endpoint.  <a href="#ga68215a09be5668f33392a0c524dd1b59">More...</a><br /></td></tr>
<tr class="separator:ga68215a09be5668f33392a0c524dd1b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga725339c1cbe5f5c2b57659a21310244c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga78ea82c2917d7d2c6c5e0422a5378cbf">HW_USB_VBUS_IRQ_STAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga725339c1cbe5f5c2b57659a21310244c">hw_usb_get_vbus_mask_status</a> (void)</td></tr>
<tr class="memdesc:ga725339c1cbe5f5c2b57659a21310244c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the VBUS mask register.  <a href="#ga725339c1cbe5f5c2b57659a21310244c">More...</a><br /></td></tr>
<tr class="separator:ga725339c1cbe5f5c2b57659a21310244c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5736358c133599a74e9eb52e53a25667"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5736358c133599a74e9eb52e53a25667"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga5736358c133599a74e9eb52e53a25667">hw_usb_set_hw_mode_to_suspended</a> (void)</td></tr>
<tr class="memdesc:ga5736358c133599a74e9eb52e53a25667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the USB HW-Block in SUSPENDED mode. This is used when the Remote Wakeup signaling is triggered so the USB HW block will process the RESUME-EOP and generate the RESUME event interrupt. <br /></td></tr>
<tr class="separator:ga5736358c133599a74e9eb52e53a25667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3234f8ba6be826142d697b85d4d0da4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#gab3234f8ba6be826142d697b85d4d0da4">hw_usb_enable_usb_pads_with_pullup</a> (void)</td></tr>
<tr class="memdesc:gab3234f8ba6be826142d697b85d4d0da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the USB pads with a pull-up on D+.  <a href="#gab3234f8ba6be826142d697b85d4d0da4">More...</a><br /></td></tr>
<tr class="separator:gab3234f8ba6be826142d697b85d4d0da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga111ec362dac1eb1ccbc9a4e342ed3df1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga111ec362dac1eb1ccbc9a4e342ed3df1">hw_usb_enable_usb_pads_without_pullup</a> (void)</td></tr>
<tr class="memdesc:ga111ec362dac1eb1ccbc9a4e342ed3df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the USB pads without activating the pull-up.  <a href="#ga111ec362dac1eb1ccbc9a4e342ed3df1">More...</a><br /></td></tr>
<tr class="separator:ga111ec362dac1eb1ccbc9a4e342ed3df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4691d8032fbfc493af4e0b668fe13748"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4691d8032fbfc493af4e0b668fe13748"></a>
__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga4691d8032fbfc493af4e0b668fe13748">hw_usb_disable_usb_pads</a> (void)</td></tr>
<tr class="memdesc:ga4691d8032fbfc493af4e0b668fe13748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the USB pads. <br /></td></tr>
<tr class="separator:ga4691d8032fbfc493af4e0b668fe13748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d2f8800643d84cfdc7c6be89eff8cb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga8d2f8800643d84cfdc7c6be89eff8cb4">hw_usb_enable_vbus_interrupt</a> (<a class="el" href="group___u_s_b___d_r_i_v_e_r.html#gaa151065ff93a5856f2c50553ece4411f">hw_usb_vbus_cb_t</a> cb)</td></tr>
<tr class="memdesc:ga8d2f8800643d84cfdc7c6be89eff8cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable VBUS interrupt in NVIC.  <a href="#ga8d2f8800643d84cfdc7c6be89eff8cb4">More...</a><br /></td></tr>
<tr class="separator:ga8d2f8800643d84cfdc7c6be89eff8cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3083d26da1d540e6ba167642ca33b073"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3083d26da1d540e6ba167642ca33b073"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga3083d26da1d540e6ba167642ca33b073">hw_usb_disable_vbus_interrupt</a> (void)</td></tr>
<tr class="memdesc:ga3083d26da1d540e6ba167642ca33b073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable VBUS interrupt in NVIC. <br /></td></tr>
<tr class="separator:ga3083d26da1d540e6ba167642ca33b073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a8df817f83a2fbbf3e43ea1bbf38e54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4a8df817f83a2fbbf3e43ea1bbf38e54"></a>
__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga4a8df817f83a2fbbf3e43ea1bbf38e54">hw_usb_program_vbus_irq_on_rising</a> (void)</td></tr>
<tr class="memdesc:ga4a8df817f83a2fbbf3e43ea1bbf38e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program VBUS IRQ to hit when the VBUS level goes from low to high. <br /></td></tr>
<tr class="separator:ga4a8df817f83a2fbbf3e43ea1bbf38e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab99d2e9e56a653edd5028a7531a7edc0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab99d2e9e56a653edd5028a7531a7edc0"></a>
__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#gab99d2e9e56a653edd5028a7531a7edc0">hw_usb_program_vbus_irq_on_falling</a> (void)</td></tr>
<tr class="memdesc:gab99d2e9e56a653edd5028a7531a7edc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program VBUS IRQ to hit when the VBUS level goes from high to low. <br /></td></tr>
<tr class="separator:gab99d2e9e56a653edd5028a7531a7edc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf19fe5a1a635d279c9f780c61216a3ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf19fe5a1a635d279c9f780c61216a3ad"></a>
__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#gaf19fe5a1a635d279c9f780c61216a3ad">hw_usb_program_vbus_cancel_irq</a> (void)</td></tr>
<tr class="memdesc:gaf19fe5a1a635d279c9f780c61216a3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask VBUS IRQ so that it does not hit when the VBUS level changes. <br /></td></tr>
<tr class="separator:gaf19fe5a1a635d279c9f780c61216a3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa964d3ae5f95860b858f98938d1142e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafa964d3ae5f95860b858f98938d1142e"></a>
__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#gafa964d3ae5f95860b858f98938d1142e">hw_usb_clear_vbus_irq</a> (void)</td></tr>
<tr class="memdesc:gafa964d3ae5f95860b858f98938d1142e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear VBUS IRQ. <br /></td></tr>
<tr class="separator:gafa964d3ae5f95860b858f98938d1142e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga582d711842ff73f3e1674bf4dea2d621"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga582d711842ff73f3e1674bf4dea2d621"></a>
__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga582d711842ff73f3e1674bf4dea2d621">hw_usb_program_usb_irq</a> (void)</td></tr>
<tr class="memdesc:ga582d711842ff73f3e1674bf4dea2d621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program USB IRQ to hit when [0,3] bits of USB_CHARGER_STAT_REG are set. <br /></td></tr>
<tr class="separator:ga582d711842ff73f3e1674bf4dea2d621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8f88b8fc26d4e045a19913b29f6d169"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf8f88b8fc26d4e045a19913b29f6d169"></a>
__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#gaf8f88b8fc26d4e045a19913b29f6d169">hw_usb_program_usb_cancel_irq</a> (void)</td></tr>
<tr class="memdesc:gaf8f88b8fc26d4e045a19913b29f6d169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask USB IRQ so that it does not hit when when [0,3] bits of USB_CHARGER_STAT_REG are set. <br /></td></tr>
<tr class="separator:gaf8f88b8fc26d4e045a19913b29f6d169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb8949c71e4bf4de3c1631fc94e7e2ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadb8949c71e4bf4de3c1631fc94e7e2ec"></a>
__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#gadb8949c71e4bf4de3c1631fc94e7e2ec">hw_usb_get_and_clear_usb_event_status</a> (void)</td></tr>
<tr class="memdesc:gadb8949c71e4bf4de3c1631fc94e7e2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get USB event. <br /></td></tr>
<tr class="separator:gadb8949c71e4bf4de3c1631fc94e7e2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90192fd3fa2aefd3a3228d2f7920bd5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga90192fd3fa2aefd3a3228d2f7920bd5f">hw_usb_enable_usb_interrupt</a> (<a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga146895cd4fed03f51411478d01895bca">hw_usb_usb_cb_t</a> cb)</td></tr>
<tr class="memdesc:ga90192fd3fa2aefd3a3228d2f7920bd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable USB interrupt in NVIC.  <a href="#ga90192fd3fa2aefd3a3228d2f7920bd5f">More...</a><br /></td></tr>
<tr class="separator:ga90192fd3fa2aefd3a3228d2f7920bd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaa19831b205df6273a348fd9c204839"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacaa19831b205df6273a348fd9c204839"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#gacaa19831b205df6273a348fd9c204839">hw_usb_disable_usb_interrupt</a> (void)</td></tr>
<tr class="memdesc:gacaa19831b205df6273a348fd9c204839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable USB interrupt in NVIC. <br /></td></tr>
<tr class="separator:gacaa19831b205df6273a348fd9c204839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78f0f8b38dfcd1146989279c0bac2f28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga78f0f8b38dfcd1146989279c0bac2f28">hw_usb_is_suspended</a> (void)</td></tr>
<tr class="memdesc:ga78f0f8b38dfcd1146989279c0bac2f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the USB device is suspended.  <a href="#ga78f0f8b38dfcd1146989279c0bac2f28">More...</a><br /></td></tr>
<tr class="separator:ga78f0f8b38dfcd1146989279c0bac2f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga367e3ace657db720b5f7eb51fdcb747a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga367e3ace657db720b5f7eb51fdcb747a">hw_usb_set_suspended</a> (bool suspend)</td></tr>
<tr class="memdesc:ga367e3ace657db720b5f7eb51fdcb747a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set flag to indicate USB device is suspended.  <a href="#ga367e3ace657db720b5f7eb51fdcb747a">More...</a><br /></td></tr>
<tr class="separator:ga367e3ace657db720b5f7eb51fdcb747a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92be0f6cd4e47606dde86235533dd8aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga92be0f6cd4e47606dde86235533dd8aa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga92be0f6cd4e47606dde86235533dd8aa">hw_usb_enable_irqs_on_resume</a> (void)</td></tr>
<tr class="memdesc:ga92be0f6cd4e47606dde86235533dd8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-enable IRQs that were disabled when the device was suspended. <br /></td></tr>
<tr class="separator:ga92be0f6cd4e47606dde86235533dd8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cb5f53b61c5c5687ac4df662740d73a"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga1cb5f53b61c5c5687ac4df662740d73a">hw_usb_is_powered_by_vbus</a> (void)</td></tr>
<tr class="memdesc:ga1cb5f53b61c5c5687ac4df662740d73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if VBUS power is available.  <a href="#ga1cb5f53b61c5c5687ac4df662740d73a">More...</a><br /></td></tr>
<tr class="separator:ga1cb5f53b61c5c5687ac4df662740d73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>USB Driver Controller. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga146895cd4fed03f51411478d01895bca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* hw_usb_usb_cb_t) (uint32_t status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>IRQ status. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa151065ff93a5856f2c50553ece4411f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* hw_usb_vbus_cb_t) (<a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga78ea82c2917d7d2c6c5e0422a5378cbf">HW_USB_VBUS_IRQ_STAT</a> status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB VBUS callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>IRQ status. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga78ea82c2917d7d2c6c5e0422a5378cbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga78ea82c2917d7d2c6c5e0422a5378cbf">HW_USB_VBUS_IRQ_STAT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VBUS IRQ status. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga78ea82c2917d7d2c6c5e0422a5378cbfacf17686c9cb608b4cd759a0f4d631652"></a>HW_USB_VBUS_IRQ_STAT_FALL&#160;</td><td class="fielddoc">
<p>VBUS irq has been programmed to hit on falling edge. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga78ea82c2917d7d2c6c5e0422a5378cbfa8b9e0def605250082bf1a7934e7b8e97"></a>HW_USB_VBUS_IRQ_STAT_RISE&#160;</td><td class="fielddoc">
<p>VBUS irq has been programmed to hit on rising edge. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga90192fd3fa2aefd3a3228d2f7920bd5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_usb_enable_usb_interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga146895cd4fed03f51411478d01895bca">hw_usb_usb_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable USB interrupt in NVIC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function that will be called when the interrupt line is asserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab3234f8ba6be826142d697b85d4d0da4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_usb_enable_usb_pads_with_pullup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the USB pads with a pull-up on D+. </p>
<dl class="section note"><dt>Note</dt><dd>Corresponding pin / port must be configured as a USB pad in advance. </dd></dl>

</div>
</div>
<a class="anchor" id="ga111ec362dac1eb1ccbc9a4e342ed3df1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_usb_enable_usb_pads_without_pullup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the USB pads without activating the pull-up. </p>
<dl class="section note"><dt>Note</dt><dd>Corresponding pin / port must be configured as a USB pad in advance. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8d2f8800643d84cfdc7c6be89eff8cb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_usb_enable_vbus_interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___d_r_i_v_e_r.html#gaa151065ff93a5856f2c50553ece4411f">hw_usb_vbus_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable VBUS interrupt in NVIC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function that will be called when the interrupt line is asserted on rising or on falling edge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga725339c1cbe5f5c2b57659a21310244c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group___u_s_b___d_r_i_v_e_r.html#ga78ea82c2917d7d2c6c5e0422a5378cbf">HW_USB_VBUS_IRQ_STAT</a> hw_usb_get_vbus_mask_status </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the VBUS mask register. </p>
<dl class="section return"><dt>Returns</dt><dd>VBUS mask register. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1cb5f53b61c5c5687ac4df662740d73a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE bool hw_usb_is_powered_by_vbus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if VBUS power is available. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Powered by VBUS. </td></tr>
    <tr><td class="paramname">false</td><td>Not Powered by VBUS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>A ~20ms delay is needed for safely reading the power source. </dd></dl>

</div>
</div>
<a class="anchor" id="ga78f0f8b38dfcd1146989279c0bac2f28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hw_usb_is_suspended </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the USB device is suspended. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000046">Deprecated:</a></b></dt><dd>This function is deprecated. The application can get the USB state through the emUSB API call USBD_GetState() and/or the registered emUSB callback through USBD_RegisterSCHook(...); See the emUSB documentation for details. </dd></dl>

</div>
</div>
<a class="anchor" id="ga367e3ace657db720b5f7eb51fdcb747a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_usb_set_suspended </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>suspend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set flag to indicate USB device is suspended. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000047">Deprecated:</a></b></dt><dd>This function is deprecated. User should not call this function. A USB device cannot suspend on its own. The USB host must request it. The USB state is handled internally and the Application can get it through the emUSB API call USBD_GetState() and/or the registered emUSB callback through USBD_RegisterSCHook(...); See the emUSB documentation for details. </dd></dl>

</div>
</div>
<a class="anchor" id="ga68215a09be5668f33392a0c524dd1b59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_usb_tx_ep </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep_nr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Continue or complete TX for the endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_nr</td><td>The endpoint number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 15 2022 14:13:48 for SmartSnippets DA1469x SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>

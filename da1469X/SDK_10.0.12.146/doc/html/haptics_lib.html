<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>SmartSnippets DA1469x SDK: Dialog Haptics Algorithm Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1469x SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Board&#160;and&#160;Applications&#160;General&#160;Info</span></a></li>
      <li><a href="modules.html"><span>SDK&#160;Architecture</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Dialog Haptics Algorithm Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>License Information</h2>
<p>This software ("Software") is owned by Dialog Semiconductor.</p>
<p>By using this Software you agree that Dialog Semiconductor retains all intellectual property and proprietary rights in and to this Software and any use, reproduction, disclosure or distribution of the Software without express written permission or a license agreement from Dialog Semiconductor is strictly prohibited. This Software is solely for use on or in conjunction with Dialog Semiconductor products.</p>
<p>EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES OR AS REQUIRED BY LAW, THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES OR BY LAW, IN NO EVENT SHALL DIALOG SEMICONDUCTOR BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THE SOFTWARE.</p>
<h2>Overview</h2>
<p>The Haptics Algorithms Library provides a set of algorithmic modules for the open and closed loop monitoring and control of haptic actuators such as Eccentric Rotating Mass motors (ERMs) and Linear Resonant Actuators (LRAs).</p>
<p>The provided algorithms include functionality for actuator back electro-motive force (EMF) measurement/analysis, resonant frequency tracking (LRA only) and acceleration/braking.</p>
<p>The library is designed to work in conjunction with the haptic driver interface on the Dialog Semiconductor DA1469x Bluetooth Low Energy SoC. This interface can be configured to drive haptic actuators with either DC levels (in the case of ERMs) or square wave drive signals (in the case of LRAs) at varying drive levels and frequencies and can operate in both open and closed loop modes. It is also able to measure the electrical current flowing through the haptic driver circuit by using an analog to digital converter (ADC) to sample the voltage drop across a sense resistor (internal to chip), placed in series with the actuator in the drive circuit.</p>
<p>The current flowing through an actuator circuit is dependent on both the DC drive voltage and the back-EMF of the actuator. By calibrating the sense circuit to account for differences in impedance in both the sense resistor and the actuator, it is possible to distinguish the back-EMF current from the drive current and hence monitor the state of the actuator.</p>
<p>In the case of an ERM, the back-EMF is dependent on its speed/loading. By measuring the back-EMF we can therefore monitor when the ERM reaches equilibrium speed and how long it takes to get there.</p>
<p>In the case of an LRA, the back-EMF and hence the measured current is induced by speed of the movement of the magnetic mass through the voice coil. As this movement is sinusoidal, this results in a sinusoidal signal that is superimposed on top of the square wave drive signal. By measuring the amplitude of the back-EMF signal, we can monitor when the LRA reaches equilibrium and how long it takes to get there. By measuring the phase on the back-EMF signal, we can monitor whether the LRA is being driven on its resonant frequency.</p>
<h2>Curve Fitter</h2>
<p>The Curve Fitter module is provided for determining the behavior and state of a haptic actuator by monitoring and analyzing the electrical current induced by the back-EMF as it rotates/oscillates.</p>
<p>The haptic driver interface samples the ADC 8 times every half period. Curve Fitter processing is designed to be triggered just after the seventh sample has been captured so that the sampled data can be analyzed and new drive parameters calculated prior to the start of the next half period.</p>
<p>The curve fitter analyzes the shape of the sampled half period data to separate the sinusoidal back EMF current signal from the DC drive signal to calculate the amplitude and phase offset of the back-EMF signal (LRA only) as well as the DC drive level.</p>
<h3>API Usage</h3>
<h4>Initialization</h4>
<p>An instance of the <code>curve_fitter_params</code> parameter structure must be instantiated, either statically or on the heap, and must be maintained for the life-cycle of haptics processing.</p>
<p>Before processing can be performed on an instance of the Curve Fitter module, a subset of the parameters within the <code>curve_fitter_params</code> structure must be initialized. These parameters are as follows:</p><ul>
<li><code>amplitude_threshold</code>: Amplitude threshold below which <code>phi</code> is not calculated.</li>
</ul>
<p>Note: All remaining parameters are output parameters and need not be initialized.</p>
<p>When the amplitude of the back-EMF signal is low, the curve fitter cannot accurately calculate its phase offset and can erroneously lock on to spurious peaks generated by noise. This can have a negative impact on the behavior of the automatic frequency control algorithm. To prevent this, the <code>amplitude_threshold</code> parameter is provided to specify the amplitude threshold below which the phase offset should not be calculated.</p>
<p>This should be set to an amplitude level at which the back-EMF signal is comfortably distinguishable from the noise. This parameter uses the same value representation as the raw <code>i_data</code> samples captured by the driver interface (see below).</p>
<p>Note: When the amplitude of the back-EMF signal is below the specified threshold, the output phase offset (<code>phi</code>) will be set to zero.</p>
<h4>Processing</h4>
<p>Curve Fitter module processing is performed by calling the <code><a class="el" href="group___c_u_r_v_e___f_i_t_t_e_r.html#gac3870b62c1f64d873c2c80af438afcec">curve_fitter_process()</a></code> function. This function is designed to be called from within a call-back function registered with the haptic driver interface's low-level driver.</p>
<p>The parameters of this function are as follows:</p><ul>
<li><code>params</code>: Pointer to an instance of the <code>curve_fitter_params</code> structure.</li>
<li><code>i_data</code>: Pointer to an array of ADC current data samples.</li>
</ul>
<p>The <code>i_data</code> pointer should reference an array of the 8 16-bit samples of ADC data captured by the driver interface over the duration of the half period.</p>
<p>After calling the <code><a class="el" href="group___c_u_r_v_e___f_i_t_t_e_r.html#gac3870b62c1f64d873c2c80af438afcec">curve_fitter_process()</a></code> function, the calculated output parameters can be read from the <code>curve_fitter_params</code> structure. The output parameters are as follows:</p><ul>
<li><code>dc_offset</code>: DC current component/offset.</li>
<li><code>amplitude</code>: Amplitude of back-EMF current signal.</li>
<li><code>phi</code>: Phase offset of back-EMF current signal.</li>
<li><code>phasor</code>: Phasor representation of back-EMF current signal.<ul>
<li><code>x</code>: Real component of <code>phasor</code>.</li>
<li><code>y</code>: Imaginary component of <code>phasor</code>.</li>
</ul>
</li>
</ul>
<p>The representations of the <code>dc_offset</code>, <code>amplitude</code> parameters and components of <code>phasor</code> parameter are the same as the raw <code>i_data</code> samples.</p>
<p>The representation of <code>phi</code> is normalized angle in Q1.15 fixed-point format (i.e. -32768 to 32767 represents -&pi; to +&pi;).</p>
<h2>Automatic Frequency Control (AFC)</h2>
<p>The Automatic Frequency Control (AFC) module is provided for monitoring the resonant frequency of an LRA and adjusting the drive frequency accordingly. This ensures that the LRA is driven on its resonant frequency at all times, maximizing its efficiency and the amount of accelerative force delivered.</p>
<p>The algorithm monitors the phase offset calculated by the curve fitter to determine whether or not the LRA is resonating in phase with the drive signal and hence is being driven at its resonant frequency. When a phase offset is detected the AFC adjusts the half period of the drive signal accordingly until the phase offset disappears.</p>
<p>Note: The AFC module is only applicable for LRAs and should be disabled when an ERM is in use.</p>
<h3>API Usage</h3>
<h4>Initialization</h4>
<p>An instance of the <code>lra_afc_params</code> parameter structure must be instantiated, either statically or on the heap, and must be maintained for the life-cycle of haptics processing.</p>
<p>Before processing can be performed on an instance of the AFC module, the parameters within the <code>lra_afc_params</code> structure must be initialized. These parameters are as follows:</p><ul>
<li><code>half_period</code>: Initial half period.</li>
<li><code>half_period_min</code>: Minimum half period limit.</li>
<li><code>half_period_max</code>: Maximum half period limit.</li>
<li><code>zeta</code>: Damping factor.</li>
</ul>
<p>The initial half period (<code>half_period</code>) should be initialized by setting its value according to a half period that corresponds to the resonant frequency of the LRA as specified in its datasheet.</p>
<p>The minimum and maximum half period limits specify the allowable range of half periods that can be calculated by the algorithm. These prevent the algorithm from converging on other resonant peaks other than that of the fundamental resonant frequency, such as harmonic and sub-harmonic frequencies. Typically this range should be set to encompass the full variability in potential resonant frequency experienced by all LRAs of a particular type under all operating conditions. <code>half_period_min</code> should always be set to a value which is greater than half the nominal half period. <code>half_period_max</code> should always be set to a value which is less than double the nominal half period.</p>
<p>The representation of <code>half_period</code>, <code>half_period_min</code> and <code>half_period_max</code> is the same unsigned 16-bit format as that used to configure the half period in the driver interface.</p>
<p>In some cases there may be some instability or resonance in the closed control loop tracking the LRA's resonant frequency. This can result in some oscillation in the calculated resonant frequency, causing it to take longer than it should to converge or not to converge at all. To prevent this, a parameter has been provided (<code>zeta</code>) to damp out any oscillations and make the control loop more stable. This is represented in unsigned Q1.15 fixed-point format with the range of 0 to 32768 (representing 0.0 to 1.0). The lower this value, the more damping is applied. Setting this to a value of 32768 (1.0) effectively disables damping.</p>
<h4>Processing</h4>
<p>AFC module processing is performed by calling the <code><a class="el" href="group___a_f_c.html#ga3849c3a8329aac558f040ecd4af1a864">lra_afc_process()</a></code> function. This function is designed to be called from within a call-back function registered with the haptic driver interface's low-level driver.</p>
<p>The parameters of this function are as follows:</p><ul>
<li><code>params</code>: Pointer to an instance of the <code>lra_afc_params</code> structure.</li>
<li><code>half_period</code>: Half period value for current half period.</li>
<li><code>phase_offset</code>: Phase offset for current half period.</li>
</ul>
<p>The <code>half_period</code> parameter should be set according to the half period value used to drive the LRA over the current half period. Ideally this should be read directly from the driver interface and uses the same representation.</p>
<p>The <code>phase_offset</code> parameter should be set according to the value of <code>phi</code> calculated by the curve fitter from the sampled <code>i_data</code> for the current half period and uses the same representation.</p>
<p>After calling the <code><a class="el" href="group___a_f_c.html#ga3849c3a8329aac558f040ecd4af1a864">lra_afc_process()</a></code> function, the updated <code>half_period</code> parameter can be read from the <code>lra_afc_params</code> structure. Note that this is also returned by the <code><a class="el" href="group___a_f_c.html#ga3849c3a8329aac558f040ecd4af1a864">lra_afc_process()</a></code> function. This updated value should be used to configure the driver interface for the next half period.</p>
<h2>SmartDrive&trade;</h2>
<p>The SmartDrive module is provided for overdriving LRAs to accelerate/brake them, improving their transient responses as well as to monitor and adapt to changes in their mechanical time constants.</p>
<p>LRAs typically have an inherent mechanical time constant associated with their mechanics which dictates how long they take to reach their equilibrium state after a change in the level at which they are driven. This can result in some lag before the full accelerative force is felt after a pulse is triggered and for it to die away again after then pulse has ended. This is especially problematic for the more transient haptic patterns such as short pulses, pulse trains and more complex dynamic patterns as the energy is spread out over time resulting in less sharp and distinct haptic sensations.</p>
<p>To alleviate this, the SmartDrive algorithm is able to overdrive the LRA to accelerate/brake it, shortening the associated start/stop times resulting in an accelerative amplitude response that more closely matches the drive level specified in the haptic pattern being driven.</p>
<p>In order to know how hard the LRA should be overdriven, the SmartDrive algorithm must have knowledge of what its mechanical time constant actually is and track how it changes according to changes in the operating environment (e.g. temperature, pressure, mechanical coupling, etc.). It does this by tracking and adapting to changes in the amplitude response of the LRA's back-EMF signal according to changes in the drive level, by means of a recursive least squares (RLS) adaptive filter.</p>
<p>Note: The SmartDrive module is currently only applicable for LRAs and should be disabled when an ERM is in use. Support for ERMs will be added in a future release.</p>
<h3>API Usage</h3>
<h4>Initialization</h4>
<p>An instance of the <code>smart_drive_params</code> parameter structure must be instantiated, either statically or on the heap, and must be maintained for the life-cycle of haptics processing.</p>
<p>Before processing can be performed on an instance of the SmartDrive module, a subset of the parameters within the <code>smart_drive_params</code> structure must be initialized. These parameters are as follows:</p><ul>
<li><code>flags</code>: Instance of the <code>smart_drive_flags</code> bitfield structure:<ul>
<li><code>apply</code>: Apply flag.</li>
<li><code>update</code>: Update flag.</li>
</ul>
</li>
<li><code>peak_amplitude</code>: Peak expected back-EMF amplitude.</li>
<li><code>tau</code>: Mechanical time constant.</li>
<li><code>lambda</code>: RLS forgetting factor.</li>
<li><code>delta</code>: RLS matrix initialization parameter.</li>
</ul>
<p>Note: All remaining parameters are state or output parameters and need not be initialized.</p>
<p>The <code>flags</code> parameter includes a set of control flags for the algorithm. These can either be set at initialization and left unchanged or modified at runtime if more dynamic control of the algorithm is required.</p><ul>
<li>The <code>apply</code> flag controls the drive component of the algorithm. When enabled the LRA is overdriven to accelerate/brake it.</li>
<li>The <code>update</code> flag controls the adaptive part of the algorithm. When enabled the algorithm monitors the measured amplitude response of the LRA's back-EMF signal to adapt its internal model coefficients using the RLS filter.</li>
</ul>
<p>These flags are mutually exclusive and can be used in any configuration. However when applying the drive component of the algorithm with the adaptive part disabled, it is necessary to initialize the <code>tau</code> parameter with a relatively accurate estimate of the true mechanical time constant. Note: This configuration has the advantage of allowing SmartDrive to be used in open loop mode.</p>
<p><code>peak_amplitude</code> should be set according to the expected peak back-EMF amplitude when the LRA is driven on its resonant frequency at the maximum allowable drive level. Ideally this value should be obtained by measurement. The representation of this value is the same as the format used by the raw ADC samples and as calculated by the curve fitter.</p>
<p>The mechanical time constant (<code>tau</code>) is represented in unsigned Q1.15 fixed-point format with a range of 0 to 32768 (representing 0.0 to 1.0). It should be set according to the start/stop time for the LRA as stated in its datasheet. If unavailable, this value can also be obtained by measurement. Alternatively it can be initialized to a value of 32768 (1.0) and the true value can be calculated by the algorithm at runtime, although it will require some suitable stimulus before it is able to adapt and accurately accelerate/brake the LRA.</p>
<p>The RLS forgetting factor (<code>lambda</code>) is represented in unsigned Q1.15 fixed-point format with a range of 0 to 32768 (representing 0.0 to 1.0). This should be initialized to a value of slightly under 32768 (1.0). The default value of 32440 (0.99) is recommended.</p>
<p>The RLS matrix initialization parameter (<code>delta</code>) is represented in unsigned integer format. The higher this value, the quicker the RLS algorithm will converge on solution however instability may result if set too high. A value in the range of 100-1000 is recommended.</p>
<p>After initializing all of the required parameters in the <code>smart_drive_params</code> parameter structure, it is necessary to complete the module initialization by calling the <code><a class="el" href="group___s_m_a_r_t_d_r_i_v_e.html#ga87a3824437f464cf1d61db7f36bd25af">smart_drive_init()</a></code> function, passing a pointer to the parameter structure instance via the <code>params</code> function parameter.</p>
<h4>Processing</h4>
<p>SmartDrive module processing is performed by calling the <code><a class="el" href="group___s_m_a_r_t_d_r_i_v_e.html#gacaf51ac054f2c6b5c0a34df156bd1e5d">smart_drive_process()</a></code> function. This function is designed to be called from within a call-back function registered with the haptic driver interface's low-level driver.</p>
<p>The parameters of this function are as follows:</p><ul>
<li><code>params</code>: Pointer to an instance of the <code>smart_drive_params</code> structure.</li>
<li><code>target_level</code>: Target drive level for next half period.</li>
<li><code>amplitude</code>: Measured LRA back-EMF amplitude for current half period.</li>
<li><code>drive_level</code>: Drive level for current half period.</li>
</ul>
<p>The <code>target_level</code> parameter should be set according to the desired target drive level for the next half period. This parameter is represented as an unsigned Q1.15 fixed-point format in the range of 0 to 32768 (representing 0 to 100%).</p>
<p>The <code>amplitude</code> parameter should be set according to the value of the measured LRA back-EMF amplitude as calculated by the curve fitter from the sampled <code>i_data</code> for the current half period and uses the same representation.</p>
<p>The <code>drive_level</code> parameter should be set according to the <em>actual</em> drive level used to drive the LRA for the current half period, as calculated by the SmartDrive algorithm in the previous half period and accounting for any other subsequent external modification (e.g. drive level limiting in the low-level driver). This parameter is represented as an unsigned Q1.15 fixed-point format in the range of 0 to 32768 (representing 0 to 100%).</p>
<p>After calling the <code><a class="el" href="group___s_m_a_r_t_d_r_i_v_e.html#gacaf51ac054f2c6b5c0a34df156bd1e5d">smart_drive_process()</a></code> function, the updated <code>drive_level</code> parameter can be read from the <code>smart_drive_params</code> structure. Note that this is also returned by the <code><a class="el" href="group___s_m_a_r_t_d_r_i_v_e.html#gacaf51ac054f2c6b5c0a34df156bd1e5d">smart_drive_process()</a></code> function. This updated value should be used to configure the driver interface for the next half period.</p>
<p>Note that when the <code>apply</code> flag is disabled, the updated drive level is simply set to the same value as the given target level. When enabled the given target level is modified to overdrive the LRA but this is limited by the amount of dynamic range available. For example, when a target level of 100% is requested, it is not possible to overdrive the LRA as the target level is already at the maximum.</p>
<h2>Haptics Algorithm Library Wrapper</h2>
<p>The Haptics Algorithm Library Wrapper module is provided for integrating all of the modules within the Haptics Library together so that they can operate efficiently as a whole and to manage their interactions. Although the library does allow the flexibility to use each of the constituent modules individually, it is recommended to use them in the context of the wrapper, especially if more than a single module is to be used at a time.</p>
<p>In addition to wrapping the modules contained within the library, the wrapper adds additional functionality such as intelligence for managing the polarity of the driver interface. This includes a mechanism for making sure that the drive polarity at the start of all pulses/patterns is consistent.</p>
<h3>API Usage</h3>
<h4>Initialization</h4>
<p>An instance of the <code>haptics_lib_params</code> parameter structure must be instantiated, either statically or on the heap, and must be maintained for the life-cycle of haptics processing.</p>
<p>Before processing can be performed on an instance of the wrapper module, a subset of the parameters within the <code>haptics_lib_params</code> structure must be initialized. These parameters are as follows:</p><ul>
<li><code>flags</code>: Instance of the <code>haptics_lib_flags</code> bitfield structure:<ul>
<li><code>curve_fitter_enabled</code>: Enable flag for curve fitter.</li>
<li><code>lra_afc_enabled</code>: Enable flag for AFC.</li>
<li><code>smart_drive_enabled</code>: Enable flag for SmartDrive.</li>
<li><code>start_polarity</code>: Start polarity of pulses/patterns.</li>
</ul>
</li>
<li><code>i_data_threshold</code>: Threshold of valid <code>i_data</code>.</li>
<li><code>curve_fitter</code>: Instance of the <code>curve_fitter_params</code> parameter structure.</li>
<li><code>lra_afc</code>: Instance of the <code>lra_afc_params</code> parameter structure.</li>
<li><code>smart_drive</code>: Instance of the <code>smart_drive_params</code> parameter structure.</li>
</ul>
<p>Note: All remaining parameters are output parameters and need not be initialized.</p>
<p>The <code>flags</code> parameter includes a set of control flags for the library. These either can be set at initialization and left unchanged or modified at runtime if more dynamic control of the library is required. Most of these flags simply control the enable state of the individual library modules. The exception is the <code>start_polarity</code> flag which controls the start polarity of all patterns/pulses.</p>
<p>Note: As all of the other modules depend on the curve fitter, the <code>curve_fitter_enabled</code> flag also acts as a global enable/disable control for all modules.</p>
<p>Due to the way the driver interface's sense circuit is designed, the ADC is unable to detect voltages across the sense resistor that are below a certain threshold (including negative voltages). This results in <code>i_data</code> that is sometimes clipped at a certain minimum value. To protect the algorithms from this erroneous data, the <code>i_data_threshold</code> parameter is provided to specify the threshold below which <code>i_data</code> should no longer be considered as valid. If the wrapper detects that the sampled <code>i_data</code> dips below this threshold during a half period it temporarily disables the adaptation of the AFC and SmartDrive modules until the data is valid again.</p>
<p>The remaining module parameter structures should be initialized as outlined in the previous sections.</p>
<p>After initializing all of the required parameters in the <code>haptics_lib_params</code> parameter structure, it is necessary to complete the wrapper initialization by calling the <code><a class="el" href="group___h_a_p_t_i_c_s___l_i_b.html#gadff4e71b7b032c41a9373dea487f7e74">haptics_lib_init()</a></code> function, passing a pointer to the parameter structure instance via the <code>params</code> function parameter. This in turn calls the initialization functions for all of the submodules (if they have one).</p>
<h4>Processing</h4>
<p>Haptics Algorithm Library Wrapper processing is performed by calling the <code><a class="el" href="group___h_a_p_t_i_c_s___l_i_b.html#gab18734f05282b57253f56ec88135725e">haptics_lib_process()</a></code> function. This function is designed to be called from within a call-back function registered with the haptic driver interface's low-level driver.</p>
<p>The parameters of this function are as follows:</p><ul>
<li><code>params</code>: Pointer to an instance of the <code>haptics_lib_params</code> structure.</li>
<li><code>i_data</code>: Pointer to an array of ADC current data samples.</li>
<li><code>half_period</code>: Pointer to half period value for current half period.</li>
<li><code>drive_level</code>: Pointer to drive level for current half period.</li>
<li><code>state</code>: Pointer to an instance of the <code>haptics_lib_if_state</code> structure:<ul>
<li><code>drive_polarity</code>: Phase/polarity of the current half period.</li>
<li><code>drive_polarity_inverted</code>: Indicates whether the drive polarity is currently inverted.</li>
<li><code>i_data_valid</code>: Indicates whether <code>i_data</code> is valid.</li>
</ul>
</li>
<li><code>target_level</code>: Target drive level for next half period.</li>
</ul>
<p>The <code>i_data</code>, <code>half_period</code>, <code>drive_level</code> and <code>target_level</code> values should be set as has been previously outlined for the submodules where they are ultimately used. In the case of the <code>half_period</code> and <code>drive_level</code> however, these are passed by reference so that they can be updated by the <code><a class="el" href="group___h_a_p_t_i_c_s___l_i_b.html#gab18734f05282b57253f56ec88135725e">haptics_lib_process()</a></code> function and passed back to the calling function to be used to configure the driver interface for the next half period.</p>
<p>The <code>state</code> parameter is a bitfield structure of flags which indicate the current state of the hardware driver interface, primarily with regards to polarity. These flags should be set by the calling function prior to calling <code><a class="el" href="group___h_a_p_t_i_c_s___l_i_b.html#gab18734f05282b57253f56ec88135725e">haptics_lib_process()</a></code>.</p>
<p>The <code>i_data_valid</code> flag should be used to indicate whether the data passed via the <code>i_data</code> parameter is valid. When set to 0, the <code>i_data</code> is ignored and adaptation of the algorithms is disabled. In most cases, when operating in closed loop mode, this should always be set to 1 unless the <code>i_data</code> is invalid for any reason. Set to 0 when operating in open loop mode.</p>
<p>The <code>state</code> parameter is passed by reference so that the <code>drive_polarity_inverted</code> can be modified by the <code><a class="el" href="group___h_a_p_t_i_c_s___l_i_b.html#gab18734f05282b57253f56ec88135725e">haptics_lib_process()</a></code> function. This allows the wrapper to indicate to the calling function what the state of the polarity inversion should be for the next half period. This should be used to configure the driver interface accordingly. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 15 2022 14:13:47 for SmartSnippets DA1469x SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>

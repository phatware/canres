<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>SmartSnippets DA1469x SDK: Clock Manager Service</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1469x SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Board&#160;and&#160;Applications&#160;General&#160;Info</span></a></li>
      <li><a href="modules.html"><span>SDK&#160;Architecture</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Clock Manager Service<div class="ingroups"><a class="el" href="group___m_i_d_d_l_e_w_a_r_e.html">Middleware</a> &raquo; <a class="el" href="group___m_i_d___s_y_s_t_e_m.html">System</a> &raquo; <a class="el" href="group___m_i_d___s_y_s___s_e_r_v_i_c_e_s.html">System Services</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Clock Manager.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:sys__clock__mgr_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys__clock__mgr_8h.html">sys_clock_mgr.h</a></td></tr>
<tr class="memdesc:sys__clock__mgr_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock Manager header file. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad4e7df8e63e272869fcc340ece7b4d79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gad4e7df8e63e272869fcc340ece7b4d79">cm_sys_clk_init</a> (<a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> type)</td></tr>
<tr class="memdesc:gad4e7df8e63e272869fcc340ece7b4d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize clocks after power-up.  <a href="#gad4e7df8e63e272869fcc340ece7b4d79">More...</a><br /></td></tr>
<tr class="separator:gad4e7df8e63e272869fcc340ece7b4d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab21be99e0948c369d31d53a5bd187dbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab21be99e0948c369d31d53a5bd187dbd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gab21be99e0948c369d31d53a5bd187dbd">cm_rcx_calibrate</a> (void)</td></tr>
<tr class="memdesc:gab21be99e0948c369d31d53a5bd187dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibrate RCX. <br /></td></tr>
<tr class="separator:gab21be99e0948c369d31d53a5bd187dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0deec6c3c8fc0f44efeefca205c99b50"><td class="memItemLeft" align="right" valign="top">cm_sys_clk_set_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga0deec6c3c8fc0f44efeefca205c99b50">cm_sys_clk_set</a> (<a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> type)</td></tr>
<tr class="memdesc:ga0deec6c3c8fc0f44efeefca205c99b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the system clock.  <a href="#ga0deec6c3c8fc0f44efeefca205c99b50">More...</a><br /></td></tr>
<tr class="separator:ga0deec6c3c8fc0f44efeefca205c99b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a489811442df40533f748695d6494d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae7a489811442df40533f748695d6494d">cm_cpu_clk_set</a> (<a class="el" href="group___h_w___c_l_k.html#gaae49d94cffe9c77837af61544d1c53f7">cpu_clk_t</a> clk)</td></tr>
<tr class="memdesc:gae7a489811442df40533f748695d6494d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the CPU clock.  <a href="#gae7a489811442df40533f748695d6494d">More...</a><br /></td></tr>
<tr class="separator:gae7a489811442df40533f748695d6494d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86825b725aa19f183a4876d8a42ccbef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga86825b725aa19f183a4876d8a42ccbef">cm_cpu_clk_set_fromISR</a> (<a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> clk, <a class="el" href="group___h_w___c_l_k.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a> hdiv)</td></tr>
<tr class="memdesc:ga86825b725aa19f183a4876d8a42ccbef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the system and the AHB bus clock (interrupt safe version).  <a href="#ga86825b725aa19f183a4876d8a42ccbef">More...</a><br /></td></tr>
<tr class="separator:ga86825b725aa19f183a4876d8a42ccbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4c7649939d439045d58fec27c4b48c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaa4c7649939d439045d58fec27c4b48c2">cm_apb_set_clock_divider</a> (<a class="el" href="group___h_w___c_l_k.html#ga76dc2db718173b123e891b885cf77023">apb_div_t</a> div)</td></tr>
<tr class="memdesc:gaa4c7649939d439045d58fec27c4b48c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the divider of the AMBA Peripheral Bus clock.  <a href="#gaa4c7649939d439045d58fec27c4b48c2">More...</a><br /></td></tr>
<tr class="separator:gaa4c7649939d439045d58fec27c4b48c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44b18ecfc74a372db8f75ba23c974126"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga44b18ecfc74a372db8f75ba23c974126">cm_ahb_set_clock_divider</a> (<a class="el" href="group___h_w___c_l_k.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a> div)</td></tr>
<tr class="memdesc:ga44b18ecfc74a372db8f75ba23c974126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the divider of the AMBA High speed Bus clock.  <a href="#ga44b18ecfc74a372db8f75ba23c974126">More...</a><br /></td></tr>
<tr class="separator:ga44b18ecfc74a372db8f75ba23c974126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec75427c454e4476752fa28d8147b47e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaec75427c454e4476752fa28d8147b47e">cm_sys_clk_get</a> (void)</td></tr>
<tr class="memdesc:gaec75427c454e4476752fa28d8147b47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sys_clk that the system uses at that moment.  <a href="#gaec75427c454e4476752fa28d8147b47e">More...</a><br /></td></tr>
<tr class="separator:gaec75427c454e4476752fa28d8147b47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7c573992fb1d59dd642ee3ef12177ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae7c573992fb1d59dd642ee3ef12177ae">cm_sys_clk_get_fromISR</a> (void)</td></tr>
<tr class="memdesc:gae7c573992fb1d59dd642ee3ef12177ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sys_clk that the system uses at that moment (interrupt safe version).  <a href="#gae7c573992fb1d59dd642ee3ef12177ae">More...</a><br /></td></tr>
<tr class="separator:gae7c573992fb1d59dd642ee3ef12177ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c46e80c972a2214a394c62b9c60bc22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___c_l_k.html#ga76dc2db718173b123e891b885cf77023">apb_div_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga1c46e80c972a2214a394c62b9c60bc22">cm_apb_get_clock_divider</a> (void)</td></tr>
<tr class="memdesc:ga1c46e80c972a2214a394c62b9c60bc22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the AMBA Peripheral Bus clock divider.  <a href="#ga1c46e80c972a2214a394c62b9c60bc22">More...</a><br /></td></tr>
<tr class="separator:ga1c46e80c972a2214a394c62b9c60bc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga462965cf64536f7d5d6f9c72b5f3e4e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___c_l_k.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga462965cf64536f7d5d6f9c72b5f3e4e9">cm_ahb_get_clock_divider</a> (void)</td></tr>
<tr class="memdesc:ga462965cf64536f7d5d6f9c72b5f3e4e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the AMBA High speed Bus clock divider.  <a href="#ga462965cf64536f7d5d6f9c72b5f3e4e9">More...</a><br /></td></tr>
<tr class="separator:ga462965cf64536f7d5d6f9c72b5f3e4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60c2817b0b31bec83ce2d4245766a300"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___c_l_k.html#gaae49d94cffe9c77837af61544d1c53f7">cpu_clk_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga60c2817b0b31bec83ce2d4245766a300">cm_cpu_clk_get</a> (void)</td></tr>
<tr class="memdesc:ga60c2817b0b31bec83ce2d4245766a300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the CPU clock frequency.  <a href="#ga60c2817b0b31bec83ce2d4245766a300">More...</a><br /></td></tr>
<tr class="separator:ga60c2817b0b31bec83ce2d4245766a300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b31d79dea86dfba84b3a6dbd56bd9c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_w___c_l_k.html#gaae49d94cffe9c77837af61544d1c53f7">cpu_clk_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga7b31d79dea86dfba84b3a6dbd56bd9c9">cm_cpu_clk_get_fromISR</a> (void)</td></tr>
<tr class="memdesc:ga7b31d79dea86dfba84b3a6dbd56bd9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the CPU clock frequency (interrupt safe).  <a href="#ga7b31d79dea86dfba84b3a6dbd56bd9c9">More...</a><br /></td></tr>
<tr class="separator:ga7b31d79dea86dfba84b3a6dbd56bd9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b96b631a34f1e2c30a9213f300d3798"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8b96b631a34f1e2c30a9213f300d3798"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga8b96b631a34f1e2c30a9213f300d3798">cm_calibrate_rc32k</a> (void)</td></tr>
<tr class="memdesc:ga8b96b631a34f1e2c30a9213f300d3798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibrate RC32K. <br /></td></tr>
<tr class="separator:ga8b96b631a34f1e2c30a9213f300d3798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae884fa4c86df75b1cb87f591b9417e2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae884fa4c86df75b1cb87f591b9417e2b">cm_rcx_us_2_lpcycles</a> (uint32_t usec)</td></tr>
<tr class="memdesc:gae884fa4c86df75b1cb87f591b9417e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts usec to RCX cycles.  <a href="#gae884fa4c86df75b1cb87f591b9417e2b">More...</a><br /></td></tr>
<tr class="separator:gae884fa4c86df75b1cb87f591b9417e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64bbd9cd49b18ce46a71fa41ae287587"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga64bbd9cd49b18ce46a71fa41ae287587">cm_rcx_us_2_lpcycles_low_acc</a> (uint32_t usec)</td></tr>
<tr class="memdesc:ga64bbd9cd49b18ce46a71fa41ae287587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts time to RCX cycles.  <a href="#ga64bbd9cd49b18ce46a71fa41ae287587">More...</a><br /></td></tr>
<tr class="separator:ga64bbd9cd49b18ce46a71fa41ae287587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73baf5e403b2eb3f68f01a2d53d06260"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga73baf5e403b2eb3f68f01a2d53d06260">cm_wait_xtalm_ready</a> (void)</td></tr>
<tr class="memdesc:ga73baf5e403b2eb3f68f01a2d53d06260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until the fast XTAL clock (XTALxxM) is ready. If the fast XTAL clock (XTALxxM) is running then the function exits immediately.  <a href="#ga73baf5e403b2eb3f68f01a2d53d06260">More...</a><br /></td></tr>
<tr class="separator:ga73baf5e403b2eb3f68f01a2d53d06260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b8877669784653584dcbc4fb1ac0536"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5b8877669784653584dcbc4fb1ac0536"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga5b8877669784653584dcbc4fb1ac0536">cm_rcx_calibration_task_init</a> (void)</td></tr>
<tr class="memdesc:ga5b8877669784653584dcbc4fb1ac0536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the RCX calibration task. <br /></td></tr>
<tr class="separator:ga5b8877669784653584dcbc4fb1ac0536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga535fddae4aadc649ce4c11c9bb43b0d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga535fddae4aadc649ce4c11c9bb43b0d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga535fddae4aadc649ce4c11c9bb43b0d1">cm_rcx_trigger_calibration</a> (void)</td></tr>
<tr class="memdesc:ga535fddae4aadc649ce4c11c9bb43b0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger RCX calibration. <br /></td></tr>
<tr class="separator:ga535fddae4aadc649ce4c11c9bb43b0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9857796532a9d4e64156b009bd82fee2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga9857796532a9d4e64156b009bd82fee2">cm_lp_clk_init</a> (void)</td></tr>
<tr class="memdesc:ga9857796532a9d4e64156b009bd82fee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Low Power clock.  <a href="#ga9857796532a9d4e64156b009bd82fee2">More...</a><br /></td></tr>
<tr class="separator:ga9857796532a9d4e64156b009bd82fee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1441219191476e451ba6fbc41bb9e103"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga1441219191476e451ba6fbc41bb9e103">cm_lp_clk_is_avail</a> (void)</td></tr>
<tr class="memdesc:ga1441219191476e451ba6fbc41bb9e103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the Low Power clock is available.  <a href="#ga1441219191476e451ba6fbc41bb9e103">More...</a><br /></td></tr>
<tr class="separator:ga1441219191476e451ba6fbc41bb9e103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8326d96c90e17710e709c0de96fc5e76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga8326d96c90e17710e709c0de96fc5e76">cm_lp_clk_is_avail_fromISR</a> (void)</td></tr>
<tr class="memdesc:ga8326d96c90e17710e709c0de96fc5e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the Low Power clock is available, interrupt safe version.  <a href="#ga8326d96c90e17710e709c0de96fc5e76">More...</a><br /></td></tr>
<tr class="separator:ga8326d96c90e17710e709c0de96fc5e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dcfa191a663cbc9e2998e79cbc7b68e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga6dcfa191a663cbc9e2998e79cbc7b68e">cm_wait_lp_clk_ready</a> (void)</td></tr>
<tr class="memdesc:ga6dcfa191a663cbc9e2998e79cbc7b68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the Low Power clock is available.  <a href="#ga6dcfa191a663cbc9e2998e79cbc7b68e">More...</a><br /></td></tr>
<tr class="separator:ga6dcfa191a663cbc9e2998e79cbc7b68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga934fb28da416965225259e4964276456"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga934fb28da416965225259e4964276456">cm_lp_clk_wakeup</a> (void)</td></tr>
<tr class="memdesc:ga934fb28da416965225259e4964276456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the flag that indicates that the Low Power clock is available.  <a href="#ga934fb28da416965225259e4964276456">More...</a><br /></td></tr>
<tr class="separator:ga934fb28da416965225259e4964276456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95526e50703ab838153d26e353f36c4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga95526e50703ab838153d26e353f36c4b">cm_wait_pll_lock</a> (void)</td></tr>
<tr class="memdesc:ga95526e50703ab838153d26e353f36c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until the PLL is locked. If the PLL is locked then the function exits immediately.  <a href="#ga95526e50703ab838153d26e353f36c4b">More...</a><br /></td></tr>
<tr class="separator:ga95526e50703ab838153d26e353f36c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed5356a34ab5e81acb542f55a0284b5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaed5356a34ab5e81acb542f55a0284b5c">cm_poll_xtalm_ready</a> (void)</td></tr>
<tr class="memdesc:gaed5356a34ab5e81acb542f55a0284b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the fast XTAL clock (XTALxxM) is ready.  <a href="#gaed5356a34ab5e81acb542f55a0284b5c">More...</a><br /></td></tr>
<tr class="separator:gaed5356a34ab5e81acb542f55a0284b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac76f394c9ba43cf22a747795245cf4a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gac76f394c9ba43cf22a747795245cf4a7">cm_enable_xtalm</a> (void)</td></tr>
<tr class="memdesc:gac76f394c9ba43cf22a747795245cf4a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the fast XTAL clock (XTALxxM)  <a href="#gac76f394c9ba43cf22a747795245cf4a7">More...</a><br /></td></tr>
<tr class="separator:gac76f394c9ba43cf22a747795245cf4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe2850f410d98cf04468a7e86c4464f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gafe2850f410d98cf04468a7e86c4464f3">cm_sys_clk_sleep</a> (bool entering_sleep)</td></tr>
<tr class="memdesc:gafe2850f410d98cf04468a7e86c4464f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the system clock (unprotected).  <a href="#gafe2850f410d98cf04468a7e86c4464f3">More...</a><br /></td></tr>
<tr class="separator:gafe2850f410d98cf04468a7e86c4464f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac523437b2bdff9ee4ca005d3f66e372d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gac523437b2bdff9ee4ca005d3f66e372d">cm_halt_until_xtalm_ready</a> (void)</td></tr>
<tr class="memdesc:gac523437b2bdff9ee4ca005d3f66e372d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Halt until the fast XTAL clock (XTALxxM) has settled.  <a href="#gac523437b2bdff9ee4ca005d3f66e372d">More...</a><br /></td></tr>
<tr class="separator:gac523437b2bdff9ee4ca005d3f66e372d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab56ed15acc5f7574a4ef86dea5840326"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gab56ed15acc5f7574a4ef86dea5840326">cm_register_xtal_ready_callback</a> (void(*cb)(void))</td></tr>
<tr class="memdesc:gab56ed15acc5f7574a4ef86dea5840326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a callback function to be called then XTAL32M is ready.  <a href="#gab56ed15acc5f7574a4ef86dea5840326">More...</a><br /></td></tr>
<tr class="separator:gab56ed15acc5f7574a4ef86dea5840326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2c42a055775f448744cc922390378e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaa2c42a055775f448744cc922390378e0">cm_halt_until_pll_locked</a> (void)</td></tr>
<tr class="memdesc:gaa2c42a055775f448744cc922390378e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Halt until PLL is locked.  <a href="#gaa2c42a055775f448744cc922390378e0">More...</a><br /></td></tr>
<tr class="separator:gaa2c42a055775f448744cc922390378e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9267369c5ae554ee6b3a85db8dd4166b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga9267369c5ae554ee6b3a85db8dd4166b">cm_halt_until_sysclk_ready</a> (void)</td></tr>
<tr class="memdesc:ga9267369c5ae554ee6b3a85db8dd4166b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Halt until system clock (either PLL or XTAL32M) is ready.  <a href="#ga9267369c5ae554ee6b3a85db8dd4166b">More...</a><br /></td></tr>
<tr class="separator:ga9267369c5ae554ee6b3a85db8dd4166b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Clock Manager. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga462965cf64536f7d5d6f9c72b5f3e4e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___c_l_k.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a> cm_ahb_get_clock_divider </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the AMBA High speed Bus clock divider. </p>
<dl class="section return"><dt>Returns</dt><dd>The hclk being used.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="ga44b18ecfc74a372db8f75ba23c974126"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cm_ahb_set_clock_divider </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a>&#160;</td>
          <td class="paramname"><em>div</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the divider of the AMBA High speed Bus clock. </p>
<p>The frequency of the AHB clock is (system_clock / (1 &lt;&lt; cm_ahbclk)). Note: if the SysTick runs then it is the dg_configABORT_IF_SYSTICK_CLK_ERR setting that controls whether the switch will be aborted or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">div</td><td>The new value of the AHB divider.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the divider was changed to the requested value, else false.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1c46e80c972a2214a394c62b9c60bc22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___c_l_k.html#ga76dc2db718173b123e891b885cf77023">apb_div_t</a> cm_apb_get_clock_divider </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the AMBA Peripheral Bus clock divider. </p>
<dl class="section return"><dt>Returns</dt><dd>The pclk being used.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4c7649939d439045d58fec27c4b48c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_apb_set_clock_divider </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga76dc2db718173b123e891b885cf77023">apb_div_t</a>&#160;</td>
          <td class="paramname"><em>div</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the divider of the AMBA Peripheral Bus clock. </p>
<p>The frequency of the APB clock is (system_clock / (1 &lt;&lt; cm_ahbclk)) / (1 &lt;&lt; cm_apbclk).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">div</td><td>The new value of the APB divider.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="ga60c2817b0b31bec83ce2d4245766a300"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___c_l_k.html#gaae49d94cffe9c77837af61544d1c53f7">cpu_clk_t</a> cm_cpu_clk_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the CPU clock frequency. </p>
<dl class="section return"><dt>Returns</dt><dd>The CPU clock being used.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Any restrictions of the <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaec75427c454e4476752fa28d8147b47e" title="Returns the sys_clk that the system uses at that moment. ">cm_sys_clk_get()</a> and <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga462965cf64536f7d5d6f9c72b5f3e4e9" title="Returns the AMBA High speed Bus clock divider. ">cm_ahb_get_clock_divider()</a> apply here as well. It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7b31d79dea86dfba84b3a6dbd56bd9c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___c_l_k.html#gaae49d94cffe9c77837af61544d1c53f7">cpu_clk_t</a> cm_cpu_clk_get_fromISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the CPU clock frequency (interrupt safe). </p>
<dl class="section return"><dt>Returns</dt><dd>The CPU clock being used.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It can be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="gae7a489811442df40533f748695d6494d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cm_cpu_clk_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#gaae49d94cffe9c77837af61544d1c53f7">cpu_clk_t</a>&#160;</td>
          <td class="paramname"><em>clk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the CPU clock. </p>
<p>It attempts to set the sys_clk and the AMBA High speed bus divider to achieve the CPU clock that is requested. ARM CPU runs using the AHB clock. Any restrictions of the <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga0deec6c3c8fc0f44efeefca205c99b50" title="Set the system clock. ">cm_sys_clk_set()</a>, <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga44b18ecfc74a372db8f75ba23c974126" title="Change the divider of the AMBA High speed Bus clock. ">cm_ahb_set_clock_divider()</a> and <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaa4c7649939d439045d58fec27c4b48c2" title="Change the divider of the AMBA Peripheral Bus clock. ">cm_apb_set_clock_divider()</a> apply here as well. The APB bus clock will be set to the maximum frequency. The function may return false if the requested frequency is not achievable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clk</td><td>The CPU clock frequency.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the requested clock switch was applied, else false.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Since some frequencies can be achieved with the fast RC clock (RCxxM), this function will not change to using the fast XTAL clock (XTALxxM) or the PLL, if the fast RC clock (RCxxM) is the current system clock. It is the responsibility of the caller to switch to the fast XTAL clock (XTALxxM) or the PLL before calling this function. After switching, the function will not revert to using the fast RC clock (RCxxM) at any case. Thus, switching from/to the fast RC clock (RCxxM) may be considered as "manual" while the switching from/to any other system clock source is done automatically from this function. The setting of the clocks is done via calls to <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga0deec6c3c8fc0f44efeefca205c99b50" title="Set the system clock. ">cm_sys_clk_set()</a>, <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga44b18ecfc74a372db8f75ba23c974126" title="Change the divider of the AMBA High speed Bus clock. ">cm_ahb_set_clock_divider()</a> and <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaa4c7649939d439045d58fec27c4b48c2" title="Change the divider of the AMBA Peripheral Bus clock. ">cm_apb_set_clock_divider()</a>. It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="ga86825b725aa19f183a4876d8a42ccbef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_cpu_clk_set_fromISR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>clk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a>&#160;</td>
          <td class="paramname"><em>hdiv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the system and the AHB bus clock (interrupt safe version). </p>
<p>It sets the sys_clk to the fast XTAL clock (XTALxxM) or PLL and the AHB divider.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clk</td><td>The clock source to use as the system clock. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hdiv</td><td>The divider of the AHB clock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>It is called with interrupts disabled. The caller must have checked that the current sys_clk is not the desired one before calling this function. </dd></dl>

</div>
</div>
<a class="anchor" id="gac76f394c9ba43cf22a747795245cf4a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_enable_xtalm </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the fast XTAL clock (XTALxxM) </p>
<p>Checks if the fast XTAL clock (XTALxxM) is started. If not, it checks if there is a PDC entry for starting the fast XTAL clock (XTALxxM). If there is, it uses PDC to start the fast XTAL clock (XTALxxM). Otherwise, it enables the fast XTAL clock (XTALxxM) using <a class="el" href="group___h_w___c_l_k.html#ga2fc015f080bb3c75682d74591b2611ee" title="Activate a System clock. ">hw_clk_enable_sysclk()</a>. </p>

</div>
</div>
<a class="anchor" id="gaa2c42a055775f448744cc922390378e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void cm_halt_until_pll_locked </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Halt until PLL is locked. </p>
<p>It executes a WFI() call waiting for the PLL_LOCK_IRQn. </p>

</div>
</div>
<a class="anchor" id="ga9267369c5ae554ee6b3a85db8dd4166b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void cm_halt_until_sysclk_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Halt until system clock (either PLL or XTAL32M) is ready. </p>
<p>It executes a WFI() call waiting for the XTALxxM Ready interrupt and PLL LOCK interrupt if needed. </p>

</div>
</div>
<a class="anchor" id="gac523437b2bdff9ee4ca005d3f66e372d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void cm_halt_until_xtalm_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Halt until the fast XTAL clock (XTALxxM) has settled. </p>
<p>It executes a WFI() call waiting for the fast XTAL clock (XTALxxM) Ready interrupt. Any other interrupts that hit are served. </p>

</div>
</div>
<a class="anchor" id="ga9857796532a9d4e64156b009bd82fee2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_lp_clk_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the Low Power clock. </p>
<p>It initializes and sets as LP clock either the RCX or the XTAL32K. Since the XTAL32K settling takes a long time, the system is kept in active mode until this completes. </p>

</div>
</div>
<a class="anchor" id="ga1441219191476e451ba6fbc41bb9e103"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cm_lp_clk_is_avail </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the Low Power clock is available. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the LP clock is available, else false.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It does not block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8326d96c90e17710e709c0de96fc5e76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cm_lp_clk_is_avail_fromISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the Low Power clock is available, interrupt safe version. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the LP clock is available, else false.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It does not block. It can be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="ga934fb28da416965225259e4964276456"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void cm_lp_clk_wakeup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the flag that indicates that the Low Power clock is available. </p>
<p>It is called when the system wakes up from a "forced" deep sleep state and the XTAL32K is used as the LP clock so that the system won't enter into sleep until the crystal has settled.</p>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="gaed5356a34ab5e81acb542f55a0284b5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool cm_poll_xtalm_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the fast XTAL clock (XTALxxM) is ready. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the fast XTAL clock (XTALxxM) has settled, else false. </dd></dl>

</div>
</div>
<a class="anchor" id="gae884fa4c86df75b1cb87f591b9417e2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint32_t cm_rcx_us_2_lpcycles </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>usec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts usec to RCX cycles. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of RCX cycles for the given time period.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Maximum time period is 4.095msec. </dd></dl>

</div>
</div>
<a class="anchor" id="ga64bbd9cd49b18ce46a71fa41ae287587"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t cm_rcx_us_2_lpcycles_low_acc </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>usec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts time to RCX cycles. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of RCX cycles for the given time period.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is a low accuracy function. To have good accuracy, the minimum time period should be 1msec and the maximum 200msec. Above 200msec, the function calculates more RCX cycles than necessary. </dd></dl>

</div>
</div>
<a class="anchor" id="gab56ed15acc5f7574a4ef86dea5840326"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_register_xtal_ready_callback </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a callback function to be called then XTAL32M is ready. </p>
<p>cb pointer to the callback function </p>

</div>
</div>
<a class="anchor" id="gaec75427c454e4476752fa28d8147b47e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> cm_sys_clk_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the sys_clk that the system uses at that moment. </p>
<dl class="section return"><dt>Returns</dt><dd>The real sys_clk used by the system.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="gae7c573992fb1d59dd642ee3ef12177ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> cm_sys_clk_get_fromISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the sys_clk that the system uses at that moment (interrupt safe version). </p>
<dl class="section return"><dt>Returns</dt><dd>The real sys_clk used by the system. </dd></dl>

</div>
</div>
<a class="anchor" id="gad4e7df8e63e272869fcc340ece7b4d79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_sys_clk_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize clocks after power-up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The clock source to use as the system clock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>It must be called with interrupts enabled! It must be called only once, after power-up. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0deec6c3c8fc0f44efeefca205c99b50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cm_sys_clk_set_status_t cm_sys_clk_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the system clock. </p>
<p>It attempts to set the system clock to one of the available options. If the request involves turning on the fast XTAL clock (XTALxxM), then the task will block and the XTALxxM will be powered on. The task will resume execution when the fast XTAL clock (XTALxxM) settles. The CM will restore the clock to the type set by this function after each wake-up, automatically, whenever the fast XTAL clock (XTALxxM) settles.</p>
<p>PLL will be used as system clock when at least one task has requested it by setting type to sysclk_PLL96. System clock will remain to PLL until all tasks that requested PLL have called <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga0deec6c3c8fc0f44efeefca205c99b50" title="Set the system clock. ">cm_sys_clk_set()</a> with type other than sysclk_PLL96. In the meantime, if a task requests sysclk_XTAL32M or sysclk_RC32 it will get a return value of cm_sysclk_pll_used_by_task. The system clock will remain to sysclk_PLL96. It will be changed to sysclk_XTAL32M or sysclk_RC32 when the last task using the PLL requests to do so.</p>
<p>Note: if the SysTick runs then it is the dg_configABORT_IF_SYSTICK_CLK_ERR setting that controls whether the switch will be aborted or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The clock source to use as the system clock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cm_sysclk_success if the requested clock switch was applied cm_sysclk_din1_clk_in_use if system clock cannot be switched because a peripheral is clocked by DIV1 clock cm_sysclk_ahb_divider_in_use if system clock cannot be switched to PLL because the AHB divider is not ahb_div1 cm_sysclk_pll_used_by_task if another task is using the PLL. In this case the system clock will be switched to XTALxxM when the last task using the PLL calls <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga0deec6c3c8fc0f44efeefca205c99b50" title="Set the system clock. ">cm_sys_clk_set()</a> with clock type sysclk_XTAL32M or sysclk_RC32</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="gafe2850f410d98cf04468a7e86c4464f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void cm_sys_clk_sleep </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>entering_sleep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the system clock (unprotected). </p>
<p>It attempts to:</p><ul>
<li>Prepare the system clock for sleep : called when the system is entering power-down mode. The system clock settings of the application are kept in order to be able to restore them. If the PLL is active it will be turned off. (It is called with the scheduler stopped and all interrupts disabled in this case.)</li>
<li>Restore the previous setting : called when the fast XTAL clock (XTALxxM) settles. (It is called from ISR context with all interrupts disabled in this case.)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entering_sleep</td><td>true if the system is going to sleep, else false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>It must be called from Interrupt Context and/or with all interrupts disabled. The function is internal to the clock and power managers and should not be used externally! </dd></dl>

</div>
</div>
<a class="anchor" id="ga6dcfa191a663cbc9e2998e79cbc7b68e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_wait_lp_clk_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until the Low Power clock is available. </p>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="ga95526e50703ab838153d26e353f36c4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_wait_pll_lock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block until the PLL is locked. If the PLL is locked then the function exits immediately. </p>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="ga73baf5e403b2eb3f68f01a2d53d06260"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_wait_xtalm_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block until the fast XTAL clock (XTALxxM) is ready. If the fast XTAL clock (XTALxxM) is running then the function exits immediately. </p>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jul 7 2020 07:10:52 for SmartSnippets DA1469x SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>SmartSnippets DA1469x SDK: I2C Adapter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1469x SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Board&#160;and&#160;Applications&#160;General&#160;Info</span></a></li>
      <li><a href="modules.html"><span>SDK&#160;Architecture</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2C Adapter<div class="ingroups"><a class="el" href="group___m_i_d_d_l_e_w_a_r_e.html">Middleware</a> &raquo; <a class="el" href="group___m_i_d___s_y_s_t_e_m.html">System</a> &raquo; <a class="el" href="group___m_i_d___s_y_s___a_d_a_p_t_e_r_s.html">System Adapters</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Inter Integrated Circuit adapter.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:ad__i2c_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ad__i2c_8h.html">ad_i2c.h</a></td></tr>
<tr class="memdesc:ad__i2c_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C device access API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structad__i2c__io__conf__t.html">ad_i2c_io_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C I/O configuration.  <a href="structad__i2c__io__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structad__i2c__driver__conf__t.html">ad_i2c_driver_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C driver configuration.  <a href="structad__i2c__driver__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structad__i2c__controller__conf__t.html">ad_i2c_controller_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C controller configuration.  <a href="structad__i2c__controller__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi2c__dev__slave__event__callbacks__t.html">i2c_dev_slave_event_callbacks_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slave event callbacks.  <a href="structi2c__dev__slave__event__callbacks__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga9e541094b59475b0e27b71ad11cc9c7d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga9e541094b59475b0e27b71ad11cc9c7d">CONFIG_I2C_ENABLE_CRITICAL_SECTION</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga9e541094b59475b0e27b71ad11cc9c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable critical sections within some I2C adapter functions.  <a href="#ga9e541094b59475b0e27b71ad11cc9c7d">More...</a><br /></td></tr>
<tr class="separator:ga9e541094b59475b0e27b71ad11cc9c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ea113649ff626de4173a4ba95541b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gae1ea113649ff626de4173a4ba95541b7">CONFIG_I2C_USE_ASYNC_TRANSACTIONS</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:gae1ea113649ff626de4173a4ba95541b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls whether I2C asynchronous transaction API will be used.  <a href="#gae1ea113649ff626de4173a4ba95541b7">More...</a><br /></td></tr>
<tr class="separator:gae1ea113649ff626de4173a4ba95541b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gafd97fc778be31559d1c682d3ad00e045"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafd97fc778be31559d1c682d3ad00e045"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a></td></tr>
<tr class="memdesc:gafd97fc778be31559d1c682d3ad00e045"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Handle returned by <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> <br /></td></tr>
<tr class="separator:gafd97fc778be31559d1c682d3ad00e045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b665bf082202d3e106611b9fa0e260"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab9b665bf082202d3e106611b9fa0e260"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab9b665bf082202d3e106611b9fa0e260">ad_i2c_user_cb</a>) (void *user_data, <a class="el" href="group___h_w___i2_c.html#gaf7ef8a80c9c6e53c3edf28cc5bf2007e">HW_I2C_ABORT_SOURCE</a> error)</td></tr>
<tr class="memdesc:gab9b665bf082202d3e106611b9fa0e260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous callback function. <br /></td></tr>
<tr class="separator:gab9b665bf082202d3e106611b9fa0e260"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2d28fe9a89c02b4815c5d5f5c9ce24b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2d28fe9a89c02b4815c5d5f5c9ce24b7"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga2d28fe9a89c02b4815c5d5f5c9ce24b7">AD_I2C_ERROR</a> </td></tr>
<tr class="memdesc:ga2d28fe9a89c02b4815c5d5f5c9ce24b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C adapter error codes. <br /></td></tr>
<tr class="separator:ga2d28fe9a89c02b4815c5d5f5c9ce24b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1af8a888eeb7893994ff10bdd900055"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac1af8a888eeb7893994ff10bdd900055">AD_I2C_SLAVE_STATE</a> { <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ggac1af8a888eeb7893994ff10bdd900055a2e0595e500ca11cbdf5f9e7e15b32dfe">AD_I2C_SLAVE_STATE_STOPPED</a> = 0, 
<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ggac1af8a888eeb7893994ff10bdd900055a5e17ab5541f692eb95da27bc8c912b51">AD_I2C_SLAVE_STATE_INIT</a> = 0x1, 
<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ggac1af8a888eeb7893994ff10bdd900055a98dd6508b2e9e65e2cf69f63c9e8c4d3">AD_I2C_SLAVE_STATE_READ_PENDING</a> = 0x2, 
<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ggac1af8a888eeb7893994ff10bdd900055a727d46eb6a915303f05ca923a1b07161">AD_I2C_SLAVE_STATE_WRITE_PENDING</a> = 0x4
 }</td></tr>
<tr class="memdesc:gac1af8a888eeb7893994ff10bdd900055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slave state bits.  <a href="group___i2_c___a_d_a_p_t_e_r.html#gac1af8a888eeb7893994ff10bdd900055">More...</a><br /></td></tr>
<tr class="separator:gac1af8a888eeb7893994ff10bdd900055"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1b3105a748890da0dec74c504185819a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1b3105a748890da0dec74c504185819a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga1b3105a748890da0dec74c504185819a">ad_i2c_init</a> (void)</td></tr>
<tr class="memdesc:ga1b3105a748890da0dec74c504185819a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize adapter. <br /></td></tr>
<tr class="separator:ga1b3105a748890da0dec74c504185819a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabef785c2b17e762efd103e2ae6630403"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403">ad_i2c_open</a> (const <a class="el" href="structad__i2c__controller__conf__t.html">ad_i2c_controller_conf_t</a> *conf)</td></tr>
<tr class="memdesc:gabef785c2b17e762efd103e2ae6630403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open I2C controller.  <a href="#gabef785c2b17e762efd103e2ae6630403">More...</a><br /></td></tr>
<tr class="separator:gabef785c2b17e762efd103e2ae6630403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa0659b852cb6030cf508b9efc61c95d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafa0659b852cb6030cf508b9efc61c95d">ad_i2c_reconfig</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p, const <a class="el" href="structad__i2c__driver__conf__t.html">ad_i2c_driver_conf_t</a> *conf)</td></tr>
<tr class="memdesc:gafa0659b852cb6030cf508b9efc61c95d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconfigure I2C controller.  <a href="#gafa0659b852cb6030cf508b9efc61c95d">More...</a><br /></td></tr>
<tr class="separator:gafa0659b852cb6030cf508b9efc61c95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d3cd1892d3a7ed78d4b6702b416f101"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga1d3cd1892d3a7ed78d4b6702b416f101">ad_i2c_close</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p, bool force)</td></tr>
<tr class="memdesc:ga1d3cd1892d3a7ed78d4b6702b416f101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close I2C controller.  <a href="#ga1d3cd1892d3a7ed78d4b6702b416f101">More...</a><br /></td></tr>
<tr class="separator:ga1d3cd1892d3a7ed78d4b6702b416f101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga504b1b0c337c3bea6be314361478c6c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga504b1b0c337c3bea6be314361478c6c2">ad_i2c_io_config</a> (HW_I2C_ID id, const <a class="el" href="structad__i2c__io__conf__t.html">ad_i2c_io_conf_t</a> *io_config, <a class="el" href="group___a_d_a_p_t_e_r.html#ga37f7ad66c2edac01fa114cd43d15d428">AD_IO_CONF_STATE</a> state)</td></tr>
<tr class="memdesc:ga504b1b0c337c3bea6be314361478c6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize controller pins to on / off io configuration.  <a href="#ga504b1b0c337c3bea6be314361478c6c2">More...</a><br /></td></tr>
<tr class="separator:ga504b1b0c337c3bea6be314361478c6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d29ecd47d69bbf4d535950dc9a3ddf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga25d29ecd47d69bbf4d535950dc9a3ddf">ad_i2c_write</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p, const uint8_t *wbuf, size_t wlen, uint8_t condition_flags)</td></tr>
<tr class="memdesc:ga25d29ecd47d69bbf4d535950dc9a3ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a blocking write transaction.  <a href="#ga25d29ecd47d69bbf4d535950dc9a3ddf">More...</a><br /></td></tr>
<tr class="separator:ga25d29ecd47d69bbf4d535950dc9a3ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a9cadc282a01e3dbf0122596bd62c62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga3a9cadc282a01e3dbf0122596bd62c62">ad_i2c_read</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p, uint8_t *rbuf, size_t rlen, uint8_t condition_flags)</td></tr>
<tr class="memdesc:ga3a9cadc282a01e3dbf0122596bd62c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a blocking read transaction.  <a href="#ga3a9cadc282a01e3dbf0122596bd62c62">More...</a><br /></td></tr>
<tr class="separator:ga3a9cadc282a01e3dbf0122596bd62c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e732a37377b2f95dc9d0961d383af2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga5e732a37377b2f95dc9d0961d383af2a">ad_i2c_write_read</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p, const uint8_t *wbuf, size_t wlen, uint8_t *rbuf, size_t rlen, uint8_t condition_flags)</td></tr>
<tr class="memdesc:ga5e732a37377b2f95dc9d0961d383af2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform synchronous write/read transaction.  <a href="#ga5e732a37377b2f95dc9d0961d383af2a">More...</a><br /></td></tr>
<tr class="separator:ga5e732a37377b2f95dc9d0961d383af2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4b2a9949b0c2d41722f3ad814be35c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab4b2a9949b0c2d41722f3ad814be35c5">ad_i2c_wait_while_master_busy</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p)</td></tr>
<tr class="memdesc:gab4b2a9949b0c2d41722f3ad814be35c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait while I2C master device is busy.  <a href="#gab4b2a9949b0c2d41722f3ad814be35c5">More...</a><br /></td></tr>
<tr class="separator:gab4b2a9949b0c2d41722f3ad814be35c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedad123674a8383d3f7a0e7a27d6893c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gaedad123674a8383d3f7a0e7a27d6893c">ad_i2c_write_async</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p, const uint8_t *wbuf, size_t wlen, <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab9b665bf082202d3e106611b9fa0e260">ad_i2c_user_cb</a> cb, void *user_data, uint8_t condition_flags)</td></tr>
<tr class="memdesc:gaedad123674a8383d3f7a0e7a27d6893c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a non blocking write transaction.  <a href="#gaedad123674a8383d3f7a0e7a27d6893c">More...</a><br /></td></tr>
<tr class="separator:gaedad123674a8383d3f7a0e7a27d6893c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga054ec1413ed354953cb8c4862be210be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga054ec1413ed354953cb8c4862be210be">ad_i2c_read_async</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p, uint8_t *rbuf, size_t rlen, <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab9b665bf082202d3e106611b9fa0e260">ad_i2c_user_cb</a> cb, void *user_data, uint8_t condition_flags)</td></tr>
<tr class="memdesc:ga054ec1413ed354953cb8c4862be210be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a non blocking read transaction.  <a href="#ga054ec1413ed354953cb8c4862be210be">More...</a><br /></td></tr>
<tr class="separator:ga054ec1413ed354953cb8c4862be210be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ac69454b40f7ac974708077c3468dd3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga7ac69454b40f7ac974708077c3468dd3">ad_i2c_write_read_async</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p, const uint8_t *wbuf, size_t wlen, uint8_t *rbuf, size_t rlen, <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab9b665bf082202d3e106611b9fa0e260">ad_i2c_user_cb</a> cb, void *user_data, uint8_t condition_flags)</td></tr>
<tr class="memdesc:ga7ac69454b40f7ac974708077c3468dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform write and asynchronous read I2C transaction.  <a href="#ga7ac69454b40f7ac974708077c3468dd3">More...</a><br /></td></tr>
<tr class="separator:ga7ac69454b40f7ac974708077c3468dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34d7dd37cc71a21737ae34cea7ff3248"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga34d7dd37cc71a21737ae34cea7ff3248">ad_i2c_start_slave</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p, const uint8_t *wbuf, uint16_t wlen, uint8_t *rbuf, uint16_t rlen, const <a class="el" href="structi2c__dev__slave__event__callbacks__t.html">i2c_dev_slave_event_callbacks_t</a> *events, void *user_data)</td></tr>
<tr class="memdesc:ga34d7dd37cc71a21737ae34cea7ff3248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start slave transmission/reception.  <a href="#ga34d7dd37cc71a21737ae34cea7ff3248">More...</a><br /></td></tr>
<tr class="separator:ga34d7dd37cc71a21737ae34cea7ff3248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca75752a74b96d18bfe2d67d6dd54065"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gaca75752a74b96d18bfe2d67d6dd54065">ad_i2c_stop_slave</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p)</td></tr>
<tr class="memdesc:gaca75752a74b96d18bfe2d67d6dd54065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop slave response.  <a href="#gaca75752a74b96d18bfe2d67d6dd54065">More...</a><br /></td></tr>
<tr class="separator:gaca75752a74b96d18bfe2d67d6dd54065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2af75a25db182b3ef9b9386b3a372f1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga2af75a25db182b3ef9b9386b3a372f1e">ad_i2c_clear_read_slave</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> p)</td></tr>
<tr class="memdesc:ga2af75a25db182b3ef9b9386b3a372f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear I2C slave read buffer.  <a href="#ga2af75a25db182b3ef9b9386b3a372f1e">More...</a><br /></td></tr>
<tr class="separator:ga2af75a25db182b3ef9b9386b3a372f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Inter Integrated Circuit adapter. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga9e541094b59475b0e27b71ad11cc9c7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_I2C_ENABLE_CRITICAL_SECTION&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable critical sections within some I2C adapter functions. </p>
<p>Some I2C peripherals do not respond well to a write-read transaction if a STOP condition occurs after the write operation. By setting this macro to 1, ad_i2c_transact() will execute the write and the setup of read within a critical section, thus ensuring that no STOP condition will occur after write due to I2C FIFO underflow. </p>

</div>
</div>
<a class="anchor" id="gae1ea113649ff626de4173a4ba95541b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_I2C_USE_ASYNC_TRANSACTIONS&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls whether I2C asynchronous transaction API will be used. </p>
<p>I2C asynchronous transaction API (see "ad_i2c_async_*" API) maintains state in retention RAM for every I2C bus declared. If the API is not to be used, setting this macro to 0 will save retention RAM. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gac1af8a888eeb7893994ff10bdd900055"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac1af8a888eeb7893994ff10bdd900055">AD_I2C_SLAVE_STATE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slave state bits. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggac1af8a888eeb7893994ff10bdd900055a2e0595e500ca11cbdf5f9e7e15b32dfe"></a>AD_I2C_SLAVE_STATE_STOPPED&#160;</td><td class="fielddoc">
<p>Slave stopped or uninitialized. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggac1af8a888eeb7893994ff10bdd900055a5e17ab5541f692eb95da27bc8c912b51"></a>AD_I2C_SLAVE_STATE_INIT&#160;</td><td class="fielddoc">
<p>Initial state. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggac1af8a888eeb7893994ff10bdd900055a98dd6508b2e9e65e2cf69f63c9e8c4d3"></a>AD_I2C_SLAVE_STATE_READ_PENDING&#160;</td><td class="fielddoc">
<p>Slave read pending. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggac1af8a888eeb7893994ff10bdd900055a727d46eb6a915303f05ca923a1b07161"></a>AD_I2C_SLAVE_STATE_WRITE_PENDING&#160;</td><td class="fielddoc">
<p>Slave write pending. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga2af75a25db182b3ef9b9386b3a372f1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_i2c_clear_read_slave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear I2C slave read buffer. </p>
<p>This function will flush the I2C receive buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>handle returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1d3cd1892d3a7ed78d4b6702b416f101"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close I2C controller. </p>
<p>This function:</p><ul>
<li>Aborts ongoing transactions</li>
<li>De-initializes the drivers associated with the controller</li>
<li>Resets controller interface IOs (as specified in <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a>)</li>
<li>Releases the controller resources</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>handle returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">force</td><td>force close even if contoller is occupied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0: success, &lt;0: error code</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga504b1b0c337c3bea6be314361478c6c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_io_config </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structad__i2c__io__conf__t.html">ad_i2c_io_conf_t</a> *&#160;</td>
          <td class="paramname"><em>io_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_a_p_t_e_r.html#ga37f7ad66c2edac01fa114cd43d15d428">AD_IO_CONF_STATE</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize controller pins to on / off io configuration. </p>
<p>This function should be called for setting pins to the correct level before external devices are powered up (e.g on system init). It does not need to be called before every <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io_config</td><td>controller io configuration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>on/off io configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0: success, &lt;0: error code </dd></dl>

</div>
</div>
<a class="anchor" id="gabef785c2b17e762efd103e2ae6630403"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> ad_i2c_open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structad__i2c__controller__conf__t.html">ad_i2c_controller_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open I2C controller. </p>
<p>This function:</p><ul>
<li>Acquires the resources needed for using the controller</li>
<li>Configures the controller interface IOs</li>
<li>Initializes the drivers associated with the controller</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>controller configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;0: non-NULL handle that should be used in subsequent API calls, NULL: error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function will block until it acquires all controller resources </dd></dl>

</div>
</div>
<a class="anchor" id="ga3a9cadc282a01e3dbf0122596bd62c62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>condition_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a blocking read transaction. </p>
<p>This function performs a synchronous read only transaction</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>handle returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>buffer for incoming data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>number of bytes to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">condition_flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br />
 No STOP or RESTART conditions will be generated at the end of the transaction. DA14680/1 will automatically generate a STOP condition when the last byte in the transmit buffer has been transmitted.</p>
<p><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, value from HW_I2C_ABORT_SOURCE enum on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga054ec1413ed354953cb8c4862be210be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_read_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab9b665bf082202d3e106611b9fa0e260">ad_i2c_user_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>condition_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a non blocking read transaction. </p>
<p>This function performs an asynchronous read only transaction Caller task should retry until function returns no error Callback will be called when transaction is completed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>handle returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>buffer for incoming data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>number of bytes to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback to call after transaction is over (from ISR context) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>user data passed to cb callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">condition_flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br />
 No STOP or RESTART conditions will be generated at the end of the transaction. DA14680/1 will automatically generate a STOP condition when the last byte in the transmit buffer has been transmitted.</p>
<p><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0: error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafa0659b852cb6030cf508b9efc61c95d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_reconfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structad__i2c__driver__conf__t.html">ad_i2c_driver_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconfigure I2C controller. </p>
<p>This function will apply a new I2C driver configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>handle returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>pointer to driver configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0: success, &lt;0: error code</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga34d7dd37cc71a21737ae34cea7ff3248"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_start_slave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structi2c__dev__slave__event__callbacks__t.html">i2c_dev_slave_event_callbacks_t</a> *&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start slave transmission/reception. </p>
<p>When I2C is configured in slave mode, this function sets up input and/or output buffers to use for master initiated transmission and/or reception. It also specifies user callbacks that will be called when transmission or reception starts or finishes.</p>
<p>If the user specifies valid (wbuf, wlen) pair, data will be sent on incoming read request from master. After reception, data_sent() callback will be called. If wbuf is NULL or wlen is 0, read_request() callback will be called to notify the user about master read request.</p>
<p>If (rbuf, rlen) pair is specified, data will be received when master starts writing. When data is received, callback data_received() will be called. If rbuf is NULL or rlen is 0, data_ready() callback will be called to notify user about master write. If the user fails to read from the Rx FIFO before it becomes full then data loss may occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>handle returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>buffer for outgoing data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>number of bytes to write in case master wants to read </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>buffer for incoming data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>number of bytes to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">events</td><td>structure with callback to call after transaction is over (from ISR context), if NULL, no callbacks will be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>user data to pass to each callback in events</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0: error</dd></dl>
<p>Example usage: </p><div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a> handle = <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403">ad_i2c_open</a>(conf);</div>
<div class="line">  <span class="keywordflow">while</span> (1) {</div>
<div class="line">    uint8_t cmd[4];</div>
<div class="line">    uint8_t response[6];</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#ga34d7dd37cc71a21737ae34cea7ff3248">ad_i2c_start_slave</a>(dev, NULL, 0, cmd, <span class="keyword">sizeof</span>(cmd), slave_callbacks, NULL);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// wait while callbacks handle write request</span></div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// prepare response in out buffer</span></div>
<div class="line">    <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#ga34d7dd37cc71a21737ae34cea7ff3248">ad_i2c_start_slave</a>(dev, response, <span class="keyword">sizeof</span>(response), NULL, 0, slave_callbacks, NULL);</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// wait for master to read response</span></div>
<div class="line">    ...</div>
<div class="line">    <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#gaca75752a74b96d18bfe2d67d6dd54065">ad_i2c_stop_slave</a>(dev);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>All callbacks are called from within I2C ISR</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaca75752a74b96d18bfe2d67d6dd54065"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_stop_slave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop slave response. </p>
<p>This function will make a slave device stop responding to external master requests for read or write operations. If such an operation is ongoing, the function will wait for its completion before returning. The bus and device are released by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>handle returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0: error</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function should only be called only if <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga34d7dd37cc71a21737ae34cea7ff3248" title="Start slave transmission/reception. ">ad_i2c_start_slave()</a> has been already used for starting the slave operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> </dd>
<dd>
<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga34d7dd37cc71a21737ae34cea7ff3248" title="Start slave transmission/reception. ">ad_i2c_start_slave()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab4b2a9949b0c2d41722f3ad814be35c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_i2c_wait_while_master_busy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait while I2C master device is busy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>pointer returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga25d29ecd47d69bbf4d535950dc9a3ddf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>condition_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a blocking write transaction. </p>
<p>This function performs a synchronous write only transaction</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>handle returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>buffer containing the data to be sent to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>size of data to be sent to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">condition_flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br />
 No STOP or RESTART conditions will be generated at the end of the transaction. DA14680/1 will automatically generate a STOP condition when the last byte in the transmit buffer has been transmitted.</p>
<p><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, value from HW_I2C_ABORT_SOURCE enum on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaedad123674a8383d3f7a0e7a27d6893c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_write_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab9b665bf082202d3e106611b9fa0e260">ad_i2c_user_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>condition_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a non blocking write transaction. </p>
<p>This function performs an asynchronous write only transaction Caller task should retry until function returns no error Callback will be called when transaction is completed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>handle returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>buffer containing the data to be sent to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>size of data to be sent to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback to call after transaction is over (from ISR context) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>user data passed to cb callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">condition_flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br />
 No STOP or RESTART conditions will be generated at the end of the transaction. DA14680/1 will automatically generate a STOP condition when the last byte in the transmit buffer has been transmitted.</p>
<p><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0: error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5e732a37377b2f95dc9d0961d383af2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_write_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>condition_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform synchronous write/read transaction. </p>
<p>This function performs a synchronous write and read transaction on I2C bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>handle returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>buffer containing the data to be sent to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>size of data to be sent to the device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>buffer to store the data read from the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>size of buffer pointed by rbuf </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">condition_flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br />
 No STOP or RESTART conditions will be generated at the end of the transaction. DA14680/1 will automatically generate a STOP condition when the last byte in the transmit buffer has been transmitted.</p>
<p><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, value from HW_I2C_ABORT_SOURCE enum on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7ac69454b40f7ac974708077c3468dd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_write_read_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafd97fc778be31559d1c682d3ad00e045">ad_i2c_handle_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab9b665bf082202d3e106611b9fa0e260">ad_i2c_user_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>condition_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform write and asynchronous read I2C transaction. </p>
<p>This function performs asynchronous write and read transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>handle returned from <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>data to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>number of bytes to write </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>buffer to store the data read from the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>size of buffer pointed by rbuf </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback to call after transaction is over (from ISR context) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>user data to pass to <code>cb</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">condition_flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br />
 No STOP or RESTART conditions will be generated at the end of the transaction. DA14680/1 will automatically generate a STOP condition when the last byte in the transmit buffer has been transmitted.</p>
<p><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0: error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabef785c2b17e762efd103e2ae6630403" title="Open I2C controller. ">ad_i2c_open()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jul 7 2020 07:10:52 for SmartSnippets DA1469x SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>

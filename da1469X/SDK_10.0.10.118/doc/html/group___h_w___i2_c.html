<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>SmartSnippets DA1469x SDK: I2C Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1469x SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Board&#160;and&#160;Applications&#160;General&#160;Info</span></a></li>
      <li><a href="modules.html"><span>SDK&#160;Architecture</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2C Driver<div class="ingroups"><a class="el" href="group___p_l_a_t_f_o_r_m___d_e_v_i_c_e.html">Platform/Device</a> &raquo; <a class="el" href="group___p_l_a___d_r_i_v_e_r_s.html">Drivers</a> &raquo; <a class="el" href="group___p_l_a___d_r_i___p_e_r_p_h_e_r_a_l_s.html">Peripheral LLD's</a> &raquo; <a class="el" href="group___p_l_a___d_r_i___p_e_r___c_o_m_m.html">Comm Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>I2C Controller.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:hw__i2c_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__i2c_8h.html">hw_i2c.h</a></td></tr>
<tr class="memdesc:hw__i2c_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of API for the I2C Low Level Driver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi2c__config.html">i2c_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C configuration.  <a href="structi2c__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gab2c8ab2a4f1438202f08aa4e60ef0914"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab2c8ab2a4f1438202f08aa4e60ef0914"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gab2c8ab2a4f1438202f08aa4e60ef0914">I2C_FIFO_DEPTH</a>&#160;&#160;&#160;(4)</td></tr>
<tr class="memdesc:gab2c8ab2a4f1438202f08aa4e60ef0914"><td class="mdescLeft">&#160;</td><td class="mdescRight">TX/RX FIFO depth. <br /></td></tr>
<tr class="separator:gab2c8ab2a4f1438202f08aa4e60ef0914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdc0311455ca8686015d5c0a7751c9d1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gacdc0311455ca8686015d5c0a7751c9d1">I2C_SETUP</a>(id,  seq)</td></tr>
<tr class="memdesc:gacdc0311455ca8686015d5c0a7751c9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to perform controller setup.  <a href="#gacdc0311455ca8686015d5c0a7751c9d1">More...</a><br /></td></tr>
<tr class="separator:gacdc0311455ca8686015d5c0a7751c9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb92f2c77d6f2cc99cc1943783d174d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabb92f2c77d6f2cc99cc1943783d174d2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gabb92f2c77d6f2cc99cc1943783d174d2">HW_I2C1</a>&#160;&#160;&#160;((void *)I2C_BASE)</td></tr>
<tr class="memdesc:gabb92f2c77d6f2cc99cc1943783d174d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C controller instance. <br /></td></tr>
<tr class="separator:gabb92f2c77d6f2cc99cc1943783d174d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaf101cb30b8b19337faa1130b230b79"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="separator:gadaf101cb30b8b19337faa1130b230b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga561070559a39fe8aa62f839207c5e5b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga561070559a39fe8aa62f839207c5e5b7">HW_I2C_F_WAIT_FOR_STOP</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:ga561070559a39fe8aa62f839207c5e5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeccd5262bded02079206c0fed157b02e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="separator:gaeccd5262bded02079206c0fed157b02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf600a3324a7a01bce204dc8946cd9731"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="separator:gaf600a3324a7a01bce204dc8946cd9731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff98913fa3822f7d43795744a2ed6027"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaff98913fa3822f7d43795744a2ed6027"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gaff98913fa3822f7d43795744a2ed6027">HW_I2C_I2C1_MADDR</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:gaff98913fa3822f7d43795744a2ed6027"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C high speed master code. This bit field holds the value of the I2C HS mode master code. HS-mode master codes are reserved 8-bit codes (00001xxx) that are not used for slave addressing or other purposes. Each master has its unique master code. Up to eight high-speed mode masters can be present on the same I2C bus system. Valid values are from 0 to 7. This can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. <br /></td></tr>
<tr class="separator:gaff98913fa3822f7d43795744a2ed6027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0805a21fb0272d1ba210f1b8406d9d6b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga0805a21fb0272d1ba210f1b8406d9d6b">HW_I2C_REG_SETF</a>(id,  reg,  field,  val)</td></tr>
<tr class="memdesc:ga0805a21fb0272d1ba210f1b8406d9d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to an I2C register field.  <a href="#ga0805a21fb0272d1ba210f1b8406d9d6b">More...</a><br /></td></tr>
<tr class="separator:ga0805a21fb0272d1ba210f1b8406d9d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf98ed2c050989a781b95443ca34ac61"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gacf98ed2c050989a781b95443ca34ac61">HW_I2C_REG_GETF</a>(id,  reg,  field)&#160;&#160;&#160;((IBA(id)-&gt;reg##_REG &amp; (I2C_##reg##_REG_##field##_Msk)) &gt;&gt; (I2C_##reg##_REG_##field##_Pos))</td></tr>
<tr class="memdesc:gacf98ed2c050989a781b95443ca34ac61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of an I2C register field.  <a href="#gacf98ed2c050989a781b95443ca34ac61">More...</a><br /></td></tr>
<tr class="separator:gacf98ed2c050989a781b95443ca34ac61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga07fb0d97fcc29f7d55b1846927d7ad18"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga07fb0d97fcc29f7d55b1846927d7ad18">hw_i2c_interrupt_cb</a>) (HW_I2C_ID id, uint16_t mask)</td></tr>
<tr class="memdesc:ga07fb0d97fcc29f7d55b1846927d7ad18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback called on interrupt from I2C controller.  <a href="#ga07fb0d97fcc29f7d55b1846927d7ad18">More...</a><br /></td></tr>
<tr class="separator:ga07fb0d97fcc29f7d55b1846927d7ad18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa93c52dfb507e72c87250e55aeacd7fa"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a>) (HW_I2C_ID id, void *cb_data, uint16_t len, bool success)</td></tr>
<tr class="memdesc:gaa93c52dfb507e72c87250e55aeacd7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback called upon completion of read or write in non-blocking mode (FIFO or DMA)  <a href="#gaa93c52dfb507e72c87250e55aeacd7fa">More...</a><br /></td></tr>
<tr class="separator:gaa93c52dfb507e72c87250e55aeacd7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b531343651246138ece5034039dd912"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga1b531343651246138ece5034039dd912">hw_i2c_dma_completed_handler_cb</a>) (HW_I2C_ID id, void *cb_data, uint16_t len)</td></tr>
<tr class="memdesc:ga1b531343651246138ece5034039dd912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback called on DMA operation completed.  <a href="#ga1b531343651246138ece5034039dd912">More...</a><br /></td></tr>
<tr class="separator:ga1b531343651246138ece5034039dd912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf953d4d6f6b9465dcc65d369b4bcb2bd"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gaf953d4d6f6b9465dcc65d369b4bcb2bd">hw_i2c_event_cb</a>) (HW_I2C_ID id, <a class="el" href="group___h_w___i2_c.html#ga67f970897e2e55be317fcae7f01bdf1f">HW_I2C_EVENT</a> event)</td></tr>
<tr class="memdesc:gaf953d4d6f6b9465dcc65d369b4bcb2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback called on event when in slave mode.  <a href="#gaf953d4d6f6b9465dcc65d369b4bcb2bd">More...</a><br /></td></tr>
<tr class="separator:gaf953d4d6f6b9465dcc65d369b4bcb2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaf7ef8a80c9c6e53c3edf28cc5bf2007e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gaf7ef8a80c9c6e53c3edf28cc5bf2007e">HW_I2C_ABORT_SOURCE</a> { <br />
&#160;&#160;<a class="el" href="group___h_w___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007eae82067c1b8c3ff8ebc74186a9c0ea898">HW_I2C_ABORT_NONE</a> = 0, 
<a class="el" href="group___h_w___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007ea339c3cf6463507009210a912d59643fe">HW_I2C_ABORT_7B_ADDR_NO_ACK</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_7B_ADDR_NOACK_Msk, 
<a class="el" href="group___h_w___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007eadcf4555266b2cf92da1855d4074188a1">HW_I2C_ABORT_10B_ADDR1_NO_ACK</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_10ADDR1_NOACK_Msk, 
<a class="el" href="group___h_w___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007eaf8e8a6cca5c2eea4f3cf52908d764fc3">HW_I2C_ABORT_10B_ADDR2_NO_ACK</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_10ADDR2_NOACK_Msk, 
<br />
&#160;&#160;<a class="el" href="group___h_w___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007ea89ed5978c4fe2387710c2bb37741eeda">HW_I2C_ABORT_TX_DATA_NO_ACK</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_TXDATA_NOACK_Msk, 
<a class="el" href="group___h_w___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007eab2998a68ea7a4125b36ee1f7535c1e35">HW_I2C_ABORT_GENERAL_CALL_NO_ACK</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_GCALL_NOACK_Msk, 
<a class="el" href="group___h_w___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007eacba5b0d9fea9fef11005edcf89189979">HW_I2C_ABORT_GENERAL_CALL_READ</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_GCALL_READ_Msk, 
<a class="el" href="group___h_w___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007eaead3321ef58dce6a681f2060dd3884de">HW_I2C_ABORT_START_BYTE_ACK</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_SBYTE_ACKDET_Msk, 
<br />
&#160;&#160;<a class="el" href="group___h_w___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007ea193c3b94ff14a9ddb921b9fbfbc07983">HW_I2C_ABORT_10B_READ_NO_RESTART</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_10B_RD_NORSTRT_Msk, 
<a class="el" href="group___h_w___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007eabd08dc012bed51af07820d453f45dd2e">HW_I2C_ABORT_MASTER_DISABLED</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_MASTER_DIS_Msk, 
<a class="el" href="group___h_w___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007eaf37422d631a97547825d6b2106f20b5b">HW_I2C_ABORT_ARBITRATION_LOST</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ARB_LOST_Msk, 
<a class="el" href="group___h_w___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007eaf579d26d06ff5b00ddd0061070fbbdc2">HW_I2C_ABORT_SLAVE_FLUSH_TX_FIFO</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_SLVFLUSH_TXFIFO_Msk, 
<br />
&#160;&#160;<a class="el" href="group___h_w___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007ea1dc300a69352c4a42cd130a030ad4624">HW_I2C_ABORT_SLAVE_ARBITRATION_LOST</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_SLV_ARBLOST_Msk, 
<a class="el" href="group___h_w___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007ea1fe3909020f346dc4aba68abd07e9498">HW_I2C_ABORT_SLAVE_IN_TX</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_SLVRD_INTX_Msk, 
<a class="el" href="group___h_w___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007eada4e3b7ea6a617303cff16354cb9ead1">HW_I2C_ABORT_SW_ERROR</a>
<br />
 }</td></tr>
<tr class="memdesc:gaf7ef8a80c9c6e53c3edf28cc5bf2007e"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C abort source.  <a href="group___h_w___i2_c.html#gaf7ef8a80c9c6e53c3edf28cc5bf2007e">More...</a><br /></td></tr>
<tr class="separator:gaf7ef8a80c9c6e53c3edf28cc5bf2007e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cbcaaa7663a2cbba9418cdb5aab66d9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga4cbcaaa7663a2cbba9418cdb5aab66d9">HW_I2C_SPEED</a> { <a class="el" href="group___h_w___i2_c.html#gga4cbcaaa7663a2cbba9418cdb5aab66d9ae56e52ba2b3aaceccff7e09c8b59c93e">HW_I2C_SPEED_STANDARD</a> = 0, 
<a class="el" href="group___h_w___i2_c.html#gga4cbcaaa7663a2cbba9418cdb5aab66d9a57993addaedcd03090ab60a2b7759f36">HW_I2C_SPEED_FAST</a>, 
<a class="el" href="group___h_w___i2_c.html#gga4cbcaaa7663a2cbba9418cdb5aab66d9af762313255ddc0e41ed01391738ba1dd">HW_I2C_SPEED_HIGH</a>
 }</td></tr>
<tr class="memdesc:ga4cbcaaa7663a2cbba9418cdb5aab66d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C interface speed.  <a href="group___h_w___i2_c.html#ga4cbcaaa7663a2cbba9418cdb5aab66d9">More...</a><br /></td></tr>
<tr class="separator:ga4cbcaaa7663a2cbba9418cdb5aab66d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf7ffb060052bb9ac0c167835afcc910"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gadf7ffb060052bb9ac0c167835afcc910">HW_I2C_MODE</a> { <a class="el" href="group___h_w___i2_c.html#ggadf7ffb060052bb9ac0c167835afcc910a70929eedc6ae4fba724cc57c4ece19e6">HW_I2C_MODE_MASTER</a> = 0, 
<a class="el" href="group___h_w___i2_c.html#ggadf7ffb060052bb9ac0c167835afcc910adf9acb461b0239156a18bbe5280bf4d4">HW_I2C_MODE_SLAVE</a>
 }</td></tr>
<tr class="memdesc:gadf7ffb060052bb9ac0c167835afcc910"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C mode.  <a href="group___h_w___i2_c.html#gadf7ffb060052bb9ac0c167835afcc910">More...</a><br /></td></tr>
<tr class="separator:gadf7ffb060052bb9ac0c167835afcc910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c4b473a8fcb034aaabd8d2c7cf9c6bd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga8c4b473a8fcb034aaabd8d2c7cf9c6bd">HW_I2C_ADDRESSING</a> { <a class="el" href="group___h_w___i2_c.html#gga8c4b473a8fcb034aaabd8d2c7cf9c6bdae223953fbec142796f36014e08490afb">HW_I2C_ADDRESSING_7B</a> = 0, 
<a class="el" href="group___h_w___i2_c.html#gga8c4b473a8fcb034aaabd8d2c7cf9c6bdab40023bfb7104ee30683a2377246892e">HW_I2C_ADDRESSING_10B</a>
 }</td></tr>
<tr class="memdesc:ga8c4b473a8fcb034aaabd8d2c7cf9c6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C addressing mode.  <a href="group___h_w___i2_c.html#ga8c4b473a8fcb034aaabd8d2c7cf9c6bd">More...</a><br /></td></tr>
<tr class="separator:ga8c4b473a8fcb034aaabd8d2c7cf9c6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67f970897e2e55be317fcae7f01bdf1f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga67f970897e2e55be317fcae7f01bdf1f">HW_I2C_EVENT</a> { <br />
&#160;&#160;<a class="el" href="group___h_w___i2_c.html#gga67f970897e2e55be317fcae7f01bdf1fac5b1bfd3ab06735b76bbdd7e731afacb">HW_I2C_EVENT_READ_REQUEST</a> = 0, 
<a class="el" href="group___h_w___i2_c.html#gga67f970897e2e55be317fcae7f01bdf1fae3a61cfca95b35f79a38ded155f8d896">HW_I2C_EVENT_DATA_READY</a>, 
<a class="el" href="group___h_w___i2_c.html#gga67f970897e2e55be317fcae7f01bdf1fa5ff2bf612fd676b74c4477d65cb4644b">HW_I2C_EVENT_TX_ABORT</a>, 
<a class="el" href="group___h_w___i2_c.html#gga67f970897e2e55be317fcae7f01bdf1fa556ed33f8390ad37fbe8505db1fd45ae">HW_I2C_EVENT_RX_OVERFLOW</a>, 
<br />
&#160;&#160;<a class="el" href="group___h_w___i2_c.html#gga67f970897e2e55be317fcae7f01bdf1faf1ab08c136ac9364cf922be55da999fa">HW_I2C_EVENT_INVALID</a>
<br />
 }</td></tr>
<tr class="memdesc:ga67f970897e2e55be317fcae7f01bdf1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback events when working as slave.  <a href="group___h_w___i2_c.html#ga67f970897e2e55be317fcae7f01bdf1f">More...</a><br /></td></tr>
<tr class="separator:ga67f970897e2e55be317fcae7f01bdf1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab067c78f6839084ba44ddd5ffa375a4c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gab067c78f6839084ba44ddd5ffa375a4c">HW_I2C_INT</a> { <br />
&#160;&#160;<a class="el" href="group___h_w___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4ca61baec49ed26f10abe66c8d0132ea189">HW_I2C_INT_RX_UNDERFLOW</a> = I2C_I2C_INTR_STAT_REG_R_RX_UNDER_Msk, 
<a class="el" href="group___h_w___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4cafcd7b0583a6b99d8854fa2909ec90c4c">HW_I2C_INT_RX_OVERFLOW</a> = I2C_I2C_INTR_STAT_REG_R_RX_OVER_Msk, 
<a class="el" href="group___h_w___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4ca8acaa4d17886b481f05246d3d4ae818e">HW_I2C_INT_RX_FULL</a> = I2C_I2C_INTR_STAT_REG_R_RX_FULL_Msk, 
<a class="el" href="group___h_w___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4ca543a0b0fb421fb098f3ccc80d42af4c2">HW_I2C_INT_TX_OVERFLOW</a> = I2C_I2C_INTR_STAT_REG_R_TX_OVER_Msk, 
<br />
&#160;&#160;<a class="el" href="group___h_w___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4cacdeff6bd5f88c566caefda8ba7d7f237">HW_I2C_INT_TX_EMPTY</a> = I2C_I2C_INTR_STAT_REG_R_TX_EMPTY_Msk, 
<a class="el" href="group___h_w___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4ca39b828d633959d80010b47553d42948c">HW_I2C_INT_READ_REQUEST</a> = I2C_I2C_INTR_STAT_REG_R_RD_REQ_Msk, 
<a class="el" href="group___h_w___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4caca667f9f8631fd98f1f0a11fc4f0c868">HW_I2C_INT_TX_ABORT</a> = I2C_I2C_INTR_STAT_REG_R_TX_ABRT_Msk, 
<a class="el" href="group___h_w___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4ca24025187688fc359ddc30f95b538097e">HW_I2C_INT_RX_DONE</a> = I2C_I2C_INTR_STAT_REG_R_RX_DONE_Msk, 
<br />
&#160;&#160;<a class="el" href="group___h_w___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4ca191c65c506005d2c2a1c28bfc99797a5">HW_I2C_INT_ACTIVITY</a> = I2C_I2C_INTR_STAT_REG_R_ACTIVITY_Msk, 
<a class="el" href="group___h_w___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4caa20a13e8d583e0c25a109cf3fd5e5d3a">HW_I2C_INT_STOP_DETECTED</a> = I2C_I2C_INTR_STAT_REG_R_STOP_DET_Msk, 
<a class="el" href="group___h_w___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4caf4c788f651f281694564881e03e1f450">HW_I2C_INT_START_DETECTED</a> = I2C_I2C_INTR_STAT_REG_R_START_DET_Msk, 
<a class="el" href="group___h_w___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4ca57b24b5967091179674f5cfc437eb127">HW_I2C_INT_GENERAL_CALL</a> = I2C_I2C_INTR_STAT_REG_R_GEN_CALL_Msk
<br />
 }</td></tr>
<tr class="memdesc:gab067c78f6839084ba44ddd5ffa375a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C interrupt source.  <a href="group___h_w___i2_c.html#gab067c78f6839084ba44ddd5ffa375a4c">More...</a><br /></td></tr>
<tr class="separator:gab067c78f6839084ba44ddd5ffa375a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f022606a4d9ca1dab3e377d0dbac6fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5f022606a4d9ca1dab3e377d0dbac6fb"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga5f022606a4d9ca1dab3e377d0dbac6fb">HW_I2C_DMA_TRANSFER</a> </td></tr>
<tr class="memdesc:ga5f022606a4d9ca1dab3e377d0dbac6fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMA transfer type. <br /></td></tr>
<tr class="separator:ga5f022606a4d9ca1dab3e377d0dbac6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae7c11da98b9e2a0b2ce5ac6e3d63d6bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gae7c11da98b9e2a0b2ce5ac6e3d63d6bd">hw_i2c_init</a> (HW_I2C_ID id, const <a class="el" href="structi2c__config.html">i2c_config</a> *cfg)</td></tr>
<tr class="memdesc:gae7c11da98b9e2a0b2ce5ac6e3d63d6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize I2C controller.  <a href="#gae7c11da98b9e2a0b2ce5ac6e3d63d6bd">More...</a><br /></td></tr>
<tr class="separator:gae7c11da98b9e2a0b2ce5ac6e3d63d6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad835e21e2833e94493aca5403f71dcb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gad835e21e2833e94493aca5403f71dcb4">hw_i2c_deinit</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gad835e21e2833e94493aca5403f71dcb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">DeInitialize I2C controller.  <a href="#gad835e21e2833e94493aca5403f71dcb4">More...</a><br /></td></tr>
<tr class="separator:gad835e21e2833e94493aca5403f71dcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b0281ad670c33606aa8c43f1de28674"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga1b0281ad670c33606aa8c43f1de28674">hw_i2c_configure</a> (HW_I2C_ID id, const <a class="el" href="structi2c__config.html">i2c_config</a> *cfg)</td></tr>
<tr class="memdesc:ga1b0281ad670c33606aa8c43f1de28674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure I2C controller.  <a href="#ga1b0281ad670c33606aa8c43f1de28674">More...</a><br /></td></tr>
<tr class="separator:ga1b0281ad670c33606aa8c43f1de28674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d2c12974ecc26330681ac6180e03c59"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga7d2c12974ecc26330681ac6180e03c59">hw_i2c_enable</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga7d2c12974ecc26330681ac6180e03c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable I2C controller.  <a href="#ga7d2c12974ecc26330681ac6180e03c59">More...</a><br /></td></tr>
<tr class="separator:ga7d2c12974ecc26330681ac6180e03c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee0d7283fbfce7d1ef01d01dd615fbad"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gaee0d7283fbfce7d1ef01d01dd615fbad">hw_i2c_disable</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gaee0d7283fbfce7d1ef01d01dd615fbad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable I2C controller.  <a href="#gaee0d7283fbfce7d1ef01d01dd615fbad">More...</a><br /></td></tr>
<tr class="separator:gaee0d7283fbfce7d1ef01d01dd615fbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c11acf2fbc38907404c35dc73a70f92"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga6c11acf2fbc38907404c35dc73a70f92">hw_i2c_get_enable_status</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga6c11acf2fbc38907404c35dc73a70f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get I2C Controller Enable status.  <a href="#ga6c11acf2fbc38907404c35dc73a70f92">More...</a><br /></td></tr>
<tr class="separator:ga6c11acf2fbc38907404c35dc73a70f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5fb1f72df9cfc50a486db1a3b75ee51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gab5fb1f72df9cfc50a486db1a3b75ee51">hw_i2c_is_occupied</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gab5fb1f72df9cfc50a486db1a3b75ee51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get I2C controller occupied status.  <a href="#gab5fb1f72df9cfc50a486db1a3b75ee51">More...</a><br /></td></tr>
<tr class="separator:gab5fb1f72df9cfc50a486db1a3b75ee51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5944b69ca4fc9f378ca3c3f7f6740c80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga5944b69ca4fc9f378ca3c3f7f6740c80">hw_i2c_register_int</a> (HW_I2C_ID id, <a class="el" href="group___h_w___i2_c.html#ga07fb0d97fcc29f7d55b1846927d7ad18">hw_i2c_interrupt_cb</a> cb, uint16_t mask)</td></tr>
<tr class="memdesc:ga5944b69ca4fc9f378ca3c3f7f6740c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register interrupt handler.  <a href="#ga5944b69ca4fc9f378ca3c3f7f6740c80">More...</a><br /></td></tr>
<tr class="separator:ga5944b69ca4fc9f378ca3c3f7f6740c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fe2293421ca1305ff40efe8e0f3ff6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga5fe2293421ca1305ff40efe8e0f3ff6b">hw_i2c_unregister_int</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga5fe2293421ca1305ff40efe8e0f3ff6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister interrupt handler.  <a href="#ga5fe2293421ca1305ff40efe8e0f3ff6b">More...</a><br /></td></tr>
<tr class="separator:ga5fe2293421ca1305ff40efe8e0f3ff6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdc4ec9c80147b1c5b07b07374ea4165"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gabdc4ec9c80147b1c5b07b07374ea4165">hw_i2c_set_int_mask</a> (HW_I2C_ID id, uint16_t mask)</td></tr>
<tr class="memdesc:gabdc4ec9c80147b1c5b07b07374ea4165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bitmask of requested interrupt events.  <a href="#gabdc4ec9c80147b1c5b07b07374ea4165">More...</a><br /></td></tr>
<tr class="separator:gabdc4ec9c80147b1c5b07b07374ea4165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64869198710650bdfb5d0e0a268a2d8f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga64869198710650bdfb5d0e0a268a2d8f">hw_i2c_get_int_mask</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga64869198710650bdfb5d0e0a268a2d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current bitmask of requested interrupt events.  <a href="#ga64869198710650bdfb5d0e0a268a2d8f">More...</a><br /></td></tr>
<tr class="separator:ga64869198710650bdfb5d0e0a268a2d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga944b02f60bac146f8ffa8a6bddae0c29"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga944b02f60bac146f8ffa8a6bddae0c29">hw_i2c_set_mode</a> (HW_I2C_ID id, <a class="el" href="group___h_w___i2_c.html#gadf7ffb060052bb9ac0c167835afcc910">HW_I2C_MODE</a> <a class="el" href="group___h_w___g_p_i_o.html#gaa199c74823032086e5cbf0bcc10be215">mode</a>)</td></tr>
<tr class="memdesc:ga944b02f60bac146f8ffa8a6bddae0c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set I2C controller mode.  <a href="#ga944b02f60bac146f8ffa8a6bddae0c29">More...</a><br /></td></tr>
<tr class="separator:ga944b02f60bac146f8ffa8a6bddae0c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04d702d4b1fbef6b81cb5c5fbbaf1706"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga04d702d4b1fbef6b81cb5c5fbbaf1706">hw_i2c_is_master</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga04d702d4b1fbef6b81cb5c5fbbaf1706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get I2C controller master mode status.  <a href="#ga04d702d4b1fbef6b81cb5c5fbbaf1706">More...</a><br /></td></tr>
<tr class="separator:ga04d702d4b1fbef6b81cb5c5fbbaf1706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93bd9d48dd2c754d4305b3adf965c54d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga93bd9d48dd2c754d4305b3adf965c54d">hw_i2c_set_speed</a> (HW_I2C_ID id, <a class="el" href="group___h_w___i2_c.html#ga4cbcaaa7663a2cbba9418cdb5aab66d9">HW_I2C_SPEED</a> speed)</td></tr>
<tr class="memdesc:ga93bd9d48dd2c754d4305b3adf965c54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set I2C interface bus speed.  <a href="#ga93bd9d48dd2c754d4305b3adf965c54d">More...</a><br /></td></tr>
<tr class="separator:ga93bd9d48dd2c754d4305b3adf965c54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab43a88609634e5a8637877e28319a8e3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gab43a88609634e5a8637877e28319a8e3">hw_i2c_set_restart_enabled</a> (HW_I2C_ID id, bool enabled)</td></tr>
<tr class="memdesc:gab43a88609634e5a8637877e28319a8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether RESTART conditions may be sent when acting as master.  <a href="#gab43a88609634e5a8637877e28319a8e3">More...</a><br /></td></tr>
<tr class="separator:gab43a88609634e5a8637877e28319a8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa8485f620b01d639f087d62af51f6b5"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gaaa8485f620b01d639f087d62af51f6b5">hw_i2c_set_general_call_enabled</a> (HW_I2C_ID id, bool enabled)</td></tr>
<tr class="memdesc:gaaa8485f620b01d639f087d62af51f6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether General Call should be used to address slaves.  <a href="#gaaa8485f620b01d639f087d62af51f6b5">More...</a><br /></td></tr>
<tr class="separator:gaaa8485f620b01d639f087d62af51f6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f7450ab438b35f90fb088404fa92805"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga3f7450ab438b35f90fb088404fa92805">hw_i2c_set_target_addressing_mode</a> (HW_I2C_ID id, <a class="el" href="group___h_w___i2_c.html#ga8c4b473a8fcb034aaabd8d2c7cf9c6bd">HW_I2C_ADDRESSING</a> addr_mode)</td></tr>
<tr class="memdesc:ga3f7450ab438b35f90fb088404fa92805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set target slave addressing mode in master mode.  <a href="#ga3f7450ab438b35f90fb088404fa92805">More...</a><br /></td></tr>
<tr class="separator:ga3f7450ab438b35f90fb088404fa92805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36fe411eb2e961228493ef77a061f158"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga36fe411eb2e961228493ef77a061f158">hw_i2c_set_slave_addressing_mode</a> (HW_I2C_ID id, <a class="el" href="group___h_w___i2_c.html#ga8c4b473a8fcb034aaabd8d2c7cf9c6bd">HW_I2C_ADDRESSING</a> addr_mode)</td></tr>
<tr class="memdesc:ga36fe411eb2e961228493ef77a061f158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set slave addressing mode in slave mode.  <a href="#ga36fe411eb2e961228493ef77a061f158">More...</a><br /></td></tr>
<tr class="separator:ga36fe411eb2e961228493ef77a061f158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec79c526d73e88d31fc45d3017954969"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gaec79c526d73e88d31fc45d3017954969">hw_i2c_set_slave_address</a> (HW_I2C_ID id, uint16_t address)</td></tr>
<tr class="memdesc:gaec79c526d73e88d31fc45d3017954969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set slave address in slave mode.  <a href="#gaec79c526d73e88d31fc45d3017954969">More...</a><br /></td></tr>
<tr class="separator:gaec79c526d73e88d31fc45d3017954969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6f21d86041cba8208dcf4e074c457b2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gaa6f21d86041cba8208dcf4e074c457b2">hw_i2c_set_general_call_ack_enabled</a> (HW_I2C_ID id, bool ack)</td></tr>
<tr class="memdesc:gaa6f21d86041cba8208dcf4e074c457b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set support for general call acknowledgment.  <a href="#gaa6f21d86041cba8208dcf4e074c457b2">More...</a><br /></td></tr>
<tr class="separator:gaa6f21d86041cba8208dcf4e074c457b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a29630b78ef7e94a3392bde6e15ca08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga2a29630b78ef7e94a3392bde6e15ca08">hw_i2c_setup_master</a> (HW_I2C_ID id, <a class="el" href="group___h_w___i2_c.html#ga8c4b473a8fcb034aaabd8d2c7cf9c6bd">HW_I2C_ADDRESSING</a> addr_mode, uint16_t address)</td></tr>
<tr class="memdesc:ga2a29630b78ef7e94a3392bde6e15ca08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup controller for operation in master mode.  <a href="#ga2a29630b78ef7e94a3392bde6e15ca08">More...</a><br /></td></tr>
<tr class="separator:ga2a29630b78ef7e94a3392bde6e15ca08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93e9a3a4c278669d66a31a0abd444812"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga93e9a3a4c278669d66a31a0abd444812">hw_i2c_set_slave_callback</a> (HW_I2C_ID id, <a class="el" href="group___h_w___i2_c.html#gaf953d4d6f6b9465dcc65d369b4bcb2bd">hw_i2c_event_cb</a> cb)</td></tr>
<tr class="memdesc:ga93e9a3a4c278669d66a31a0abd444812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup callback function for operation in slave mode.  <a href="#ga93e9a3a4c278669d66a31a0abd444812">More...</a><br /></td></tr>
<tr class="separator:ga93e9a3a4c278669d66a31a0abd444812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0490c49ca963197c4121a4340f4f868"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gaa0490c49ca963197c4121a4340f4f868">hw_i2c_register_slave_dma_read_callback</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gaa0490c49ca963197c4121a4340f4f868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register proper handling for DMA read in slave mode.  <a href="#gaa0490c49ca963197c4121a4340f4f868">More...</a><br /></td></tr>
<tr class="separator:gaa0490c49ca963197c4121a4340f4f868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfb7542e60f661193ed1fc82df545586"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gabfb7542e60f661193ed1fc82df545586">hw_i2c_setup_slave</a> (HW_I2C_ID id, <a class="el" href="group___h_w___i2_c.html#ga8c4b473a8fcb034aaabd8d2c7cf9c6bd">HW_I2C_ADDRESSING</a> addr_mode, uint16_t address, <a class="el" href="group___h_w___i2_c.html#gaf953d4d6f6b9465dcc65d369b4bcb2bd">hw_i2c_event_cb</a> cb)</td></tr>
<tr class="memdesc:gabfb7542e60f661193ed1fc82df545586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup controller for operation in slave mode.  <a href="#gabfb7542e60f661193ed1fc82df545586">More...</a><br /></td></tr>
<tr class="separator:gabfb7542e60f661193ed1fc82df545586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb337465229c2552d1ad4762207b2813"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gabb337465229c2552d1ad4762207b2813">hw_i2c_is_master_busy</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gabb337465229c2552d1ad4762207b2813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if controller is busy when operating in master mode.  <a href="#gabb337465229c2552d1ad4762207b2813">More...</a><br /></td></tr>
<tr class="separator:gabb337465229c2552d1ad4762207b2813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b67ce7fed2275262772c0d2b49a3261"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga2b67ce7fed2275262772c0d2b49a3261">hw_i2c_is_slave_busy</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga2b67ce7fed2275262772c0d2b49a3261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if controller is busy when operating in slave mode.  <a href="#ga2b67ce7fed2275262772c0d2b49a3261">More...</a><br /></td></tr>
<tr class="separator:ga2b67ce7fed2275262772c0d2b49a3261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44963f4dda188d16fc63dc62fcd2d563"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga44963f4dda188d16fc63dc62fcd2d563">hw_i2c_controler_is_busy</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga44963f4dda188d16fc63dc62fcd2d563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check controller activity.  <a href="#ga44963f4dda188d16fc63dc62fcd2d563">More...</a><br /></td></tr>
<tr class="separator:ga44963f4dda188d16fc63dc62fcd2d563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga694fb9bb8c7149af5f15a09614356aa5"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga694fb9bb8c7149af5f15a09614356aa5">hw_i2c_is_tx_fifo_empty</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga694fb9bb8c7149af5f15a09614356aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if TX FIFO queue is empty.  <a href="#ga694fb9bb8c7149af5f15a09614356aa5">More...</a><br /></td></tr>
<tr class="separator:ga694fb9bb8c7149af5f15a09614356aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1efff1212c20d381d6916c7511912dbc"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga1efff1212c20d381d6916c7511912dbc">hw_i2c_is_tx_fifo_not_full</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga1efff1212c20d381d6916c7511912dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if TX FIFO is not full.  <a href="#ga1efff1212c20d381d6916c7511912dbc">More...</a><br /></td></tr>
<tr class="separator:ga1efff1212c20d381d6916c7511912dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7825881b52de2f0d9a21ab9656a2f1d3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga7825881b52de2f0d9a21ab9656a2f1d3">hw_i2c_is_rx_fifo_full</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga7825881b52de2f0d9a21ab9656a2f1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if RX FIFO queue is full.  <a href="#ga7825881b52de2f0d9a21ab9656a2f1d3">More...</a><br /></td></tr>
<tr class="separator:ga7825881b52de2f0d9a21ab9656a2f1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22ba4ad39e591d59eb448c6c097d6294"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga22ba4ad39e591d59eb448c6c097d6294">hw_i2c_is_rx_fifo_not_empty</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga22ba4ad39e591d59eb448c6c097d6294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if RX FIFO is not empty.  <a href="#ga22ba4ad39e591d59eb448c6c097d6294">More...</a><br /></td></tr>
<tr class="separator:ga22ba4ad39e591d59eb448c6c097d6294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab808b7a790080603e8ada092c8167b4f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gab808b7a790080603e8ada092c8167b4f">hw_i2c_set_target_address</a> (HW_I2C_ID id, uint16_t address)</td></tr>
<tr class="memdesc:gab808b7a790080603e8ada092c8167b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set target slave address in master mode.  <a href="#gab808b7a790080603e8ada092c8167b4f">More...</a><br /></td></tr>
<tr class="separator:gab808b7a790080603e8ada092c8167b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01e8777fff2beda6b7e3823fba2548d1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga01e8777fff2beda6b7e3823fba2548d1">hw_i2c_write_byte</a> (HW_I2C_ID id, uint8_t byte)</td></tr>
<tr class="memdesc:ga01e8777fff2beda6b7e3823fba2548d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write single byte into TX FIFO.  <a href="#ga01e8777fff2beda6b7e3823fba2548d1">More...</a><br /></td></tr>
<tr class="separator:ga01e8777fff2beda6b7e3823fba2548d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e5e57db2f2b5eafe39c3efc2a752f09"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga2e5e57db2f2b5eafe39c3efc2a752f09">hw_i2c_write_buffer_sync</a> (HW_I2C_ID id, const uint8_t *data, uint16_t len, <a class="el" href="group___h_w___i2_c.html#gaf7ef8a80c9c6e53c3edf28cc5bf2007e">HW_I2C_ABORT_SOURCE</a> *abrt_code, uint32_t flags)</td></tr>
<tr class="memdesc:ga2e5e57db2f2b5eafe39c3efc2a752f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write multiple bytes to I2C slave synchronously.  <a href="#ga2e5e57db2f2b5eafe39c3efc2a752f09">More...</a><br /></td></tr>
<tr class="separator:ga2e5e57db2f2b5eafe39c3efc2a752f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4f644c258dfd1dd0c3c5df464733d21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gaf4f644c258dfd1dd0c3c5df464733d21">hw_i2c_write_buffer_async</a> (HW_I2C_ID id, const uint8_t *data, uint16_t len, <a class="el" href="group___h_w___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a> cb, void *cb_data, uint32_t flags)</td></tr>
<tr class="memdesc:gaf4f644c258dfd1dd0c3c5df464733d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write multiple bytes to I2C slave asynchronously.  <a href="#gaf4f644c258dfd1dd0c3c5df464733d21">More...</a><br /></td></tr>
<tr class="separator:gaf4f644c258dfd1dd0c3c5df464733d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ba745fbf5b2aa3fbb3bd19cfd16bfe3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga2ba745fbf5b2aa3fbb3bd19cfd16bfe3">hw_i2c_read_byte_trigger</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga2ba745fbf5b2aa3fbb3bd19cfd16bfe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate reading from I2C bus.  <a href="#ga2ba745fbf5b2aa3fbb3bd19cfd16bfe3">More...</a><br /></td></tr>
<tr class="separator:ga2ba745fbf5b2aa3fbb3bd19cfd16bfe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa18b3a881d304cb070b22d5b5eda821c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gaa18b3a881d304cb070b22d5b5eda821c">hw_i2c_read_buffer_sync</a> (HW_I2C_ID id, uint8_t *data, uint16_t len, <a class="el" href="group___h_w___i2_c.html#gaf7ef8a80c9c6e53c3edf28cc5bf2007e">HW_I2C_ABORT_SOURCE</a> *abrt_code, uint32_t flags)</td></tr>
<tr class="memdesc:gaa18b3a881d304cb070b22d5b5eda821c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read multiple bytes from I2C slave synchronously.  <a href="#gaa18b3a881d304cb070b22d5b5eda821c">More...</a><br /></td></tr>
<tr class="separator:gaa18b3a881d304cb070b22d5b5eda821c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad7bb04ff5cdba25f0a1b4076cb36f44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gaad7bb04ff5cdba25f0a1b4076cb36f44">hw_i2c_read_buffer_async</a> (HW_I2C_ID id, uint8_t *data, uint16_t len, <a class="el" href="group___h_w___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a> cb, void *cb_data, uint32_t flags)</td></tr>
<tr class="memdesc:gaad7bb04ff5cdba25f0a1b4076cb36f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read multiple bytes from I2C slave asynchronously.  <a href="#gaad7bb04ff5cdba25f0a1b4076cb36f44">More...</a><br /></td></tr>
<tr class="separator:gaad7bb04ff5cdba25f0a1b4076cb36f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga427b041327ec43abc52c7f6d74a739e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga427b041327ec43abc52c7f6d74a739e7">hw_i2c_write_then_read_async</a> (HW_I2C_ID id, const uint8_t *w_data, uint16_t w_len, uint8_t *r_data, uint16_t r_len, <a class="el" href="group___h_w___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a> cb, void *cb_data, uint32_t flags)</td></tr>
<tr class="memdesc:ga427b041327ec43abc52c7f6d74a739e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write then read multiple bytes from I2C slave.  <a href="#ga427b041327ec43abc52c7f6d74a739e7">More...</a><br /></td></tr>
<tr class="separator:ga427b041327ec43abc52c7f6d74a739e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dc2a13d264888d9900aa0b2937adda2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga0dc2a13d264888d9900aa0b2937adda2">hw_i2c_read_byte</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga0dc2a13d264888d9900aa0b2937adda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read single byte from RX FIFO.  <a href="#ga0dc2a13d264888d9900aa0b2937adda2">More...</a><br /></td></tr>
<tr class="separator:ga0dc2a13d264888d9900aa0b2937adda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b461e0a63739e1310b68ac2a4d6a7b5"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga6b461e0a63739e1310b68ac2a4d6a7b5">hw_i2c_set_tx_fifo_threshold</a> (HW_I2C_ID id, uint8_t level)</td></tr>
<tr class="memdesc:ga6b461e0a63739e1310b68ac2a4d6a7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set threshold level on TX FIFO.  <a href="#ga6b461e0a63739e1310b68ac2a4d6a7b5">More...</a><br /></td></tr>
<tr class="separator:ga6b461e0a63739e1310b68ac2a4d6a7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0dada4da100a5c513ce4389036457ae"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gab0dada4da100a5c513ce4389036457ae">hw_i2c_set_rx_fifo_threshold</a> (HW_I2C_ID id, uint8_t level)</td></tr>
<tr class="memdesc:gab0dada4da100a5c513ce4389036457ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set threshold level on RX FIFO.  <a href="#gab0dada4da100a5c513ce4389036457ae">More...</a><br /></td></tr>
<tr class="separator:gab0dada4da100a5c513ce4389036457ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91814578393829d28b16023ff7b61883"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga91814578393829d28b16023ff7b61883">hw_i2c_get_tx_fifo_threshold</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga91814578393829d28b16023ff7b61883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get threshold level on TX FIFO.  <a href="#ga91814578393829d28b16023ff7b61883">More...</a><br /></td></tr>
<tr class="separator:ga91814578393829d28b16023ff7b61883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a04ad6aa503971a081c4b2af1847652"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga3a04ad6aa503971a081c4b2af1847652">hw_i2c_get_rx_fifo_threshold</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga3a04ad6aa503971a081c4b2af1847652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get threshold level on RX FIFO.  <a href="#ga3a04ad6aa503971a081c4b2af1847652">More...</a><br /></td></tr>
<tr class="separator:ga3a04ad6aa503971a081c4b2af1847652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3580f5534d5d1fb3b86fa19911bc695"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gaf3580f5534d5d1fb3b86fa19911bc695">hw_i2c_get_tx_fifo_level</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gaf3580f5534d5d1fb3b86fa19911bc695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of bytes in TX FIFO.  <a href="#gaf3580f5534d5d1fb3b86fa19911bc695">More...</a><br /></td></tr>
<tr class="separator:gaf3580f5534d5d1fb3b86fa19911bc695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81090f2405c289d0ecd207ee96bad651"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga81090f2405c289d0ecd207ee96bad651">hw_i2c_get_rx_fifo_level</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga81090f2405c289d0ecd207ee96bad651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of bytes in RX FIFO.  <a href="#ga81090f2405c289d0ecd207ee96bad651">More...</a><br /></td></tr>
<tr class="separator:ga81090f2405c289d0ecd207ee96bad651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08d2af6de76f5186c1c16d51269b5c37"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga08d2af6de76f5186c1c16d51269b5c37">hw_i2c_get_int_state</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga08d2af6de76f5186c1c16d51269b5c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interrupt state.  <a href="#ga08d2af6de76f5186c1c16d51269b5c37">More...</a><br /></td></tr>
<tr class="separator:ga08d2af6de76f5186c1c16d51269b5c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c817096fa18e6495c7244c734f03004"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga5c817096fa18e6495c7244c734f03004">hw_i2c_get_raw_int_state</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga5c817096fa18e6495c7244c734f03004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get raw interrupt state.  <a href="#ga5c817096fa18e6495c7244c734f03004">More...</a><br /></td></tr>
<tr class="separator:ga5c817096fa18e6495c7244c734f03004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16e89d90f015b43269e6c49cfbba0ec4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga16e89d90f015b43269e6c49cfbba0ec4">hw_i2c_reset_int_all</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga16e89d90f015b43269e6c49cfbba0ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all interrupt state.  <a href="#ga16e89d90f015b43269e6c49cfbba0ec4">More...</a><br /></td></tr>
<tr class="separator:ga16e89d90f015b43269e6c49cfbba0ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga788dd9d7200110f6c9541973859eb628"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga788dd9d7200110f6c9541973859eb628">hw_i2c_reset_int_rx_underflow</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga788dd9d7200110f6c9541973859eb628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset RX_UNDERFLOW interrupt state.  <a href="#ga788dd9d7200110f6c9541973859eb628">More...</a><br /></td></tr>
<tr class="separator:ga788dd9d7200110f6c9541973859eb628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fbe57fcca5e406cd360e2e697af581a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga8fbe57fcca5e406cd360e2e697af581a">hw_i2c_reset_int_rx_overflow</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga8fbe57fcca5e406cd360e2e697af581a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset RX_OVERFLOW interrupt state.  <a href="#ga8fbe57fcca5e406cd360e2e697af581a">More...</a><br /></td></tr>
<tr class="separator:ga8fbe57fcca5e406cd360e2e697af581a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga718b3de7c09d4cb5daf6defe21716ed6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga718b3de7c09d4cb5daf6defe21716ed6">hw_i2c_reset_int_tx_overflow</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga718b3de7c09d4cb5daf6defe21716ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset TX_OVERFLOW interrupt state.  <a href="#ga718b3de7c09d4cb5daf6defe21716ed6">More...</a><br /></td></tr>
<tr class="separator:ga718b3de7c09d4cb5daf6defe21716ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ddda1add62f2cffb23e28367d1cefd9"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga0ddda1add62f2cffb23e28367d1cefd9">hw_i2c_reset_int_read_request</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga0ddda1add62f2cffb23e28367d1cefd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset READ_REQUEST interrupt state.  <a href="#ga0ddda1add62f2cffb23e28367d1cefd9">More...</a><br /></td></tr>
<tr class="separator:ga0ddda1add62f2cffb23e28367d1cefd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f237147b1403e491c5c4c6d0d3396ff"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga0f237147b1403e491c5c4c6d0d3396ff">hw_i2c_reset_int_tx_abort</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga0f237147b1403e491c5c4c6d0d3396ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset TX_ABORT interrupt state.  <a href="#ga0f237147b1403e491c5c4c6d0d3396ff">More...</a><br /></td></tr>
<tr class="separator:ga0f237147b1403e491c5c4c6d0d3396ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97d7ed3f50914fc65a1d7614148726ae"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga97d7ed3f50914fc65a1d7614148726ae">hw_i2c_reset_int_rx_done</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga97d7ed3f50914fc65a1d7614148726ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset RX_DONE interrupt state.  <a href="#ga97d7ed3f50914fc65a1d7614148726ae">More...</a><br /></td></tr>
<tr class="separator:ga97d7ed3f50914fc65a1d7614148726ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10ccd98f55a6a813772c799bd3324f0e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga10ccd98f55a6a813772c799bd3324f0e">hw_i2c_reset_int_activity</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga10ccd98f55a6a813772c799bd3324f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset ACTIVITY interrupt state.  <a href="#ga10ccd98f55a6a813772c799bd3324f0e">More...</a><br /></td></tr>
<tr class="separator:ga10ccd98f55a6a813772c799bd3324f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a37c58f9dd3d45f9de6b611e9f65414"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga0a37c58f9dd3d45f9de6b611e9f65414">hw_i2c_reset_int_start_detected</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga0a37c58f9dd3d45f9de6b611e9f65414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset START_DETECTED interrupt state.  <a href="#ga0a37c58f9dd3d45f9de6b611e9f65414">More...</a><br /></td></tr>
<tr class="separator:ga0a37c58f9dd3d45f9de6b611e9f65414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd879383099d7176d124c638bf893b46"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gacd879383099d7176d124c638bf893b46">hw_i2c_reset_int_stop_detected</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gacd879383099d7176d124c638bf893b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset STOP_DETECTED interrupt state.  <a href="#gacd879383099d7176d124c638bf893b46">More...</a><br /></td></tr>
<tr class="separator:gacd879383099d7176d124c638bf893b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf5b54df4c64480f521c2c163d0a8728"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gabf5b54df4c64480f521c2c163d0a8728">hw_i2c_reset_int_gen_call</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gabf5b54df4c64480f521c2c163d0a8728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset GENERAL_CALL interrupt state.  <a href="#gabf5b54df4c64480f521c2c163d0a8728">More...</a><br /></td></tr>
<tr class="separator:gabf5b54df4c64480f521c2c163d0a8728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07ac8b942da9cc034ac5beb40d540c78"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga07ac8b942da9cc034ac5beb40d540c78">hw_i2c_get_abort_source</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga07ac8b942da9cc034ac5beb40d540c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get abort source.  <a href="#ga07ac8b942da9cc034ac5beb40d540c78">More...</a><br /></td></tr>
<tr class="separator:ga07ac8b942da9cc034ac5beb40d540c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccce6c681f6b95ee85c84f511f6eb97f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gaccce6c681f6b95ee85c84f511f6eb97f">hw_i2c_reset_abort_source</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gaccce6c681f6b95ee85c84f511f6eb97f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset abort source.  <a href="#gaccce6c681f6b95ee85c84f511f6eb97f">More...</a><br /></td></tr>
<tr class="separator:gaccce6c681f6b95ee85c84f511f6eb97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05dd5e10e905a26aa2086830d5468168"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga05dd5e10e905a26aa2086830d5468168">hw_i2c_master_abort_transfer</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga05dd5e10e905a26aa2086830d5468168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts I2C transfer.  <a href="#ga05dd5e10e905a26aa2086830d5468168">More...</a><br /></td></tr>
<tr class="separator:ga05dd5e10e905a26aa2086830d5468168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7a5bfe7457313724023263d82204091"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gab7a5bfe7457313724023263d82204091">hw_i2c_prepare_dma</a> (HW_I2C_ID id, uint8_t channel, void *data, uint16_t len, <a class="el" href="group___h_w___i2_c.html#ga5f022606a4d9ca1dab3e377d0dbac6fb">HW_I2C_DMA_TRANSFER</a> type, <a class="el" href="group___h_w___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a> cb, void *cb_data, uint32_t flags)</td></tr>
<tr class="memdesc:gab7a5bfe7457313724023263d82204091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares I2C DMA for transfer.  <a href="#gab7a5bfe7457313724023263d82204091">More...</a><br /></td></tr>
<tr class="separator:gab7a5bfe7457313724023263d82204091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfb617be9d4503854630dc6e6d545027"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gacfb617be9d4503854630dc6e6d545027">hw_i2c_dma_start</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gacfb617be9d4503854630dc6e6d545027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts DMA transfer.  <a href="#gacfb617be9d4503854630dc6e6d545027">More...</a><br /></td></tr>
<tr class="separator:gacfb617be9d4503854630dc6e6d545027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0093fa24296f69f2ec83da50aea34332"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#ga0093fa24296f69f2ec83da50aea34332">hw_i2c_write_buffer_dma</a> (HW_I2C_ID id, uint8_t channel, const uint16_t *data, uint16_t len, <a class="el" href="group___h_w___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a> cb, void *cb_data, uint32_t flags)</td></tr>
<tr class="memdesc:ga0093fa24296f69f2ec83da50aea34332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write multiple bytes on I2C bus using DMA.  <a href="#ga0093fa24296f69f2ec83da50aea34332">More...</a><br /></td></tr>
<tr class="separator:ga0093fa24296f69f2ec83da50aea34332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac735de8a924f7ebcc5eddf7a0094faf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___i2_c.html#gac735de8a924f7ebcc5eddf7a0094faf0">hw_i2c_read_buffer_dma</a> (HW_I2C_ID id, uint8_t channel, uint8_t *data, uint16_t len, <a class="el" href="group___h_w___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a> cb, void *cb_data, uint32_t flags)</td></tr>
<tr class="memdesc:gac735de8a924f7ebcc5eddf7a0094faf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read multiple bytes from I2C bus using DMA.  <a href="#gac735de8a924f7ebcc5eddf7a0094faf0">More...</a><br /></td></tr>
<tr class="separator:gac735de8a924f7ebcc5eddf7a0094faf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>I2C Controller. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gaf600a3324a7a01bce204dc8946cd9731"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HW_I2C_F_ADD_RESTART&#160;&#160;&#160;0x00000004</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add Restart condition at the start of read or write </p>

</div>
</div>
<a class="anchor" id="gaeccd5262bded02079206c0fed157b02e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HW_I2C_F_ADD_STOP&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add stop condition after read or write </p>

</div>
</div>
<a class="anchor" id="gadaf101cb30b8b19337faa1130b230b79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HW_I2C_F_NONE&#160;&#160;&#160;0x00000000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>No special command for the operation </p>

</div>
</div>
<a class="anchor" id="ga561070559a39fe8aa62f839207c5e5b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HW_I2C_F_WAIT_FOR_STOP&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operation will wait until stop condition occurs </p>

</div>
</div>
<a class="anchor" id="gacf98ed2c050989a781b95443ca34ac61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HW_I2C_REG_GETF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">field&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((IBA(id)-&gt;reg##_REG &amp; (I2C_##reg##_REG_##field##_Msk)) &gt;&gt; (I2C_##reg##_REG_##field##_Pos))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of an I2C register field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>the I2C register </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>the I2C register field</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>HW_SPI_SET_RFIELD </dd></dl>

</div>
</div>
<a class="anchor" id="ga0805a21fb0272d1ba210f1b8406d9d6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HW_I2C_REG_SETF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">val&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">IBA(<span class="keywordtype">id</span>)-&gt;reg##_REG = ((IBA(<span class="keywordtype">id</span>)-&gt;reg##_REG &amp; ~(I2C_##reg##_REG_##field##_Msk)) | \</div>
<div class="line">        ((I2C_##reg##_REG_##field##_Msk) &amp; ((val) &lt;&lt; (I2C_##reg##_REG_##field##_Pos))))</div>
</div><!-- fragment -->
<p>Write a value to an I2C register field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>the I2C register </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>the I2C register field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>value to be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_w___i2_c.html#gacf98ed2c050989a781b95443ca34ac61" title="Get the value of an I2C register field. ">HW_I2C_REG_GETF</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gacdc0311455ca8686015d5c0a7751c9d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_SETUP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">seq&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                         <a class="code" href="group___h_w___i2_c.html#gaee0d7283fbfce7d1ef01d01dd615fbad">\</a></div>
<div class="line"><a class="code" href="group___h_w___i2_c.html#gaee0d7283fbfce7d1ef01d01dd615fbad">                hw_i2c_disable</a>(<span class="keywordtype">id</span>);  \</div>
<div class="line">                seq;                 <a class="code" href="group___h_w___i2_c.html#ga7d2c12974ecc26330681ac6180e03c59">\</a></div>
<div class="line"><a class="code" href="group___h_w___i2_c.html#ga7d2c12974ecc26330681ac6180e03c59">                hw_i2c_enable</a>(<span class="keywordtype">id</span>);   \</div>
<div class="line">        } <span class="keywordflow">while</span> (0);</div>
<div class="ttc" id="group___h_w___i2_c_html_ga7d2c12974ecc26330681ac6180e03c59"><div class="ttname"><a href="group___h_w___i2_c.html#ga7d2c12974ecc26330681ac6180e03c59">hw_i2c_enable</a></div><div class="ttdeci">__STATIC_INLINE void hw_i2c_enable(HW_I2C_ID id)</div><div class="ttdoc">Enable I2C controller. </div><div class="ttdef"><b>Definition:</b> hw_i2c.h:323</div></div>
<div class="ttc" id="group___h_w___i2_c_html_gaee0d7283fbfce7d1ef01d01dd615fbad"><div class="ttname"><a href="group___h_w___i2_c.html#gaee0d7283fbfce7d1ef01d01dd615fbad">hw_i2c_disable</a></div><div class="ttdeci">__STATIC_INLINE void hw_i2c_disable(HW_I2C_ID id)</div><div class="ttdoc">Disable I2C controller. </div><div class="ttdef"><b>Definition:</b> hw_i2c.h:334</div></div>
</div><!-- fragment -->
<p>Wrapper to perform controller setup. </p>
<p>Controller will be disabled, then any code given as <code>seq</code> is executed and controller is enabled again. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gaa93c52dfb507e72c87250e55aeacd7fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* hw_i2c_complete_cb) (HW_I2C_ID id, void *cb_data, uint16_t len, bool success)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback called upon completion of read or write in non-blocking mode (FIFO or DMA) </p>
<p>This is a common callback type, which can be used with all non-deprecated API</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>data passed by user along with callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>number of bytes transferred. In case of write failure this number is equal to the number of bytes written to I2C TX FIFO until the failure occurred. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">success</td><td>operation status </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1b531343651246138ece5034039dd912"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* hw_i2c_dma_completed_handler_cb) (HW_I2C_ID id, void *cb_data, uint16_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback called on DMA operation completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>user data passed to <a class="el" href="group___h_w___i2_c.html#gab7a5bfe7457313724023263d82204091" title="Prepares I2C DMA for transfer. ">hw_i2c_prepare_dma()</a>, <a class="el" href="group___h_w___i2_c.html#ga0093fa24296f69f2ec83da50aea34332" title="Write multiple bytes on I2C bus using DMA. ">hw_i2c_write_buffer_dma()</a> or <a class="el" href="group___h_w___i2_c.html#gac735de8a924f7ebcc5eddf7a0094faf0" title="Read multiple bytes from I2C bus using DMA. ">hw_i2c_read_buffer_dma()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of data in buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>it is used by deprecated API, consider switching to API that uses <dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_w___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa" title="Callback called upon completion of read or write in non-blocking mode (FIFO or DMA) ...">hw_i2c_complete_cb</a></dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf953d4d6f6b9465dcc65d369b4bcb2bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* hw_i2c_event_cb) (HW_I2C_ID id, <a class="el" href="group___h_w___i2_c.html#ga67f970897e2e55be317fcae7f01bdf1f">HW_I2C_EVENT</a> event)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback called on event when in slave mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>event identifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga07fb0d97fcc29f7d55b1846927d7ad18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* hw_i2c_interrupt_cb) (HW_I2C_ID id, uint16_t mask)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback called on interrupt from I2C controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>interrupt events mask </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gaf7ef8a80c9c6e53c3edf28cc5bf2007e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_w___i2_c.html#gaf7ef8a80c9c6e53c3edf28cc5bf2007e">HW_I2C_ABORT_SOURCE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C abort source. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007eae82067c1b8c3ff8ebc74186a9c0ea898"></a>HW_I2C_ABORT_NONE&#160;</td><td class="fielddoc">
<p>no abort occured </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007ea339c3cf6463507009210a912d59643fe"></a>HW_I2C_ABORT_7B_ADDR_NO_ACK&#160;</td><td class="fielddoc">
<p>address byte of 7-bit address was not acknowledged by any slave </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007eadcf4555266b2cf92da1855d4074188a1"></a>HW_I2C_ABORT_10B_ADDR1_NO_ACK&#160;</td><td class="fielddoc">
<p>1st address byte of the 10-bit address was not acknowledged by any slave </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007eaf8e8a6cca5c2eea4f3cf52908d764fc3"></a>HW_I2C_ABORT_10B_ADDR2_NO_ACK&#160;</td><td class="fielddoc">
<p>2nd address byte of the 10-bit address was not acknowledged by any slave </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007ea89ed5978c4fe2387710c2bb37741eeda"></a>HW_I2C_ABORT_TX_DATA_NO_ACK&#160;</td><td class="fielddoc">
<p>data were not acknowledged by slave </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007eab2998a68ea7a4125b36ee1f7535c1e35"></a>HW_I2C_ABORT_GENERAL_CALL_NO_ACK&#160;</td><td class="fielddoc">
<p>General Call sent but no slave acknowledged </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007eacba5b0d9fea9fef11005edcf89189979"></a>HW_I2C_ABORT_GENERAL_CALL_READ&#160;</td><td class="fielddoc">
<p>trying to read from bus after General Call </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007eaead3321ef58dce6a681f2060dd3884de"></a>HW_I2C_ABORT_START_BYTE_ACK&#160;</td><td class="fielddoc">
<p>START condition acknowledged by slave </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007ea193c3b94ff14a9ddb921b9fbfbc07983"></a>HW_I2C_ABORT_10B_READ_NO_RESTART&#160;</td><td class="fielddoc">
<p>read command in 10-bit addressing mode with RESTART disabled </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007eabd08dc012bed51af07820d453f45dd2e"></a>HW_I2C_ABORT_MASTER_DISABLED&#160;</td><td class="fielddoc">
<p>master operation initiated with master mode disabled </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007eaf37422d631a97547825d6b2106f20b5b"></a>HW_I2C_ABORT_ARBITRATION_LOST&#160;</td><td class="fielddoc">
<p>bus arbitration lost </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007eaf579d26d06ff5b00ddd0061070fbbdc2"></a>HW_I2C_ABORT_SLAVE_FLUSH_TX_FIFO&#160;</td><td class="fielddoc">
<p>(slave mode) request for data with data already in TX FIFO - used to flush data in TX FIFO </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007ea1dc300a69352c4a42cd130a030ad4624"></a>HW_I2C_ABORT_SLAVE_ARBITRATION_LOST&#160;</td><td class="fielddoc">
<p>(slave mode) bus lost when transmitting to master </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007ea1fe3909020f346dc4aba68abd07e9498"></a>HW_I2C_ABORT_SLAVE_IN_TX&#160;</td><td class="fielddoc">
<p>(slave mode) request for data replied with read request </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007eada4e3b7ea6a617303cff16354cb9ead1"></a>HW_I2C_ABORT_SW_ERROR&#160;</td><td class="fielddoc">
<p>abort due to software error </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga8c4b473a8fcb034aaabd8d2c7cf9c6bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_w___i2_c.html#ga8c4b473a8fcb034aaabd8d2c7cf9c6bd">HW_I2C_ADDRESSING</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C addressing mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga8c4b473a8fcb034aaabd8d2c7cf9c6bdae223953fbec142796f36014e08490afb"></a>HW_I2C_ADDRESSING_7B&#160;</td><td class="fielddoc">
<p>7-bit addressing </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8c4b473a8fcb034aaabd8d2c7cf9c6bdab40023bfb7104ee30683a2377246892e"></a>HW_I2C_ADDRESSING_10B&#160;</td><td class="fielddoc">
<p>10-bit addressing </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga67f970897e2e55be317fcae7f01bdf1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_w___i2_c.html#ga67f970897e2e55be317fcae7f01bdf1f">HW_I2C_EVENT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback events when working as slave. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga67f970897e2e55be317fcae7f01bdf1fac5b1bfd3ab06735b76bbdd7e731afacb"></a>HW_I2C_EVENT_READ_REQUEST&#160;</td><td class="fielddoc">
<p>Data read request from master </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga67f970897e2e55be317fcae7f01bdf1fae3a61cfca95b35f79a38ded155f8d896"></a>HW_I2C_EVENT_DATA_READY&#160;</td><td class="fielddoc">
<p>Data written by master </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga67f970897e2e55be317fcae7f01bdf1fa5ff2bf612fd676b74c4477d65cb4644b"></a>HW_I2C_EVENT_TX_ABORT&#160;</td><td class="fielddoc">
<p>TX FIFO abort </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga67f970897e2e55be317fcae7f01bdf1fa556ed33f8390ad37fbe8505db1fd45ae"></a>HW_I2C_EVENT_RX_OVERFLOW&#160;</td><td class="fielddoc">
<p>RX FIFO overflow, some data are lost </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga67f970897e2e55be317fcae7f01bdf1faf1ab08c136ac9364cf922be55da999fa"></a>HW_I2C_EVENT_INVALID&#160;</td><td class="fielddoc">
<p>Invalid event </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gab067c78f6839084ba44ddd5ffa375a4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_w___i2_c.html#gab067c78f6839084ba44ddd5ffa375a4c">HW_I2C_INT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C interrupt source. </p>
<p>Can be used as bitmask. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4ca61baec49ed26f10abe66c8d0132ea189"></a>HW_I2C_INT_RX_UNDERFLOW&#160;</td><td class="fielddoc">
<p>attempt to read from empty RX FIFO has been made </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4cafcd7b0583a6b99d8854fa2909ec90c4c"></a>HW_I2C_INT_RX_OVERFLOW&#160;</td><td class="fielddoc">
<p>RX FIFO is full but new data are incoming and being discarded </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4ca8acaa4d17886b481f05246d3d4ae818e"></a>HW_I2C_INT_RX_FULL&#160;</td><td class="fielddoc">
<p>RX FIFO level is equal or above threshold set by <a class="el" href="group___h_w___i2_c.html#gab0dada4da100a5c513ce4389036457ae" title="Set threshold level on RX FIFO. ">hw_i2c_set_rx_fifo_threshold()</a> </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4ca543a0b0fb421fb098f3ccc80d42af4c2"></a>HW_I2C_INT_TX_OVERFLOW&#160;</td><td class="fielddoc">
<p>attempt to write to TX FIFO which is already full </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4cacdeff6bd5f88c566caefda8ba7d7f237"></a>HW_I2C_INT_TX_EMPTY&#160;</td><td class="fielddoc">
<p>TX FIFO level is equal or below threshold set by <a class="el" href="group___h_w___i2_c.html#ga6b461e0a63739e1310b68ac2a4d6a7b5" title="Set threshold level on TX FIFO. ">hw_i2c_set_tx_fifo_threshold()</a> </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4ca39b828d633959d80010b47553d42948c"></a>HW_I2C_INT_READ_REQUEST&#160;</td><td class="fielddoc">
<p>(slave only) I2C master attempts to read data </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4caca667f9f8631fd98f1f0a11fc4f0c868"></a>HW_I2C_INT_TX_ABORT&#160;</td><td class="fielddoc">
<p>TX cannot be completed </p><dl class="section see"><dt>See also</dt><dd>hw_get_abort_source() </dd>
<dd>
<a class="el" href="group___h_w___i2_c.html#gaccce6c681f6b95ee85c84f511f6eb97f" title="Reset abort source. ">hw_i2c_reset_abort_source()</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4ca24025187688fc359ddc30f95b538097e"></a>HW_I2C_INT_RX_DONE&#160;</td><td class="fielddoc">
<p>(slave only) I2C master did not acknowledge transmitted byte </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4ca191c65c506005d2c2a1c28bfc99797a5"></a>HW_I2C_INT_ACTIVITY&#160;</td><td class="fielddoc">
<p>any I2C activity occurred </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4caa20a13e8d583e0c25a109cf3fd5e5d3a"></a>HW_I2C_INT_STOP_DETECTED&#160;</td><td class="fielddoc">
<p>STOP condition occurred </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4caf4c788f651f281694564881e03e1f450"></a>HW_I2C_INT_START_DETECTED&#160;</td><td class="fielddoc">
<p>START/RESTART condition occurred </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4ca57b24b5967091179674f5cfc437eb127"></a>HW_I2C_INT_GENERAL_CALL&#160;</td><td class="fielddoc">
<p>(slave only) General Call address received </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gadf7ffb060052bb9ac0c167835afcc910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_w___i2_c.html#gadf7ffb060052bb9ac0c167835afcc910">HW_I2C_MODE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggadf7ffb060052bb9ac0c167835afcc910a70929eedc6ae4fba724cc57c4ece19e6"></a>HW_I2C_MODE_MASTER&#160;</td><td class="fielddoc">
<p>master mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf7ffb060052bb9ac0c167835afcc910adf9acb461b0239156a18bbe5280bf4d4"></a>HW_I2C_MODE_SLAVE&#160;</td><td class="fielddoc">
<p>slave mode </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga4cbcaaa7663a2cbba9418cdb5aab66d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_w___i2_c.html#ga4cbcaaa7663a2cbba9418cdb5aab66d9">HW_I2C_SPEED</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C interface speed. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga4cbcaaa7663a2cbba9418cdb5aab66d9ae56e52ba2b3aaceccff7e09c8b59c93e"></a>HW_I2C_SPEED_STANDARD&#160;</td><td class="fielddoc">
<p>100kb/s </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4cbcaaa7663a2cbba9418cdb5aab66d9a57993addaedcd03090ab60a2b7759f36"></a>HW_I2C_SPEED_FAST&#160;</td><td class="fielddoc">
<p>400kb/s </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4cbcaaa7663a2cbba9418cdb5aab66d9af762313255ddc0e41ed01391738ba1dd"></a>HW_I2C_SPEED_HIGH&#160;</td><td class="fielddoc">
<p>3.4Mb/s </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1b0281ad670c33606aa8c43f1de28674"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_configure </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structi2c__config.html">i2c_config</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure I2C controller. </p>
<p>Shortcut to configure most common I2C controller parameters.</p>
<dl class="section note"><dt>Note</dt><dd>Even with <code>cfg</code> set to NULL, I2C clock (SCL) will be configured using default values.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>configuration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga44963f4dda188d16fc63dc62fcd2d563"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool hw_i2c_controler_is_busy </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check controller activity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>busy status </dd></dl>

</div>
</div>
<a class="anchor" id="gad835e21e2833e94493aca5403f71dcb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_deinit </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DeInitialize I2C controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaee0d7283fbfce7d1ef01d01dd615fbad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_disable </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable I2C controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacfb617be9d4503854630dc6e6d545027"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_dma_start </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts DMA transfer. </p>
<p>Should be called once I2C DMA is setup using <a class="el" href="group___h_w___i2_c.html#gab7a5bfe7457313724023263d82204091" title="Prepares I2C DMA for transfer. ">hw_i2c_prepare_dma()</a>. Once started, DMA transfer will only finish once previously specified number of bytes is read or written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_w___i2_c.html#gab7a5bfe7457313724023263d82204091" title="Prepares I2C DMA for transfer. ">hw_i2c_prepare_dma</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d2c12974ecc26330681ac6180e03c59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_enable </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable I2C controller. </p>
<p><a class="el" href="group___h_w___i2_c.html#gae7c11da98b9e2a0b2ce5ac6e3d63d6bd" title="Initialize I2C controller. ">hw_i2c_init()</a> shall be called before enabling I2C controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga07ac8b942da9cc034ac5beb40d540c78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint16_t hw_i2c_get_abort_source </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get abort source. </p>
<p>This can be used to retrieve source of TX_ABORT interrupt. TX FIFO is flushed and remains in this state until cleared using <a class="el" href="group___h_w___i2_c.html#gaccce6c681f6b95ee85c84f511f6eb97f" title="Reset abort source. ">hw_i2c_reset_abort_source()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>abort source bitmask</dd></dl>
<dl class="section see"><dt>See also</dt><dd>I2C_ABORT_SOURCE </dd>
<dd>
<a class="el" href="group___h_w___i2_c.html#gaccce6c681f6b95ee85c84f511f6eb97f" title="Reset abort source. ">hw_i2c_reset_abort_source</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6c11acf2fbc38907404c35dc73a70f92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint16_t hw_i2c_get_enable_status </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get I2C Controller Enable status. </p>
<dl class="section return"><dt>Returns</dt><dd>The contents of the I2C_ENABLE_STATUS_REG </dd></dl>

</div>
</div>
<a class="anchor" id="ga64869198710650bdfb5d0e0a268a2d8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t hw_i2c_get_int_mask </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current bitmask of requested interrupt events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>current bitmask</dd></dl>
<dl class="section see"><dt>See also</dt><dd>I2C_INT </dd></dl>

</div>
</div>
<a class="anchor" id="ga08d2af6de76f5186c1c16d51269b5c37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint16_t hw_i2c_get_int_state </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get interrupt state. </p>
<p>Interrupt state returned includes only interrupts which are not masked. For raw interrupt status use <a class="el" href="group___h_w___i2_c.html#ga5c817096fa18e6495c7244c734f03004" title="Get raw interrupt state. ">hw_i2c_get_raw_int_state()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interrupt state bitmask</dd></dl>
<dl class="section see"><dt>See also</dt><dd>I2C_INT </dd>
<dd>
<a class="el" href="group___h_w___i2_c.html#ga5c817096fa18e6495c7244c734f03004" title="Get raw interrupt state. ">hw_i2c_get_raw_int_state</a> </dd>
<dd>
hw_i2c_set_intr_mask </dd></dl>

</div>
</div>
<a class="anchor" id="ga5c817096fa18e6495c7244c734f03004"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint16_t hw_i2c_get_raw_int_state </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get raw interrupt state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interrupt state bitmask</dd></dl>
<dl class="section see"><dt>See also</dt><dd>I2C_INT </dd>
<dd>
<a class="el" href="group___h_w___i2_c.html#ga08d2af6de76f5186c1c16d51269b5c37" title="Get interrupt state. ">hw_i2c_get_int_state</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga81090f2405c289d0ecd207ee96bad651"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint8_t hw_i2c_get_rx_fifo_level </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of bytes in RX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes </dd></dl>

</div>
</div>
<a class="anchor" id="ga3a04ad6aa503971a081c4b2af1847652"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint8_t hw_i2c_get_rx_fifo_threshold </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get threshold level on RX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf3580f5534d5d1fb3b86fa19911bc695"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint8_t hw_i2c_get_tx_fifo_level </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of bytes in TX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes </dd></dl>

</div>
</div>
<a class="anchor" id="ga91814578393829d28b16023ff7b61883"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint8_t hw_i2c_get_tx_fifo_threshold </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get threshold level on TX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae7c11da98b9e2a0b2ce5ac6e3d63d6bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_init </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structi2c__config.html">i2c_config</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize I2C controller. </p>
<p>I2C controller is disabled, clock and interrupt for I2C component are enabled, all interrupts are masked though. <code>cfg</code> can be NULL if no configuration should be performed.</p>
<dl class="section note"><dt>Note</dt><dd>Even with <code>cfg</code> set to NULL, I2C clock (SCL) will be configured using default values.</dd>
<dd>
The I2C clock source is set to DIVN (16MHz, regardless of PLL or XTAL16M being used).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>configuration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga04d702d4b1fbef6b81cb5c5fbbaf1706"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint8_t hw_i2c_is_master </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get I2C controller master mode status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if controller in master mode </dd></dl>

</div>
</div>
<a class="anchor" id="gabb337465229c2552d1ad4762207b2813"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool hw_i2c_is_master_busy </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if controller is busy when operating in master mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>busy status </dd></dl>

</div>
</div>
<a class="anchor" id="gab5fb1f72df9cfc50a486db1a3b75ee51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hw_i2c_is_occupied </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get I2C controller occupied status. </p>
<p>This function checks if the I2C controller is occupied by an ongoing operation waiting for an interrupt to hit in order to complete the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if requested id is already occupied, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga7825881b52de2f0d9a21ab9656a2f1d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool hw_i2c_is_rx_fifo_full </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if RX FIFO queue is full. </p>
<p>This function should be used to check if RX FIFO is filled, i.e. subsequent data read will be discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RX FIFO full status </dd></dl>

</div>
</div>
<a class="anchor" id="ga22ba4ad39e591d59eb448c6c097d6294"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool hw_i2c_is_rx_fifo_not_empty </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if RX FIFO is not empty. </p>
<p>This function should be used to check if there are any data received in RX FIFO</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RX FIFO not empty status </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b67ce7fed2275262772c0d2b49a3261"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool hw_i2c_is_slave_busy </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if controller is busy when operating in slave mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>busy status </dd></dl>

</div>
</div>
<a class="anchor" id="ga694fb9bb8c7149af5f15a09614356aa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool hw_i2c_is_tx_fifo_empty </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if TX FIFO queue is empty. </p>
<p>This function should be used to check if all data written to TX FIFO were transmitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TX FIFO empty status </dd></dl>

</div>
</div>
<a class="anchor" id="ga1efff1212c20d381d6916c7511912dbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool hw_i2c_is_tx_fifo_not_full </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if TX FIFO is not full. </p>
<p>This function should be used to check if data can be written to TX FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TX FIFO not full status </dd></dl>

</div>
</div>
<a class="anchor" id="ga05dd5e10e905a26aa2086830d5468168"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_master_abort_transfer </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts I2C transfer. </p>
<p>This forces master to issue a STOP command and flush the TX fifo.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Can be used only if controller is in master mode </dd></dl>

</div>
</div>
<a class="anchor" id="gab7a5bfe7457313724023263d82204091"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_prepare_dma </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___i2_c.html#ga5f022606a4d9ca1dab3e377d0dbac6fb">HW_I2C_DMA_TRANSFER</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares I2C DMA for transfer. </p>
<p>This "extended functionality" variant of <a class="el" href="group___h_w___i2_c.html#gab7a5bfe7457313724023263d82204091" title="Prepares I2C DMA for transfer. ">hw_i2c_prepare_dma()</a> adds the <code>notify_on_stop</code> parameter.</p>
<p>Use <a class="el" href="group___h_w___i2_c.html#gacfb617be9d4503854630dc6e6d545027" title="Starts DMA transfer. ">hw_i2c_dma_start()</a> to start actual data transfer.</p>
<p><code>channel</code> specifies either of channels in RX/TX pair used for transfer, i.e. channel=0|1 means channels 0 and 1 will be used, channel=2|3 means channels 2 and 3 will be used and so on. Once DMA is prepared, no other application should make changes to either of channels.</p>
<p><code>data</code> buffer elements are 16-bit wide, this high byte should be 0 for writing and discarded when reading.</p>
<p>Callback is called once DMA transfer between buffer and RX/TX FIFOs is completed which means that there could still be activity on I2C bus. Application can check when transfer is completed using other means, i.e. STOP_DETECTED interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>DMA channel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>buffer to read from or write to, depends on <code>type</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of <code>buffer</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>type of transfer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback for transfer completed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>data to pass to <code>cb</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br />
 This flag can be used for consecutive calls where the transaction can resume without stop/start conditions in between.</p>
<p><a class="el" href="group___h_w___i2_c.html#ga561070559a39fe8aa62f839207c5e5b7">HW_I2C_F_WAIT_FOR_STOP</a><br />
 <code>cb</code> will be called when STOP condition is generated. STOP condition will be generated at the end of the transaction. If HW_I2C_F_WAIT_FOR_STOP flag is not set <code>cb</code> will be called when the last byte has been written to the Tx FIFO.</p>
<p><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_w___i2_c.html#gacfb617be9d4503854630dc6e6d545027" title="Starts DMA transfer. ">hw_i2c_dma_start</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaad7bb04ff5cdba25f0a1b4076cb36f44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hw_i2c_read_buffer_async </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read multiple bytes from I2C slave asynchronously. </p>
<p>This function will read multiple bytes from bus taking care of RX FIFO control. This call is non-blocking and specified callback is called upon completion, with the operation status. The operation completes when the complete buffer is filled, or in case of a failure. In case of failure the failure cause must be read from the cb by calling <a class="el" href="group___h_w___i2_c.html#ga07ac8b942da9cc034ac5beb40d540c78" title="Get abort source. ">hw_i2c_get_abort_source()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Address of the buffer where data are stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback to be called upon completion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Data to pass to cb </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br />
 This flag can be used for consecutive calls where the transaction can resume without stop/start conditions in between.</p>
<p><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 in case of success, -1 otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used only when operating in master mode.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function registers an internal interrupt handler, which overrides any previously installed handler. Only for DA14680/1: When calling this function under an OS, it is possible to have a Tx FIFO underrun which results in a STOP sequence, due to OS preemption.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_w___i2_c.html#ga5944b69ca4fc9f378ca3c3f7f6740c80" title="Register interrupt handler. ">hw_i2c_register_int</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac735de8a924f7ebcc5eddf7a0094faf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_read_buffer_dma </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read multiple bytes from I2C bus using DMA. </p>
<p>This function uses the common callback type, which provides a way to signal whether the read finished successfully.</p>
<p>Shortcut for calling <a class="el" href="group___h_w___i2_c.html#gab7a5bfe7457313724023263d82204091" title="Prepares I2C DMA for transfer. ">hw_i2c_prepare_dma()</a> and <a class="el" href="group___h_w___i2_c.html#gacfb617be9d4503854630dc6e6d545027" title="Starts DMA transfer. ">hw_i2c_dma_start()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>DMA channel </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>buffer to put data read from I2C bus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of <code>buffer</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback for transfer completed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>data to pass to <code>cb</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br />
 This flag can be used for consecutive calls where the transaction can resume without stop/start conditions in between.</p>
<p><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_w___i2_c.html#gab7a5bfe7457313724023263d82204091" title="Prepares I2C DMA for transfer. ">hw_i2c_prepare_dma</a> </dd>
<dd>
<a class="el" href="group___h_w___i2_c.html#gacfb617be9d4503854630dc6e6d545027" title="Starts DMA transfer. ">hw_i2c_dma_start</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa18b3a881d304cb070b22d5b5eda821c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hw_i2c_read_buffer_sync </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___i2_c.html#gaf7ef8a80c9c6e53c3edf28cc5bf2007e">HW_I2C_ABORT_SOURCE</a> *&#160;</td>
          <td class="paramname"><em>abrt_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read multiple bytes from I2C slave synchronously. </p>
<p>This function will read multiple bytes from bus taking care of RX FIFO control. This call blocks until the operation completes. The operation completes when the complete buffer is filled, or in case of a failure. Failures are cleared by the function before returning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Address of the buffer where data are stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data buffer </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">abrt_code</td><td>If not NULL, the status of the operation based on <a class="el" href="group___h_w___i2_c.html#gaf7ef8a80c9c6e53c3edf28cc5bf2007e" title="I2C abort source. ">HW_I2C_ABORT_SOURCE</a> enumeration will be stored here </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br />
 This flag can be used for consecutive calls where the transaction can resume without stop/start conditions in between.</p>
<p><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used only when operating in master mode.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Only for DA14680/1: When calling this function under an OS, it is possible to have a Tx FIFO underrun which results in a STOP sequence, due to OS preemption. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0dc2a13d264888d9900aa0b2937adda2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint8_t hw_i2c_read_byte </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read single byte from RX FIFO. </p>
<p>It is caller's responsibility to ensure there is data to read in RX FIFO before calling this function by checking either <a class="el" href="group___h_w___i2_c.html#ga81090f2405c289d0ecd207ee96bad651" title="Get number of bytes in RX FIFO. ">hw_i2c_get_rx_fifo_level()</a> or hw_i2c_rx_fifo_not_empty().</p>
<p>This function can be used in both master and slave modes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>read byte</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_w___i2_c.html#ga81090f2405c289d0ecd207ee96bad651" title="Get number of bytes in RX FIFO. ">hw_i2c_get_rx_fifo_level</a> </dd>
<dd>
hw_i2c_rx_fifo_not_empty </dd></dl>

</div>
</div>
<a class="anchor" id="ga2ba745fbf5b2aa3fbb3bd19cfd16bfe3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_read_byte_trigger </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate reading from I2C bus. </p>
<p>No data is read via this call, only START/RESTART condition is generated on bus if required. Actual data is read by controller and put in RX FIFO which can be read using <a class="el" href="group___h_w___i2_c.html#ga0dc2a13d264888d9900aa0b2937adda2" title="Read single byte from RX FIFO. ">hw_i2c_read_byte()</a>.</p>
<p>This function should be only used when operating in master mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_w___i2_c.html#ga0dc2a13d264888d9900aa0b2937adda2" title="Read single byte from RX FIFO. ">hw_i2c_read_byte</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5944b69ca4fc9f378ca3c3f7f6740c80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_register_int </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___i2_c.html#ga07fb0d97fcc29f7d55b1846927d7ad18">hw_i2c_interrupt_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register interrupt handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>initial bitmask of requested interrupt events</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_w___i2_c.html#gabdc4ec9c80147b1c5b07b07374ea4165" title="Set bitmask of requested interrupt events. ">hw_i2c_set_int_mask</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa0490c49ca963197c4121a4340f4f868"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_register_slave_dma_read_callback </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register proper handling for DMA read in slave mode. </p>
<p>This function must be called after DMA has been setup for reading in slave mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_w___i2_c.html#gac735de8a924f7ebcc5eddf7a0094faf0" title="Read multiple bytes from I2C bus using DMA. ">hw_i2c_read_buffer_dma</a> </dd>
<dd>
<a class="el" href="group___h_w___i2_c.html#gab7a5bfe7457313724023263d82204091" title="Prepares I2C DMA for transfer. ">hw_i2c_prepare_dma</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaccce6c681f6b95ee85c84f511f6eb97f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_reset_abort_source </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset abort source. </p>
<p>This clears TX_ABORT interrupt status and unlocks TX FIFO.</p>
<dl class="section note"><dt>Note</dt><dd>this is an alias for <a class="el" href="group___h_w___i2_c.html#ga0f237147b1403e491c5c4c6d0d3396ff" title="Reset TX_ABORT interrupt state. ">hw_i2c_reset_int_tx_abort()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>I2C_ABORT_SOURCE </dd>
<dd>
<a class="el" href="group___h_w___i2_c.html#ga0f237147b1403e491c5c4c6d0d3396ff" title="Reset TX_ABORT interrupt state. ">hw_i2c_reset_int_tx_abort</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga10ccd98f55a6a813772c799bd3324f0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_reset_int_activity </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset ACTIVITY interrupt state. </p>
<p>Should be used to reset ACTIVITY interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga16e89d90f015b43269e6c49cfbba0ec4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_reset_int_all </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset all interrupt state. </p>
<p>This does reset all interrupts which can be reset by software and TX_ABORT status.</p>
<dl class="section warning"><dt>Warning</dt><dd>Although this also clears TX_ABORT it does not reset flushed state on TX FIFO. This has </dd>
<dd>
to be cleared manually using <a class="el" href="group___h_w___i2_c.html#gaccce6c681f6b95ee85c84f511f6eb97f" title="Reset abort source. ">hw_i2c_reset_abort_source()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_w___i2_c.html#gaccce6c681f6b95ee85c84f511f6eb97f" title="Reset abort source. ">hw_i2c_reset_abort_source</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gabf5b54df4c64480f521c2c163d0a8728"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_reset_int_gen_call </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset GENERAL_CALL interrupt state. </p>
<p>Should be used to reset GENERAL_CALL interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0ddda1add62f2cffb23e28367d1cefd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_reset_int_read_request </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset READ_REQUEST interrupt state. </p>
<p>Should be used to reset READ_REQUEST interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga97d7ed3f50914fc65a1d7614148726ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_reset_int_rx_done </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset RX_DONE interrupt state. </p>
<p>Should be used to reset RX_DONE interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8fbe57fcca5e406cd360e2e697af581a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_reset_int_rx_overflow </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset RX_OVERFLOW interrupt state. </p>
<p>Should be used to reset RX_OVERFLOW interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga788dd9d7200110f6c9541973859eb628"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_reset_int_rx_underflow </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset RX_UNDERFLOW interrupt state. </p>
<p>Should be used to reset RX_UNDERFLOW interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0a37c58f9dd3d45f9de6b611e9f65414"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_reset_int_start_detected </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset START_DETECTED interrupt state. </p>
<p>Should be used to reset START_DETECTED interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacd879383099d7176d124c638bf893b46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_reset_int_stop_detected </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset STOP_DETECTED interrupt state. </p>
<p>Should be used to reset STOP_DETECTED interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0f237147b1403e491c5c4c6d0d3396ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_reset_int_tx_abort </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset TX_ABORT interrupt state. </p>
<p>Should be used to reset TX_ABORT interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga718b3de7c09d4cb5daf6defe21716ed6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_reset_int_tx_overflow </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset TX_OVERFLOW interrupt state. </p>
<p>Should be used to reset TX_OVERFLOW interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa6f21d86041cba8208dcf4e074c457b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_set_general_call_ack_enabled </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set support for general call acknowledgment. </p>
<p>When enabled, controller will send ACK for general call address. This applies only to controller working in slave mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ack</td><td>acknowledgment status </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaa8485f620b01d639f087d62af51f6b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_set_general_call_enabled </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether General Call should be used to address slaves. </p>
<p>Can only be changed when controller is disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enabled</td><td>General Call status to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabdc4ec9c80147b1c5b07b07374ea4165"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_set_int_mask </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set bitmask of requested interrupt events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>bitmask of requested interrupt events</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>I2C_INT </dd></dl>

</div>
</div>
<a class="anchor" id="ga944b02f60bac146f8ffa8a6bddae0c29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_set_mode </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___i2_c.html#gadf7ffb060052bb9ac0c167835afcc910">HW_I2C_MODE</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set I2C controller mode. </p>
<p>Can be only set when controller is disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>mode to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab43a88609634e5a8637877e28319a8e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_set_restart_enabled </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether RESTART conditions may be sent when acting as master. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enabled</td><td>RESTART status to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab0dada4da100a5c513ce4389036457ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_set_rx_fifo_threshold </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set threshold level on RX FIFO. </p>
<p>An interrupt will be generated once number of entries in RX FIFO is greater than <code>level</code>. This cannot be set to value greater than HW_I2C_FIFO_DEPTH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>threshold </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaec79c526d73e88d31fc45d3017954969"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_set_slave_address </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set slave address in slave mode. </p>
<p>Can be only set when controller is disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>slave address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga36fe411eb2e961228493ef77a061f158"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_set_slave_addressing_mode </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___i2_c.html#ga8c4b473a8fcb034aaabd8d2c7cf9c6bd">HW_I2C_ADDRESSING</a>&#160;</td>
          <td class="paramname"><em>addr_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set slave addressing mode in slave mode. </p>
<p>Can be only set when controller is disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_mode</td><td>mode of addressing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga93e9a3a4c278669d66a31a0abd444812"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_set_slave_callback </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___i2_c.html#gaf953d4d6f6b9465dcc65d369b4bcb2bd">hw_i2c_event_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup callback function for operation in slave mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback for events </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga93bd9d48dd2c754d4305b3adf965c54d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_set_speed </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___i2_c.html#ga4cbcaaa7663a2cbba9418cdb5aab66d9">HW_I2C_SPEED</a>&#160;</td>
          <td class="paramname"><em>speed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set I2C interface bus speed. </p>
<p>Can be only set when controller is disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">speed</td><td>speed to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab808b7a790080603e8ada092c8167b4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_set_target_address </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set target slave address in master mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>slave address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3f7450ab438b35f90fb088404fa92805"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_set_target_addressing_mode </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___i2_c.html#ga8c4b473a8fcb034aaabd8d2c7cf9c6bd">HW_I2C_ADDRESSING</a>&#160;</td>
          <td class="paramname"><em>addr_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set target slave addressing mode in master mode. </p>
<p>Can only be changed when controller is disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_mode</td><td>mode of addressing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6b461e0a63739e1310b68ac2a4d6a7b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_set_tx_fifo_threshold </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set threshold level on TX FIFO. </p>
<p>An interrupt will be generated once number of entries in TX FIFO is less or equal to <code>level</code>. This cannot be set to value greater than HW_I2C_FIFO_DEPTH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>threshold </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2a29630b78ef7e94a3392bde6e15ca08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_setup_master </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___i2_c.html#ga8c4b473a8fcb034aaabd8d2c7cf9c6bd">HW_I2C_ADDRESSING</a>&#160;</td>
          <td class="paramname"><em>addr_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup controller for operation in master mode. </p>
<p>Shortcut for calling <a class="el" href="group___h_w___i2_c.html#ga944b02f60bac146f8ffa8a6bddae0c29" title="Set I2C controller mode. ">hw_i2c_set_mode()</a>, <a class="el" href="group___h_w___i2_c.html#ga3f7450ab438b35f90fb088404fa92805" title="Set target slave addressing mode in master mode. ">hw_i2c_set_target_addressing_mode()</a> and <a class="el" href="group___h_w___i2_c.html#gab808b7a790080603e8ada092c8167b4f" title="Set target slave address in master mode. ">hw_i2c_set_target_address()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_mode</td><td>mode of addressing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>target slave address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabfb7542e60f661193ed1fc82df545586"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_setup_slave </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___i2_c.html#ga8c4b473a8fcb034aaabd8d2c7cf9c6bd">HW_I2C_ADDRESSING</a>&#160;</td>
          <td class="paramname"><em>addr_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___i2_c.html#gaf953d4d6f6b9465dcc65d369b4bcb2bd">hw_i2c_event_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup controller for operation in slave mode. </p>
<p>Shortcut for calling <a class="el" href="group___h_w___i2_c.html#ga944b02f60bac146f8ffa8a6bddae0c29" title="Set I2C controller mode. ">hw_i2c_set_mode()</a>, <a class="el" href="group___h_w___i2_c.html#ga36fe411eb2e961228493ef77a061f158" title="Set slave addressing mode in slave mode. ">hw_i2c_set_slave_addressing_mode()</a> and <a class="el" href="group___h_w___i2_c.html#gaec79c526d73e88d31fc45d3017954969" title="Set slave address in slave mode. ">hw_i2c_set_slave_address()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_mode</td><td>mode of addressing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>slave address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback for events</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_w___i2_c.html#ga944b02f60bac146f8ffa8a6bddae0c29" title="Set I2C controller mode. ">hw_i2c_set_mode</a> </dd>
<dd>
<a class="el" href="group___h_w___i2_c.html#ga36fe411eb2e961228493ef77a061f158" title="Set slave addressing mode in slave mode. ">hw_i2c_set_slave_addressing_mode</a> </dd>
<dd>
<a class="el" href="group___h_w___i2_c.html#gaec79c526d73e88d31fc45d3017954969" title="Set slave address in slave mode. ">hw_i2c_set_slave_address</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5fe2293421ca1305ff40efe8e0f3ff6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_unregister_int </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister interrupt handler. </p>
<p>This function disables all I2C interrupts by masking them. In addition it clears any pending ones on the ARM core. The status of RAW_INTR_STAT_REG remains unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf4f644c258dfd1dd0c3c5df464733d21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hw_i2c_write_buffer_async </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write multiple bytes to I2C slave asynchronously. </p>
<p>Writes array of data to a slave device on the I2C bus via the TX FIFO. This call is non-blocking and specified callback is called upon completion, with the operation status. In case of failure the failure cause must be read from the cb by calling <a class="el" href="group___h_w___i2_c.html#ga07ac8b942da9cc034ac5beb40d540c78" title="Get abort source. ">hw_i2c_get_abort_source()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Address of the buffer containing the data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback to be called upon completion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Data to pass to cb </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br />
 The cb will be called as soon as the last byte of data is written to the Tx FIFO. Possible Tx failure after this point must be checked by the caller. This flag can be used for consecutive calls where the transaction can resume without stop/start conditions in between.</p>
<p><a class="el" href="group___h_w___i2_c.html#ga561070559a39fe8aa62f839207c5e5b7">HW_I2C_F_WAIT_FOR_STOP</a><br />
 The callback will be called when all bytes have been transmitted and a STOP condition has been generated.</p>
<p><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 in case of success, -1 otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used only when operating in master mode.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function registers an internal interrupt handler, which overrides any previously installed handler. Only for DA14680/1: When calling this function under an OS, it is possible to have a Tx FIFO underrun which results in a STOP sequence, due to OS preemption.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_w___i2_c.html#ga5944b69ca4fc9f378ca3c3f7f6740c80" title="Register interrupt handler. ">hw_i2c_register_int</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0093fa24296f69f2ec83da50aea34332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_write_buffer_dma </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write multiple bytes on I2C bus using DMA. </p>
<p>Shortcut for calling <a class="el" href="group___h_w___i2_c.html#gab7a5bfe7457313724023263d82204091" title="Prepares I2C DMA for transfer. ">hw_i2c_prepare_dma()</a> and <a class="el" href="group___h_w___i2_c.html#gacfb617be9d4503854630dc6e6d545027" title="Starts DMA transfer. ">hw_i2c_dma_start()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>DMA channel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>buffer to write data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of <code>buffer</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback for transfer completed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>data to pass to <code>cb</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br />
 This flag can be used for consecutive calls where the transaction can resume without stop/start conditions in between.</p>
<p><a class="el" href="group___h_w___i2_c.html#ga561070559a39fe8aa62f839207c5e5b7">HW_I2C_F_WAIT_FOR_STOP</a><br />
 <code>cb</code> will be called when STOP condition is generated. STOP condition will be generated at the end of the transaction. If HW_I2C_F_WAIT_FOR_STOP flag is not set <code>cb</code> will be called when the last byte has been written to the Tx FIFO.</p>
<p><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_w___i2_c.html#gab7a5bfe7457313724023263d82204091" title="Prepares I2C DMA for transfer. ">hw_i2c_prepare_dma</a> </dd>
<dd>
<a class="el" href="group___h_w___i2_c.html#gacfb617be9d4503854630dc6e6d545027" title="Starts DMA transfer. ">hw_i2c_dma_start</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e5e57db2f2b5eafe39c3efc2a752f09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hw_i2c_write_buffer_sync </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___i2_c.html#gaf7ef8a80c9c6e53c3edf28cc5bf2007e">HW_I2C_ABORT_SOURCE</a> *&#160;</td>
          <td class="paramname"><em>abrt_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write multiple bytes to I2C slave synchronously. </p>
<p>Writes array of data to a slave device on the I2C bus via the TX FIFO. This call blocks until the operation completes. In case of failure the function stores the Tx error code to the abrt_code parameter -if provided- and clears the Tx Abort register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Address of the buffer containing the data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data buffer </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">abrt_code</td><td>If not NULL, the status of the operation based on <a class="el" href="group___h_w___i2_c.html#gaf7ef8a80c9c6e53c3edf28cc5bf2007e" title="I2C abort source. ">HW_I2C_ABORT_SOURCE</a> enumeration will be stored here </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br />
 The function will return only when all bytes have been transmitted. Possible Tx failure after this point must be checked by the caller. This flag can be used for consecutive calls where the transaction can resume without stop/start conditions in between.</p>
<p><a class="el" href="group___h_w___i2_c.html#ga561070559a39fe8aa62f839207c5e5b7">HW_I2C_F_WAIT_FOR_STOP</a><br />
 The function will return only when all bytes have been transmitted and a STOP condition has been generated.</p>
<p><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written to the Tx FIFO. It is strongly recommended to check the value of abrt_code to make sure that the number of bytes returned were actually transmitted to the I2C bus.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used only when operating in master mode.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Only for DA14680/1: When calling this function under an OS, it is possible to have a Tx FIFO underrun which results in a STOP sequence, due to OS preemption. </dd></dl>

</div>
</div>
<a class="anchor" id="ga01e8777fff2beda6b7e3823fba2548d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void hw_i2c_write_byte </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write single byte into TX FIFO. </p>
<p>It is caller's responsibility to ensure there is free space in TX FIFO before calling this function - either <a class="el" href="group___h_w___i2_c.html#ga1efff1212c20d381d6916c7511912dbc" title="Check if TX FIFO is not full. ">hw_i2c_is_tx_fifo_not_full()</a> or <a class="el" href="group___h_w___i2_c.html#gaf3580f5534d5d1fb3b86fa19911bc695" title="Get number of bytes in TX FIFO. ">hw_i2c_get_tx_fifo_level()</a> can be used for this purpose.</p>
<p>This function can be used in both master and slave modes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">byte</td><td>data to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does not check for errors during transmission. Use <a class="el" href="group___h_w___i2_c.html#ga2e5e57db2f2b5eafe39c3efc2a752f09" title="Write multiple bytes to I2C slave synchronously. ">hw_i2c_write_buffer_sync()</a> or <a class="el" href="group___h_w___i2_c.html#gaf4f644c258dfd1dd0c3c5df464733d21" title="Write multiple bytes to I2C slave asynchronously. ">hw_i2c_write_buffer_async()</a> instead </dd></dl>

</div>
</div>
<a class="anchor" id="ga427b041327ec43abc52c7f6d74a739e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hw_i2c_write_then_read_async </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>w_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>w_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>r_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>r_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write then read multiple bytes from I2C slave. </p>
<p>This function allows to perform typical I2C transaction. This call is non-blocking and specified callback is called upon completion, with the operation status. In case of failure the failure cause must be read from the cb by calling <a class="el" href="group___h_w___i2_c.html#ga07ac8b942da9cc034ac5beb40d540c78" title="Get abort source. ">hw_i2c_get_abort_source()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w_data</td><td>Address of the buffer containing the data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w_len</td><td>Length of the buffer containing the data to write </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">r_data</td><td>Address of the buffer where data will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_len</td><td>Length of the buffer where data will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback to be called upon completion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Data to pass to cb </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___h_w___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br />
 This flag can be used for consecutive calls where the transaction can resume without stop/start conditions in between.</p>
<p><a class="el" href="group___h_w___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14680/1 since STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___h_w___i2_c.html#gaf600a3324a7a01bce204dc8946cd9731">HW_I2C_F_ADD_RESTART</a><br />
 RESTART condition will be generated at the beginning of the transaction. HW_I2C_F_ADD_RESTART is not supported in DA14680/1. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 in case of success, -1 otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used only when operating in master mode.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function registers an internal interrupt handler, which overrides any previously installed handler. Only for DA14680/1: When calling this function under an OS, it is possible to have a Tx FIFO underrun which results in a STOP sequence, due to OS preemption.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_w___i2_c.html#ga5944b69ca4fc9f378ca3c3f7f6740c80" title="Register interrupt handler. ">hw_i2c_register_int</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jul 7 2020 07:10:51 for SmartSnippets DA1469x SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>

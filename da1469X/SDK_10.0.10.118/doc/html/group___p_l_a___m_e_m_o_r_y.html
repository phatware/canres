<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>SmartSnippets DA1469x SDK: QSPI Flash Memory Devices</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1469x SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Board&#160;and&#160;Applications&#160;General&#160;Info</span></a></li>
      <li><a href="modules.html"><span>SDK&#160;Architecture</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">QSPI Flash Memory Devices<div class="ingroups"><a class="el" href="group___p_l_a_t_f_o_r_m___d_e_v_i_c_e.html">Platform/Device</a> &raquo; <a class="el" href="group___p_l_a___b_s_p.html">BSP (Board Support Package)</a> &raquo; <a class="el" href="group___p_l_a___b_s_p___s_y_s_t_e_m.html">System Configuration</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Configuration values for the various supported qspi devices.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:psram__aps1604jsq_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="psram__aps1604jsq_8h.html">psram_aps1604jsq.h</a></td></tr>
<tr class="memdesc:psram__aps1604jsq_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI ram driver for aps1604jsq. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:psram__aps3204jsq_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="psram__aps3204jsq_8h.html">psram_aps3204jsq.h</a></td></tr>
<tr class="memdesc:psram__aps3204jsq_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI ram driver for aps3204jsq. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:psram__aps6404jsq_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="psram__aps6404jsq_8h.html">psram_aps6404jsq.h</a></td></tr>
<tr class="memdesc:psram__aps6404jsq_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI ram driver for aps6404jsq. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__apmemory_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__apmemory_8h.html">qspi_apmemory.h</a></td></tr>
<tr class="memdesc:qspi__apmemory_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI driver for AP Memory PSRAMs - common code. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__at25ff321a_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__at25ff321a_8h.html">qspi_at25ff321a.h</a></td></tr>
<tr class="memdesc:qspi__at25ff321a_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver for flash ADESTO AT25FF321A. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__at25sl321_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__at25sl321_8h.html">qspi_at25sl321.h</a></td></tr>
<tr class="memdesc:qspi__at25sl321_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver for flash ADESTO AT25SL321. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__automode_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__automode_8h.html">qspi_automode.h</a></td></tr>
<tr class="memdesc:qspi__automode_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access QSPI device when running in auto mode. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__common_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__common_8h.html">qspi_common.h</a></td></tr>
<tr class="memdesc:qspi__common_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver common definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__gd25le32_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__gd25le32_8h.html">qspi_gd25le32.h</a></td></tr>
<tr class="memdesc:qspi__gd25le32_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver for the GigaDevice GD25LE32. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__gigadevice_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__gigadevice_8h.html">qspi_gigadevice.h</a></td></tr>
<tr class="memdesc:qspi__gigadevice_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver for Gigadevice flashes - common code. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__macronix_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__macronix_8h.html">qspi_macronix.h</a></td></tr>
<tr class="memdesc:qspi__macronix_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver for Macronix flashes - common code. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__mx25u3235_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__mx25u3235_8h.html">qspi_mx25u3235.h</a></td></tr>
<tr class="memdesc:qspi__mx25u3235_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver for the Macronix MX25U3235. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__w25q32fw_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__w25q32fw_8h.html">qspi_w25q32fw.h</a></td></tr>
<tr class="memdesc:qspi__w25q32fw_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver for the Winbond W25Q32FW. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__winbond_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__winbond_8h.html">qspi_winbond.h</a></td></tr>
<tr class="memdesc:qspi__winbond_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver for Winbond flashes - common code. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi___x_x_x__template_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi___x_x_x__template_8h.html">qspi_XXX_template.h</a></td></tr>
<tr class="memdesc:qspi___x_x_x__template_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver for flash XXXX. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqspi__flash__config.html">qspi_flash_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI Flash configuration structure.  <a href="structqspi__flash__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gacb6745c33d23a6ee71eeaea8b9dda828"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gacb6745c33d23a6ee71eeaea8b9dda828">ADESTO_ID</a>&#160;&#160;&#160;0x1F</td></tr>
<tr class="memdesc:gacb6745c33d23a6ee71eeaea8b9dda828"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Flash type JEDEC ID.  <a href="#gacb6745c33d23a6ee71eeaea8b9dda828">More...</a><br /></td></tr>
<tr class="separator:gacb6745c33d23a6ee71eeaea8b9dda828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72f54ad0a6bb563f1db1284258340cc0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga72f54ad0a6bb563f1db1284258340cc0">AT25FF321A_TYPE</a>&#160;&#160;&#160;0x47</td></tr>
<tr class="memdesc:ga72f54ad0a6bb563f1db1284258340cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Flash type JEDEC ID.  <a href="#ga72f54ad0a6bb563f1db1284258340cc0">More...</a><br /></td></tr>
<tr class="separator:ga72f54ad0a6bb563f1db1284258340cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1c1df9af42d8b10edacab947c0c9004"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gad1c1df9af42d8b10edacab947c0c9004">AT25FF321A_SIZE</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="memdesc:gad1c1df9af42d8b10edacab947c0c9004"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Flash density JEDEC ID.  <a href="#gad1c1df9af42d8b10edacab947c0c9004">More...</a><br /></td></tr>
<tr class="separator:gad1c1df9af42d8b10edacab947c0c9004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb6745c33d23a6ee71eeaea8b9dda828"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gacb6745c33d23a6ee71eeaea8b9dda828">ADESTO_ID</a>&#160;&#160;&#160;0x1F</td></tr>
<tr class="memdesc:gacb6745c33d23a6ee71eeaea8b9dda828"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Flash type JEDEC ID.  <a href="#gacb6745c33d23a6ee71eeaea8b9dda828">More...</a><br /></td></tr>
<tr class="separator:gacb6745c33d23a6ee71eeaea8b9dda828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad120f9c1bc5fee08c9020c07a4ecabf9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gad120f9c1bc5fee08c9020c07a4ecabf9">AT25SL_TYPE</a>&#160;&#160;&#160;0x42</td></tr>
<tr class="memdesc:gad120f9c1bc5fee08c9020c07a4ecabf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Flash type JEDEC ID.  <a href="#gad120f9c1bc5fee08c9020c07a4ecabf9">More...</a><br /></td></tr>
<tr class="separator:gad120f9c1bc5fee08c9020c07a4ecabf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c5e6481bd16f58441b1213663edd70c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga8c5e6481bd16f58441b1213663edd70c">AT25SL321_SIZE</a>&#160;&#160;&#160;0x16</td></tr>
<tr class="memdesc:ga8c5e6481bd16f58441b1213663edd70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Flash density JEDEC ID.  <a href="#ga8c5e6481bd16f58441b1213663edd70c">More...</a><br /></td></tr>
<tr class="separator:ga8c5e6481bd16f58441b1213663edd70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8cf118323b91b1be085f266a2267c1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf8cf118323b91b1be085f266a2267c1e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaf8cf118323b91b1be085f266a2267c1e">FLASH_SUS_DELAY</a>&#160;&#160;&#160;(20)</td></tr>
<tr class="memdesc:gaf8cf118323b91b1be085f266a2267c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay after SUSPEND command (in μsec) <br /></td></tr>
<tr class="separator:gaf8cf118323b91b1be085f266a2267c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd340ff3bc4ce58ba3b00326710c2b80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafd340ff3bc4ce58ba3b00326710c2b80"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gafd340ff3bc4ce58ba3b00326710c2b80">FLASH_RES_DELAY</a>&#160;&#160;&#160;(20)</td></tr>
<tr class="memdesc:gafd340ff3bc4ce58ba3b00326710c2b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay after RESUME command (in μsec) <br /></td></tr>
<tr class="separator:gafd340ff3bc4ce58ba3b00326710c2b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e232980f124b71e3065dc86afcb746f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9e232980f124b71e3065dc86afcb746f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga9e232980f124b71e3065dc86afcb746f">FLASH_RST_DELAY</a>&#160;&#160;&#160;(12000)</td></tr>
<tr class="memdesc:ga9e232980f124b71e3065dc86afcb746f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay after RESET command (in μsec) <br /></td></tr>
<tr class="separator:ga9e232980f124b71e3065dc86afcb746f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga230871cbef94a3328fdcda1f87dd2bde"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga230871cbef94a3328fdcda1f87dd2bde">XXXXX_ID</a>&#160;&#160;&#160;0xFF</td></tr>
<tr class="memdesc:ga230871cbef94a3328fdcda1f87dd2bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Flash vendor JEDEC ID.  <a href="#ga230871cbef94a3328fdcda1f87dd2bde">More...</a><br /></td></tr>
<tr class="separator:ga230871cbef94a3328fdcda1f87dd2bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e4a1a837d547365760bd32ebc664e84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga8e4a1a837d547365760bd32ebc664e84">XXXXX</a>&#160;&#160;&#160;0xFF</td></tr>
<tr class="memdesc:ga8e4a1a837d547365760bd32ebc664e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Flash type JEDEC ID.  <a href="#ga8e4a1a837d547365760bd32ebc664e84">More...</a><br /></td></tr>
<tr class="separator:ga8e4a1a837d547365760bd32ebc664e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f22a9fb53cdeabb03c8b173b93822ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga6f22a9fb53cdeabb03c8b173b93822ab">XXXXX_SIZE</a>&#160;&#160;&#160;0xFF</td></tr>
<tr class="memdesc:ga6f22a9fb53cdeabb03c8b173b93822ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Flash density JEDEC ID.  <a href="#ga6f22a9fb53cdeabb03c8b173b93822ab">More...</a><br /></td></tr>
<tr class="separator:ga6f22a9fb53cdeabb03c8b173b93822ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaaca7b42888b10ca3e05786453609d0d3"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structqspi__flash__config.html">qspi_flash_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaaca7b42888b10ca3e05786453609d0d3">qspi_flash_config_t</a></td></tr>
<tr class="memdesc:gaaca7b42888b10ca3e05786453609d0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI Flash configuration structure.  <a href="#gaaca7b42888b10ca3e05786453609d0d3">More...</a><br /></td></tr>
<tr class="separator:gaaca7b42888b10ca3e05786453609d0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaffec894ee6f1f45260e72f3bf57b5608"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaffec894ee6f1f45260e72f3bf57b5608"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaffec894ee6f1f45260e72f3bf57b5608">AT25FF321A_STATUS_REG</a> </td></tr>
<tr class="memdesc:gaffec894ee6f1f45260e72f3bf57b5608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash Status Registers. <br /></td></tr>
<tr class="separator:gaffec894ee6f1f45260e72f3bf57b5608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f77846abda0a0fb42506063697b31f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2f77846abda0a0fb42506063697b31f6"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga2f77846abda0a0fb42506063697b31f6">AT25FF321A_OP_FREQ_EB</a> </td></tr>
<tr class="memdesc:ga2f77846abda0a0fb42506063697b31f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy Cycles Bit value set of Status Register 5 for EBh at each Operating Frequency according to the Datasheet. <br /></td></tr>
<tr class="separator:ga2f77846abda0a0fb42506063697b31f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8f146c23ecc49ee6a02663d8feac2189"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga8f146c23ecc49ee6a02663d8feac2189">flash_at25ff321a_enable_quad_mode</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:ga8f146c23ecc49ee6a02663d8feac2189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Quad Enable Bit of the Status Register if it is not already set.  <a href="#ga8f146c23ecc49ee6a02663d8feac2189">More...</a><br /></td></tr>
<tr class="separator:ga8f146c23ecc49ee6a02663d8feac2189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga925308084233a6494cb37bc2d76f057b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga925308084233a6494cb37bc2d76f057b">flash_at25ff321a_enable_XiP_and_DPD_mode</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:ga925308084233a6494cb37bc2d76f057b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the XiP Bit of the Status Register 4 if it is not already set.  <a href="#ga925308084233a6494cb37bc2d76f057b">More...</a><br /></td></tr>
<tr class="separator:ga925308084233a6494cb37bc2d76f057b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77962d11705451d28241f969096f11cc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga77962d11705451d28241f969096f11cc">flash_at25ff321a_get_dummy_bytes</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:ga77962d11705451d28241f969096f11cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the dummy bytes required when utilizing Fast Read Quad.  <a href="#ga77962d11705451d28241f969096f11cc">More...</a><br /></td></tr>
<tr class="separator:ga77962d11705451d28241f969096f11cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafac598dd4dadf54eadc355c7646e63c5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gafac598dd4dadf54eadc355c7646e63c5">flash_at25ff321a_initialize</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:gafac598dd4dadf54eadc355c7646e63c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize AT25FF321A QSPI Flash.  <a href="#gafac598dd4dadf54eadc355c7646e63c5">More...</a><br /></td></tr>
<tr class="separator:gafac598dd4dadf54eadc355c7646e63c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c71c52f2cf8a39c5c889e58beb77505"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga7c71c52f2cf8a39c5c889e58beb77505">flash_at25ff321a_is_suspended</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:ga7c71c52f2cf8a39c5c889e58beb77505"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns true if an erase or program operation is already suspended.  <a href="#ga7c71c52f2cf8a39c5c889e58beb77505">More...</a><br /></td></tr>
<tr class="separator:ga7c71c52f2cf8a39c5c889e58beb77505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41cce88a1b387d99a13017726ff1ff9d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga41cce88a1b387d99a13017726ff1ff9d">flash_at25ff321a_read_status_register_2</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:ga41cce88a1b387d99a13017726ff1ff9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the Status Register 2 of the Flash.  <a href="#ga41cce88a1b387d99a13017726ff1ff9d">More...</a><br /></td></tr>
<tr class="separator:ga41cce88a1b387d99a13017726ff1ff9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46751b6258f19e79b120f63d0345eb83"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga46751b6258f19e79b120f63d0345eb83">flash_at25ff321a_read_status_register_indirect</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id, uint8_t reg)</td></tr>
<tr class="memdesc:ga46751b6258f19e79b120f63d0345eb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indirectly read the targetted Status Register of the Flash.  <a href="#ga46751b6258f19e79b120f63d0345eb83">More...</a><br /></td></tr>
<tr class="separator:ga46751b6258f19e79b120f63d0345eb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccd9780a2ee60d6092d67aa3bd00290f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaccd9780a2ee60d6092d67aa3bd00290f">flash_at25ff321a_set_dummy_cycles</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id, bool set_non_volatile, <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga2f77846abda0a0fb42506063697b31f6">AT25FF321A_OP_FREQ_EB</a> d_cycles)</td></tr>
<tr class="memdesc:gaccd9780a2ee60d6092d67aa3bd00290f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of Dummy Cycles for AT25FF321A.  <a href="#gaccd9780a2ee60d6092d67aa3bd00290f">More...</a><br /></td></tr>
<tr class="separator:gaccd9780a2ee60d6092d67aa3bd00290f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8800aba2f7517960e6dc679ddbaccba"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaa8800aba2f7517960e6dc679ddbaccba">flash_at25ff321a_set_initial_boot_state</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:gaa8800aba2f7517960e6dc679ddbaccba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the initial number of Dummy Cycles for AT25FF321A.  <a href="#gaa8800aba2f7517960e6dc679ddbaccba">More...</a><br /></td></tr>
<tr class="separator:gaa8800aba2f7517960e6dc679ddbaccba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dbe0bec3278c3fcb995eec4ff491d77"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga5dbe0bec3278c3fcb995eec4ff491d77">flash_at25ff321a_sys_clock_cfg</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id, <a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> sys_clk)</td></tr>
<tr class="memdesc:ga5dbe0bec3278c3fcb995eec4ff491d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook function called when the clock is changed.  <a href="#ga5dbe0bec3278c3fcb995eec4ff491d77">More...</a><br /></td></tr>
<tr class="separator:ga5dbe0bec3278c3fcb995eec4ff491d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed5b58d37e657b220e229a11703f6dee"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaed5b58d37e657b220e229a11703f6dee">flash_at25ff321a_volatile_write_enable</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:gaed5b58d37e657b220e229a11703f6dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set WEL (Write Enable Latch) bit of the Volatile version of the Status Register of the Flash.  <a href="#gaed5b58d37e657b220e229a11703f6dee">More...</a><br /></td></tr>
<tr class="separator:gaed5b58d37e657b220e229a11703f6dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4cfba5711a05ed3432db2c516e8a39b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gae4cfba5711a05ed3432db2c516e8a39b">flash_at25ff321a_write_status_register_2</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id, uint8_t value)</td></tr>
<tr class="memdesc:gae4cfba5711a05ed3432db2c516e8a39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the Status Register 2 of the Flash.  <a href="#gae4cfba5711a05ed3432db2c516e8a39b">More...</a><br /></td></tr>
<tr class="separator:gae4cfba5711a05ed3432db2c516e8a39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa768488c3a2e5aaa03283238cd90b7c5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaa768488c3a2e5aaa03283238cd90b7c5">flash_at25ff321a_write_status_register_indirect</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id, uint8_t reg, uint8_t value)</td></tr>
<tr class="memdesc:gaa768488c3a2e5aaa03283238cd90b7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indirectly write the targetted Status Register of the Flash.  <a href="#gaa768488c3a2e5aaa03283238cd90b7c5">More...</a><br /></td></tr>
<tr class="separator:gaa768488c3a2e5aaa03283238cd90b7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24058c32882183c2f3d9117c94e2a418"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga24058c32882183c2f3d9117c94e2a418">flash_at25sl321_enable_quad_mode</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:ga24058c32882183c2f3d9117c94e2a418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Quad Enable Bit of the Status Register if it is not already set.  <a href="#ga24058c32882183c2f3d9117c94e2a418">More...</a><br /></td></tr>
<tr class="separator:ga24058c32882183c2f3d9117c94e2a418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae75eae068642c5da78a0ce01a9ceae1e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gae75eae068642c5da78a0ce01a9ceae1e">flash_at25sl321_get_dummy_bytes</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:gae75eae068642c5da78a0ce01a9ceae1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the dummy bytes required when utilizing Fast Read Quad.  <a href="#gae75eae068642c5da78a0ce01a9ceae1e">More...</a><br /></td></tr>
<tr class="separator:gae75eae068642c5da78a0ce01a9ceae1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf7ba823ab7fa7895c20037b769e528a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gabf7ba823ab7fa7895c20037b769e528a">flash_at25sl321_initialize</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:gabf7ba823ab7fa7895c20037b769e528a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize AT25SL321 QSPI Flash.  <a href="#gabf7ba823ab7fa7895c20037b769e528a">More...</a><br /></td></tr>
<tr class="separator:gabf7ba823ab7fa7895c20037b769e528a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51759ea3b92dfd88a618b19fc512cd1c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga51759ea3b92dfd88a618b19fc512cd1c">flash_at25sl321_is_suspended</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:ga51759ea3b92dfd88a618b19fc512cd1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns true if an erase or program operation is already suspended.  <a href="#ga51759ea3b92dfd88a618b19fc512cd1c">More...</a><br /></td></tr>
<tr class="separator:ga51759ea3b92dfd88a618b19fc512cd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7234c98f04254f142684c6757b7e49b2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga7234c98f04254f142684c6757b7e49b2">flash_at25sl321_read_status_register_2</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:ga7234c98f04254f142684c6757b7e49b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the Status Register 2 of the Flash.  <a href="#ga7234c98f04254f142684c6757b7e49b2">More...</a><br /></td></tr>
<tr class="separator:ga7234c98f04254f142684c6757b7e49b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa319dd3aadb27e6b42e3a61e2dfec43"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gafa319dd3aadb27e6b42e3a61e2dfec43">flash_at25sl321_sys_clock_cfg</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id, <a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> sys_clk)</td></tr>
<tr class="memdesc:gafa319dd3aadb27e6b42e3a61e2dfec43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook function called when the clock is changed.  <a href="#gafa319dd3aadb27e6b42e3a61e2dfec43">More...</a><br /></td></tr>
<tr class="separator:gafa319dd3aadb27e6b42e3a61e2dfec43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d13e1908fd0b742b3d6c6648151b3b6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga2d13e1908fd0b742b3d6c6648151b3b6">flash_at25sl321_write_status_register_2</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id, uint8_t value)</td></tr>
<tr class="memdesc:ga2d13e1908fd0b742b3d6c6648151b3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the Status Register 2 of the Flash.  <a href="#ga2d13e1908fd0b742b3d6c6648151b3b6">More...</a><br /></td></tr>
<tr class="separator:ga2d13e1908fd0b742b3d6c6648151b3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec10550774f00ae313483c48000253cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaec10550774f00ae313483c48000253cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaec10550774f00ae313483c48000253cc">qspi_operations_init</a> (void)</td></tr>
<tr class="memdesc:gaec10550774f00ae313483c48000253cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize background Flash operations. <br /></td></tr>
<tr class="separator:gaec10550774f00ae313483c48000253cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b3bcb6f4a8d0e17144bf0edce4d4d8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga2b3bcb6f4a8d0e17144bf0edce4d4d8d">qspi_process_operations</a> (void)</td></tr>
<tr class="memdesc:ga2b3bcb6f4a8d0e17144bf0edce4d4d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute any pending QSPI program / erase operations.  <a href="#ga2b3bcb6f4a8d0e17144bf0edce4d4d8d">More...</a><br /></td></tr>
<tr class="separator:ga2b3bcb6f4a8d0e17144bf0edce4d4d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbc75c9e1e14d777ff709365c240fd70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gacbc75c9e1e14d777ff709365c240fd70">qspi_check_and_suspend_operations</a> (void)</td></tr>
<tr class="memdesc:gacbc75c9e1e14d777ff709365c240fd70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend a Flash program or erase operation.  <a href="#gacbc75c9e1e14d777ff709365c240fd70">More...</a><br /></td></tr>
<tr class="separator:gacbc75c9e1e14d777ff709365c240fd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac09116c0f4b50220906b0fb11ec4ffbc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac09116c0f4b50220906b0fb11ec4ffbc"></a>
<a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gac09116c0f4b50220906b0fb11ec4ffbc">qspi_process_completed_operations</a> (void)</td></tr>
<tr class="memdesc:gac09116c0f4b50220906b0fb11ec4ffbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify tasks waiting for Flash operations that they have been completed. <br /></td></tr>
<tr class="separator:gac09116c0f4b50220906b0fb11ec4ffbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d9bb478f93a3613dad89f84c3f50b8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga3d9bb478f93a3613dad89f84c3f50b8c">qspi_is_op_pending</a> (void)</td></tr>
<tr class="memdesc:ga3d9bb478f93a3613dad89f84c3f50b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there is a pending background Flash operation.  <a href="#ga3d9bb478f93a3613dad89f84c3f50b8c">More...</a><br /></td></tr>
<tr class="separator:ga3d9bb478f93a3613dad89f84c3f50b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eb0ffc532fe27b4ea3fa4af9b5fdc2f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga2eb0ffc532fe27b4ea3fa4af9b5fdc2f">qspi_automode_write_flash_page</a> (uint32_t addr, const uint8_t *buf, uint32_t size)</td></tr>
<tr class="memdesc:ga2eb0ffc532fe27b4ea3fa4af9b5fdc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write flash memory.  <a href="#ga2eb0ffc532fe27b4ea3fa4af9b5fdc2f">More...</a><br /></td></tr>
<tr class="separator:ga2eb0ffc532fe27b4ea3fa4af9b5fdc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcd4cecdf5349007b99b3e17e4306f36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gafcd4cecdf5349007b99b3e17e4306f36">qspi_automode_erase_flash_sector</a> (uint32_t addr)</td></tr>
<tr class="memdesc:gafcd4cecdf5349007b99b3e17e4306f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase flash sector.  <a href="#gafcd4cecdf5349007b99b3e17e4306f36">More...</a><br /></td></tr>
<tr class="separator:gafcd4cecdf5349007b99b3e17e4306f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9defebf9434bef90daeb8bd682c9e0de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9defebf9434bef90daeb8bd682c9e0de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga9defebf9434bef90daeb8bd682c9e0de">qspi_automode_erase_chip</a> (void)</td></tr>
<tr class="memdesc:ga9defebf9434bef90daeb8bd682c9e0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase whole chip. <br /></td></tr>
<tr class="separator:ga9defebf9434bef90daeb8bd682c9e0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f21b8d5ce8231d137b0ef88c8f17a4f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga9f21b8d5ce8231d137b0ef88c8f17a4f">qspi_automode_read</a> (uint32_t addr, uint8_t *buf, uint32_t len)</td></tr>
<tr class="memdesc:ga9f21b8d5ce8231d137b0ef88c8f17a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read memory.  <a href="#ga9f21b8d5ce8231d137b0ef88c8f17a4f">More...</a><br /></td></tr>
<tr class="separator:ga9f21b8d5ce8231d137b0ef88c8f17a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga949df4486361e3c5d2ec9165a94fb7e8"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga949df4486361e3c5d2ec9165a94fb7e8">qspi_automode_addr</a> (uint32_t addr)</td></tr>
<tr class="memdesc:ga949df4486361e3c5d2ec9165a94fb7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get address of memory.  <a href="#ga949df4486361e3c5d2ec9165a94fb7e8">More...</a><br /></td></tr>
<tr class="separator:ga949df4486361e3c5d2ec9165a94fb7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga495dbcef4585cf6f54afca7604f62714"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga495dbcef4585cf6f54afca7604f62714"></a>
<a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga495dbcef4585cf6f54afca7604f62714">qspi_automode_flash_power_up</a> (void)</td></tr>
<tr class="memdesc:ga495dbcef4585cf6f54afca7604f62714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power up flash. <br /></td></tr>
<tr class="separator:ga495dbcef4585cf6f54afca7604f62714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6d2b2e94eb5fe018bb212a76ddaee5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad6d2b2e94eb5fe018bb212a76ddaee5d"></a>
<a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gad6d2b2e94eb5fe018bb212a76ddaee5d">qspi_automode_flash_power_down</a> (void)</td></tr>
<tr class="memdesc:gad6d2b2e94eb5fe018bb212a76ddaee5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set QSPI Flash into power down mode. <br /></td></tr>
<tr class="separator:gad6d2b2e94eb5fe018bb212a76ddaee5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae257d1ee1830c6eef0ee9914f5c77fa6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae257d1ee1830c6eef0ee9914f5c77fa6"></a>
<a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gae257d1ee1830c6eef0ee9914f5c77fa6">qspi_automode_init</a> (void)</td></tr>
<tr class="memdesc:gae257d1ee1830c6eef0ee9914f5c77fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init QSPI controller. <br /></td></tr>
<tr class="separator:gae257d1ee1830c6eef0ee9914f5c77fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75fa38c03d4c4039b77840fb83b8e52c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga75fa38c03d4c4039b77840fb83b8e52c">qspi_check_program_erase_in_progress</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:ga75fa38c03d4c4039b77840fb83b8e52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a program or sector erase operation is in progress.  <a href="#ga75fa38c03d4c4039b77840fb83b8e52c">More...</a><br /></td></tr>
<tr class="separator:ga75fa38c03d4c4039b77840fb83b8e52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f86c4e1d8c661aaa22cd24538498843"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga9f86c4e1d8c661aaa22cd24538498843">qspi_resume</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:ga9f86c4e1d8c661aaa22cd24538498843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume a Flash program or sector erase operation.  <a href="#ga9f86c4e1d8c661aaa22cd24538498843">More...</a><br /></td></tr>
<tr class="separator:ga9f86c4e1d8c661aaa22cd24538498843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98a2cc464c5ddb81b4307df949e8e79b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga98a2cc464c5ddb81b4307df949e8e79b">flash_erase_sector_manual_mode</a> (uint32_t addr)</td></tr>
<tr class="memdesc:ga98a2cc464c5ddb81b4307df949e8e79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a sector of the Flash in manual mode.  <a href="#ga98a2cc464c5ddb81b4307df949e8e79b">More...</a><br /></td></tr>
<tr class="separator:ga98a2cc464c5ddb81b4307df949e8e79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3cbbef4f3da5e08c1a1faeed8a53f4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gac3cbbef4f3da5e08c1a1faeed8a53f4c">flash_program_page_manual_mode</a> (uint32_t addr, const uint8_t *buf, uint32_t len)</td></tr>
<tr class="memdesc:gac3cbbef4f3da5e08c1a1faeed8a53f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program data into a page of the Flash in manual mode.  <a href="#gac3cbbef4f3da5e08c1a1faeed8a53f4c">More...</a><br /></td></tr>
<tr class="separator:gac3cbbef4f3da5e08c1a1faeed8a53f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fd4f0b2853539e49bb3f3d6004c52b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga0fd4f0b2853539e49bb3f3d6004c52b6">qspi_automode_sys_clock_cfg</a> (<a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> sys_clk)</td></tr>
<tr class="memdesc:ga0fd4f0b2853539e49bb3f3d6004c52b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure Flash and QSPI controller for system clock frequency.  <a href="#ga0fd4f0b2853539e49bb3f3d6004c52b6">More...</a><br /></td></tr>
<tr class="separator:ga0fd4f0b2853539e49bb3f3d6004c52b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2b91d4420e06b659d83306de4d33c16"><td class="memItemLeft" align="right" valign="top">const qspi_ucode_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gab2b91d4420e06b659d83306de4d33c16">qspi_automode_get_ucode</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:gab2b91d4420e06b659d83306de4d33c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ucode required for wake-up sequence.  <a href="#gab2b91d4420e06b659d83306de4d33c16">More...</a><br /></td></tr>
<tr class="separator:gab2b91d4420e06b659d83306de4d33c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ea5cb64307997d2a58cebd6b194a54b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga4ea5cb64307997d2a58cebd6b194a54b">qspi_is_valid_addr</a> (uint32_t addr)</td></tr>
<tr class="memdesc:ga4ea5cb64307997d2a58cebd6b194a54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verified if passed adder is valid and physically available.  <a href="#ga4ea5cb64307997d2a58cebd6b194a54b">More...</a><br /></td></tr>
<tr class="separator:ga4ea5cb64307997d2a58cebd6b194a54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad51c75f6e701d009f8a2062765e32f41"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gad51c75f6e701d009f8a2062765e32f41">qspi_get_device_size</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:gad51c75f6e701d009f8a2062765e32f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum available memory size for selected controller id.  <a href="#gad51c75f6e701d009f8a2062765e32f41">More...</a><br /></td></tr>
<tr class="separator:gad51c75f6e701d009f8a2062765e32f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga237c2183fbc662b2f8b4ed16ffee9950"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga237c2183fbc662b2f8b4ed16ffee9950">qspi_get_config</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id, uint8_t *manufacturer_id, uint8_t *device_type, uint8_t *density)</td></tr>
<tr class="memdesc:ga237c2183fbc662b2f8b4ed16ffee9950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get configuration parameters for selected controller id.  <a href="#ga237c2183fbc662b2f8b4ed16ffee9950">More...</a><br /></td></tr>
<tr class="separator:ga237c2183fbc662b2f8b4ed16ffee9950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62058beff3233ef58137cf10709d5982"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga62058beff3233ef58137cf10709d5982">qspi_read_flash_jedec_id</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id, uint8_t *manufacturer_id, uint8_t *device_type, uint8_t *density)</td></tr>
<tr class="memdesc:ga62058beff3233ef58137cf10709d5982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the JEDEC manufacturer ID, device type and device density using command 0x9F.  <a href="#ga62058beff3233ef58137cf10709d5982">More...</a><br /></td></tr>
<tr class="separator:ga62058beff3233ef58137cf10709d5982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dc4aba657d85110b228f069e6a9b55f"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#ga6c30d490cd2302ff05d355f3ec844c1f">__UNUSED</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga1dc4aba657d85110b228f069e6a9b55f">flash_w25q_wre_volatile</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id)</td></tr>
<tr class="memdesc:ga1dc4aba657d85110b228f069e6a9b55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable volatile writes to Status Register bits.  <a href="#ga1dc4aba657d85110b228f069e6a9b55f">More...</a><br /></td></tr>
<tr class="separator:ga1dc4aba657d85110b228f069e6a9b55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf549372bb57f0afa525c903a091169e1"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaf549372bb57f0afa525c903a091169e1">flash_w25q_write_status_register_2</a> (<a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a> id, uint8_t value)</td></tr>
<tr class="memdesc:gaf549372bb57f0afa525c903a091169e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the Status Register 2 of the Flash.  <a href="#gaf549372bb57f0afa525c903a091169e1">More...</a><br /></td></tr>
<tr class="separator:gaf549372bb57f0afa525c903a091169e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c7e73735115eff9ad6a926ec9a38f4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4c7e73735115eff9ad6a926ec9a38f4e"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga4c7e73735115eff9ad6a926ec9a38f4e">flash_XXX_is_suspended</a> (void)</td></tr>
<tr class="memdesc:ga4c7e73735115eff9ad6a926ec9a38f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns true if the flash is in write/erase suspend mode. <br /></td></tr>
<tr class="separator:ga4c7e73735115eff9ad6a926ec9a38f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84493442a9b2278e1b8442cd31e7733b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga84493442a9b2278e1b8442cd31e7733b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga84493442a9b2278e1b8442cd31e7733b">flash_XXX_initialize</a> (uint8_t device_type, uint8_t device_density)</td></tr>
<tr class="memdesc:ga84493442a9b2278e1b8442cd31e7733b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called to initialize the flash. <br /></td></tr>
<tr class="separator:ga84493442a9b2278e1b8442cd31e7733b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58ae33918050d0f1b1aaaf0dcb996a17"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga58ae33918050d0f1b1aaaf0dcb996a17">flash_XXX_deactivate_command_entry_mode</a> (void)</td></tr>
<tr class="memdesc:ga58ae33918050d0f1b1aaaf0dcb996a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called to put the flash OUT of command entry mode.  <a href="#ga58ae33918050d0f1b1aaaf0dcb996a17">More...</a><br /></td></tr>
<tr class="separator:ga58ae33918050d0f1b1aaaf0dcb996a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae08612f2868e8c19042cced1ea6f1408"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gae08612f2868e8c19042cced1ea6f1408">flash_XXX_sys_clock_cfg</a> (<a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> sys_clk)</td></tr>
<tr class="memdesc:gae08612f2868e8c19042cced1ea6f1408"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called each time the system clock is changed.  <a href="#gae08612f2868e8c19042cced1ea6f1408">More...</a><br /></td></tr>
<tr class="separator:gae08612f2868e8c19042cced1ea6f1408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca7ed880e0f577fc1cf08ccb9d4370b7"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaca7ed880e0f577fc1cf08ccb9d4370b7">flash_XXX_get_dummy_bytes</a> (void)</td></tr>
<tr class="memdesc:gaca7ed880e0f577fc1cf08ccb9d4370b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This must return the number of dummy bytes required.  <a href="#gaca7ed880e0f577fc1cf08ccb9d4370b7">More...</a><br /></td></tr>
<tr class="separator:gaca7ed880e0f577fc1cf08ccb9d4370b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga7b03f55064e4b505188bde56ce8d22cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7b03f55064e4b505188bde56ce8d22cc"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga7b03f55064e4b505188bde56ce8d22cc">at25ff321a_ucode_wakeup</a> []</td></tr>
<tr class="memdesc:ga7b03f55064e4b505188bde56ce8d22cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">uCode for handling the QSPI FLASH exit from the "Continuous Read Mode". <br /></td></tr>
<tr class="separator:ga7b03f55064e4b505188bde56ce8d22cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae840eef1972474955b818a91ebc18487"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaaca7b42888b10ca3e05786453609d0d3">qspi_flash_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gae840eef1972474955b818a91ebc18487">flash_at25ff321a_config</a></td></tr>
<tr class="memdesc:gae840eef1972474955b818a91ebc18487"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct configures the system for the specific flash.  <a href="#gae840eef1972474955b818a91ebc18487">More...</a><br /></td></tr>
<tr class="separator:gae840eef1972474955b818a91ebc18487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e31134d7992a83d7900da7fb4559520"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1e31134d7992a83d7900da7fb4559520"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga1e31134d7992a83d7900da7fb4559520">at25sl321_ucode_wakeup</a> []</td></tr>
<tr class="memdesc:ga1e31134d7992a83d7900da7fb4559520"><td class="mdescLeft">&#160;</td><td class="mdescRight">uCode for handling the QSPI FLASH exit from the "Continuous Read Mode". <br /></td></tr>
<tr class="separator:ga1e31134d7992a83d7900da7fb4559520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5001117e3965e4fc9127c4c82c686ad9"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaaca7b42888b10ca3e05786453609d0d3">qspi_flash_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga5001117e3965e4fc9127c4c82c686ad9">flash_at25sl321_config</a></td></tr>
<tr class="memdesc:ga5001117e3965e4fc9127c4c82c686ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct configures the system for the specific flash.  <a href="#ga5001117e3965e4fc9127c4c82c686ad9">More...</a><br /></td></tr>
<tr class="separator:ga5001117e3965e4fc9127c4c82c686ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a4d43d25bbd9e5a2482f130491ab569"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1a4d43d25bbd9e5a2482f130491ab569"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga1a4d43d25bbd9e5a2482f130491ab569">GD25LE32_ucode_wakeup</a> []</td></tr>
<tr class="memdesc:ga1a4d43d25bbd9e5a2482f130491ab569"><td class="mdescLeft">&#160;</td><td class="mdescRight">uCode for handling the QSPI FLASH exit from the "Continuous Read Mode". <br /></td></tr>
<tr class="separator:ga1a4d43d25bbd9e5a2482f130491ab569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28d686d16a4495b50dab3b065acfb8bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga28d686d16a4495b50dab3b065acfb8bd"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga28d686d16a4495b50dab3b065acfb8bd">mx25u3235_ucode_wakeup</a> []</td></tr>
<tr class="memdesc:ga28d686d16a4495b50dab3b065acfb8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">uCode for handling the QSPI FLASH exit from the "Continuous Read Mode". <br /></td></tr>
<tr class="separator:ga28d686d16a4495b50dab3b065acfb8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c46b9d7b4d8c90d1c413d36444e4db9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2c46b9d7b4d8c90d1c413d36444e4db9"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga2c46b9d7b4d8c90d1c413d36444e4db9">w25q_ucode_wakeup</a> []</td></tr>
<tr class="memdesc:ga2c46b9d7b4d8c90d1c413d36444e4db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">uCode for handling the QSPI FLASH exit from the "Continuous Read Mode". <br /></td></tr>
<tr class="separator:ga2c46b9d7b4d8c90d1c413d36444e4db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ab3fff9d91d1281dc9ce0acd0879a8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5ab3fff9d91d1281dc9ce0acd0879a8b"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga5ab3fff9d91d1281dc9ce0acd0879a8b">XXX_ucode_wakeup</a> []</td></tr>
<tr class="memdesc:ga5ab3fff9d91d1281dc9ce0acd0879a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">uCode for handling the QSPI FLASH exit from the "Continuous Read Mode". <br /></td></tr>
<tr class="separator:ga5ab3fff9d91d1281dc9ce0acd0879a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga167ea07e00ea5e4c507cb6bb7cd6f119"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaaca7b42888b10ca3e05786453609d0d3">qspi_flash_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga167ea07e00ea5e4c507cb6bb7cd6f119">flash_XXX_config</a></td></tr>
<tr class="memdesc:ga167ea07e00ea5e4c507cb6bb7cd6f119"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structs configures the system for the specific flash.  <a href="#ga167ea07e00ea5e4c507cb6bb7cd6f119">More...</a><br /></td></tr>
<tr class="separator:ga167ea07e00ea5e4c507cb6bb7cd6f119"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Configuration values for the various supported qspi devices. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gacb6745c33d23a6ee71eeaea8b9dda828"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADESTO_ID&#160;&#160;&#160;0x1F</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Flash type JEDEC ID. </p>
<p>This is the first byte returned by the 0x9F command </p>

</div>
</div>
<a class="anchor" id="gacb6745c33d23a6ee71eeaea8b9dda828"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADESTO_ID&#160;&#160;&#160;0x1F</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Flash type JEDEC ID. </p>
<p>This is the first byte returned by the 0x9F command </p>

</div>
</div>
<a class="anchor" id="gad1c1df9af42d8b10edacab947c0c9004"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AT25FF321A_SIZE&#160;&#160;&#160;0x08</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Flash density JEDEC ID. </p>
<p>This is the third byte returned by the 0x9F command </p>

</div>
</div>
<a class="anchor" id="ga72f54ad0a6bb563f1db1284258340cc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AT25FF321A_TYPE&#160;&#160;&#160;0x47</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Flash type JEDEC ID. </p>
<p>This is the second byte returned by the 0x9F command </p>

</div>
</div>
<a class="anchor" id="ga8c5e6481bd16f58441b1213663edd70c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AT25SL321_SIZE&#160;&#160;&#160;0x16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Flash density JEDEC ID. </p>
<p>This is the third byte returned by the 0x9F command </p>

</div>
</div>
<a class="anchor" id="gad120f9c1bc5fee08c9020c07a4ecabf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AT25SL_TYPE&#160;&#160;&#160;0x42</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Flash type JEDEC ID. </p>
<p>This is the second byte returned by the 0x9F command </p>

</div>
</div>
<a class="anchor" id="ga8e4a1a837d547365760bd32ebc664e84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXXXX&#160;&#160;&#160;0xFF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Flash type JEDEC ID. </p>
<p>This is the second byte returned by the 0x9F command </p>

</div>
</div>
<a class="anchor" id="ga230871cbef94a3328fdcda1f87dd2bde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXXXX_ID&#160;&#160;&#160;0xFF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Flash vendor JEDEC ID. </p>
<p>This is the first byte returned by the 0x9F command </p>

</div>
</div>
<a class="anchor" id="ga6f22a9fb53cdeabb03c8b173b93822ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXXXX_SIZE&#160;&#160;&#160;0xFF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Flash density JEDEC ID. </p>
<p>This is the third byte returned by the 0x9F command </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gaaca7b42888b10ca3e05786453609d0d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structqspi__flash__config.html">qspi_flash_config</a>  <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaaca7b42888b10ca3e05786453609d0d3">qspi_flash_config_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QSPI Flash configuration structure. </p>
<p>This struct is used to define a driver for a specific QSPI device.</p>
<dl class="section note"><dt>Note</dt><dd>The struct instance must be declared as static const for this to work </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga8f146c23ecc49ee6a02663d8feac2189"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void flash_at25ff321a_enable_quad_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the Quad Enable Bit of the Status Register if it is not already set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga925308084233a6494cb37bc2d76f057b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void flash_at25ff321a_enable_XiP_and_DPD_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the XiP Bit of the Status Register 4 if it is not already set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga77962d11705451d28241f969096f11cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint8_t flash_at25ff321a_get_dummy_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns the dummy bytes required when utilizing Fast Read Quad. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will return the number of dummy bytes required while Fast Read Quad is activated. In some QSPI Flash devices, it is possible that the number of dummy bytes required can vary depending on the operating speed. </dd></dl>

</div>
</div>
<a class="anchor" id="gafac598dd4dadf54eadc355c7646e63c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void flash_at25ff321a_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize AT25FF321A QSPI Flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will perform all the required actions in order for AT25FF321A QSPI Flash to be properly initialized. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c71c52f2cf8a39c5c889e58beb77505"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool flash_at25ff321a_is_suspended </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns true if an erase or program operation is already suspended. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function reads the status register and checks the erase/program suspend bits. If either of them is set then it returns true since a program or erase operation is currently suspended. </dd></dl>

</div>
</div>
<a class="anchor" id="ga41cce88a1b387d99a13017726ff1ff9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint8_t flash_at25ff321a_read_status_register_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the Status Register 2 of the Flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t The value of the Status Register 2 of the Flash. </dd></dl>

</div>
</div>
<a class="anchor" id="ga46751b6258f19e79b120f63d0345eb83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint8_t flash_at25ff321a_read_status_register_indirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indirectly read the targetted Status Register of the Flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>uint8_t reg value 1 to 5</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t The value of the targetted Status Register of the Flash. </dd></dl>

</div>
</div>
<a class="anchor" id="gaccd9780a2ee60d6092d67aa3bd00290f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void flash_at25ff321a_set_dummy_cycles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>set_non_volatile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_l_a___m_e_m_o_r_y.html#ga2f77846abda0a0fb42506063697b31f6">AT25FF321A_OP_FREQ_EB</a>&#160;</td>
          <td class="paramname"><em>d_cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of Dummy Cycles for AT25FF321A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">set_non_volatile</td><td>bool set_non_volatile </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_cycles</td><td>AT25FF321A_OP_FREQ_EB d_cycles</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function sets up bits[6:4] of Status Register 5 that correspond to the number of Dummy Cycles needed. The number of Dummy Cycles include the cycles needed to send the Extra Byte[M7-M0] and depend on the Operating Frequency. If set_non_volatile is false the volatile version of the register is set, otherwise the non volatile version of the register is set instead. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa8800aba2f7517960e6dc679ddbaccba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void flash_at25ff321a_set_initial_boot_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the initial number of Dummy Cycles for AT25FF321A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function reads Status Register 5 and checks if the correct number of expected dummy cycles are set on the QSPI Flash for 32MHz Operating Frequency and if not then sets them. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5dbe0bec3278c3fcb995eec4ff491d77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void flash_at25ff321a_sys_clock_cfg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>sys_clk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hook function called when the clock is changed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sys_clk</td><td>system clock source to be switched to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will be called prior to switching from one clock source to another. This function allows doing all the required tasks before the clock source is switched. Typical use could be setting up the proper QSPI divider to ensure that the device will continue to operate even after the clock source will be switched. E.g. Flash that supports up to 80 MHz operating speed will need to have a divider of 2 if PLL96 is picked as the source. </dd></dl>

</div>
</div>
<a class="anchor" id="gaed5b58d37e657b220e229a11703f6dee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void flash_at25ff321a_volatile_write_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set WEL (Write Enable Latch) bit of the Volatile version of the Status Register of the Flash. </p>
<p>The WEL bit must be set prior to writing to the volatile versions of the Status Registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae4cfba5711a05ed3432db2c516e8a39b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void flash_at25ff321a_write_status_register_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the Status Register 2 of the Flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function blocks until the Flash has processed the command. No verification that the value has been actually written is done though. It is up to the caller to decide whether such verification is needed or not and execute it on its own. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa768488c3a2e5aaa03283238cd90b7c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void flash_at25ff321a_write_status_register_indirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indirectly write the targetted Status Register of the Flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>uint8_t reg value 1 to 5 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function blocks until the Flash has processed the command. No verification that the value has been actually written is done though. It is up to the caller to decide whether such verification is needed or not and execute it on its own. </dd></dl>

</div>
</div>
<a class="anchor" id="ga24058c32882183c2f3d9117c94e2a418"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void flash_at25sl321_enable_quad_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the Quad Enable Bit of the Status Register if it is not already set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae75eae068642c5da78a0ce01a9ceae1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint8_t flash_at25sl321_get_dummy_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns the dummy bytes required when utilizing Fast Read Quad. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will return the number of dummy bytes required while Fast Read Quad is activated. In some QSPI Flash devices, it is possible that the number of dummy bytes required can vary depending on the operating speed. </dd></dl>

</div>
</div>
<a class="anchor" id="gabf7ba823ab7fa7895c20037b769e528a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void flash_at25sl321_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize AT25SL321 QSPI Flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will perform all the required actions in order for AT25SL321 QSPI Flash to be properly initialized. </dd></dl>

</div>
</div>
<a class="anchor" id="ga51759ea3b92dfd88a618b19fc512cd1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool flash_at25sl321_is_suspended </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns true if an erase or program operation is already suspended. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function reads the status register and checks the erase/program suspend bit. If it is set then it return true since a program or erase operation is currently suspended. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7234c98f04254f142684c6757b7e49b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint8_t flash_at25sl321_read_status_register_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the Status Register 2 of the Flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t The value of the Status Register 2 of the Flash. </dd></dl>

</div>
</div>
<a class="anchor" id="gafa319dd3aadb27e6b42e3a61e2dfec43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void flash_at25sl321_sys_clock_cfg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>sys_clk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hook function called when the clock is changed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sys_clk</td><td>System clock source to be switched to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will be called prior to switching from one clock source to another. This function allows doing all the required tasks before the clock source is switched. Typical use could be setting up the proper QSPI divider to ensure that the device will continue to operate even after the clock source will be switched. E.g. Flash that supports up to 80 MHz operating speed will need to have a divider of 2 if PLL96 is picked as the source. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2d13e1908fd0b742b3d6c6648151b3b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void flash_at25sl321_write_status_register_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the Status Register 2 of the Flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function blocks until the Flash has processed the command. No verification that the value has been actually written is done though. It is up to the caller to decide whether such verification is needed or not and execute it on its own. </dd></dl>

</div>
</div>
<a class="anchor" id="ga98a2cc464c5ddb81b4307df949e8e79b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void flash_erase_sector_manual_mode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase a sector of the Flash in manual mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The address of the sector to be erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does not block until the Flash has processed the command! The QSPI controller is left to manual mode after the call to this function. The function must be called with interrupts disabled. </dd></dl>

</div>
</div>
<a class="anchor" id="gac3cbbef4f3da5e08c1a1faeed8a53f4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint32_t flash_program_page_manual_mode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program data into a page of the Flash in manual mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The address of the Flash where the data will be written. It may be anywhere in a page. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to the beginning of the buffer that contains the data to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of bytes to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The boundary of the page where addr belongs to, will not be crossed! The caller should issue another <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gac3cbbef4f3da5e08c1a1faeed8a53f4c" title="Program data into a page of the Flash in manual mode. ">flash_program_page_manual_mode()</a> call in order to write the remaining data to the next page. The QSPI controller is left to manual mode after the call to this function. The function must be called with interrupts disabled. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1dc4aba657d85110b228f069e6a9b55f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#ga6c30d490cd2302ff05d355f3ec844c1f">__UNUSED</a> void flash_w25q_wre_volatile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable volatile writes to Status Register bits. </p>
<p>When this command is issued, any writes to any of the Status Registers of the Flash are done as volatile writes. This command is valid only when the Write Status Register command follows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function blocks until the Flash has processed the command. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf549372bb57f0afa525c903a091169e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void flash_w25q_write_status_register_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the Status Register 2 of the Flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function blocks until the Flash has processed the command. No verification that the value has been actually written is done though. It is up to the caller to decide whether such verification is needed or not and execute it on its own. </dd></dl>

</div>
</div>
<a class="anchor" id="ga58ae33918050d0f1b1aaaf0dcb996a17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void flash_XXX_deactivate_command_entry_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is called to put the flash OUT of command entry mode. </p>
<p>Usually, this is left empty, unless something special needs to be done (Basic work is done by the central flash driver). </p>

</div>
</div>
<a class="anchor" id="gaca7ed880e0f577fc1cf08ccb9d4370b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint8_t flash_XXX_get_dummy_bytes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This must return the number of dummy bytes required. </p>
<p>In most cases, this can return a static value (usually 2). Sometimes, however, the dummy bytes must change (e.g. according to the system clock frequency). </p>

</div>
</div>
<a class="anchor" id="gae08612f2868e8c19042cced1ea6f1408"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void flash_XXX_sys_clock_cfg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>sys_clk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is called each time the system clock is changed. </p>
<p>This can be used e.g. to change the qspi controller divider or modify the flash dummy bytes, if e.g. the flash cannot cope with the higher clock frequency. </p>

</div>
</div>
<a class="anchor" id="ga949df4486361e3c5d2ec9165a94fb7e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* qspi_automode_addr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get address of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>starting offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address in CPU address space where data is located </dd></dl>

</div>
</div>
<a class="anchor" id="gafcd4cecdf5349007b99b3e17e4306f36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qspi_automode_erase_flash_sector </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase flash sector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>starting offset of sector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab2b91d4420e06b659d83306de4d33c16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const qspi_ucode_t* qspi_automode_get_ucode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ucode required for wake-up sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>qspi_ucode_t Pointer to the structure containing the ucode and ucode size </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f21b8d5ce8231d137b0ef88c8f17a4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t qspi_automode_read </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>starting offset </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>buffer to read data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read </dd></dl>

</div>
</div>
<a class="anchor" id="ga0fd4f0b2853539e49bb3f3d6004c52b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void qspi_automode_sys_clock_cfg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___c_l_k.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>sys_clk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure Flash and QSPI controller for system clock frequency. </p>
<p>This function is used to change the Flash configuration of the QSPI controller to work with the system clock frequency defined in sys_clk. Dummy clock cycles could be changed here to support higher clock frequencies. QSPI controller clock divider could also be changed if the Flash maximum frequency is smaller than the system clock frequency. This function must be called before changing system clock frequency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sys_clk</td><td>System clock frequency </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2eb0ffc532fe27b4ea3fa4af9b5fdc2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t qspi_automode_write_flash_page </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write flash memory. </p>
<p>This function allows to write up to page size of data to flash. If size is greater than page size, flash can wrap data and overwrite content of page. It's possible to write less then page size. Memory should be erased before.</p>
<dl class="section note"><dt>Note</dt><dd>: Do not pass buf pointing to QSPI mapped memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>offset in flash to write data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>pointer to data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<p>return number of bytes written </p>

</div>
</div>
<a class="anchor" id="gacbc75c9e1e14d777ff709365c240fd70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void qspi_check_and_suspend_operations </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend a Flash program or erase operation. </p>
<p>This function will try to suspend an ongoing program or erase procedure. Note that the program or erase procedure may have been completed before the suspend command is processed by the Flash. In this case the SUS bit will be left to 0.</p>
<dl class="section warning"><dt>Warning</dt><dd>After the call to this function, the QSPI controller is set to auto mode and the Flash access to quad mode (if QUAD_MODE is 1). The function must be called with interrupts disabled. </dd></dl>

</div>
</div>
<a class="anchor" id="ga75fa38c03d4c4039b77840fb83b8e52c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool qspi_check_program_erase_in_progress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a program or sector erase operation is in progress. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if the BUSY bit is set else false.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function checks the value of the BUSY bit in the Status Register 1 of the Flash. It is the responsibility of the caller to call the function in the right context. The function must be called with interrupts disabled. </dd></dl>

</div>
</div>
<a class="anchor" id="ga237c2183fbc662b2f8b4ed16ffee9950"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qspi_get_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>manufacturer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>device_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>density</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get configuration parameters for selected controller id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">manufacturer_id</td><td>Manufacturer ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">device_type</td><td>Device type </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">density</td><td>Device density</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device is marked as present, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gad51c75f6e701d009f8a2062765e32f41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t qspi_get_device_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get maximum available memory size for selected controller id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum memory size counted in bytes </dd></dl>

</div>
</div>
<a class="anchor" id="ga3d9bb478f93a3613dad89f84c3f50b8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qspi_is_op_pending </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if there is a pending background Flash operation. </p>
<dl class="section return"><dt>Returns</dt><dd>true if a background flash operation is pending, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="ga4ea5cb64307997d2a58cebd6b194a54b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool qspi_is_valid_addr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verified if passed adder is valid and physically available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>starting offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2b3bcb6f4a8d0e17144bf0edce4d4d8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool qspi_process_operations </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute any pending QSPI program / erase operations. </p>
<dl class="section return"><dt>Returns</dt><dd>true if write operation has been completed </dd></dl>

</div>
</div>
<a class="anchor" id="ga62058beff3233ef58137cf10709d5982"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool qspi_read_flash_jedec_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>manufacturer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>device_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>density</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the JEDEC manufacturer ID, device type and device density using command 0x9F. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">manufacturer_id</td><td>Pointer to the variable where the manufacturer ID will be returned </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">device_type</td><td>Pointer to the variable where the device type will be returned </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">density</td><td>Pointer to the variable where the device density will be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if JEDEC Id has been read successfully, false otherwise</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this function will reset FLASH device connected to the specified QSPI controller </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f86c4e1d8c661aaa22cd24538498843"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_e_f_i_n_i_t_i_o_n_s.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void qspi_resume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_w___q_s_p_i.html#gac5bb29998aea66ff88b00ff11b384adb">HW_QSPIC_ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume a Flash program or sector erase operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>QSPI controller id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>After the call to this function, the QSPI controller is set to manual mode and the Flash access to single mode. The function must be called with interrupts disabled. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="gae840eef1972474955b818a91ebc18487"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaaca7b42888b10ca3e05786453609d0d3">qspi_flash_config_t</a> flash_at25ff321a_config</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This struct configures the system for the specific flash. </p>
<dl class="section note"><dt>Note</dt><dd>This struct MUST be const for this to work. Therefore, assignments must not change (must be read-only) </dd></dl>

</div>
</div>
<a class="anchor" id="ga5001117e3965e4fc9127c4c82c686ad9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaaca7b42888b10ca3e05786453609d0d3">qspi_flash_config_t</a> flash_at25sl321_config</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This struct configures the system for the specific flash. </p>
<dl class="section note"><dt>Note</dt><dd>This struct MUST be const for this to work. Therefore, assignments must not change (must be read-only) </dd></dl>

</div>
</div>
<a class="anchor" id="ga167ea07e00ea5e4c507cb6bb7cd6f119"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___p_l_a___m_e_m_o_r_y.html#gaaca7b42888b10ca3e05786453609d0d3">qspi_flash_config_t</a> flash_XXX_config</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">        .manufacturer_id                  = <a class="code" href="group___p_l_a___m_e_m_o_r_y.html#ga230871cbef94a3328fdcda1f87dd2bde">XXXXX_ID</a>,</div>
<div class="line">        .device_type                      = <a class="code" href="group___p_l_a___m_e_m_o_r_y.html#ga8e4a1a837d547365760bd32ebc664e84">XXXXX</a>,</div>
<div class="line">        .device_density                   = <a class="code" href="group___p_l_a___m_e_m_o_r_y.html#ga6f22a9fb53cdeabb03c8b173b93822ab">XXXXX_SIZE</a>,</div>
<div class="line">        .is_suspended                     = <a class="code" href="group___p_l_a___m_e_m_o_r_y.html#ga4c7e73735115eff9ad6a926ec9a38f4e">flash_XXX_is_suspended</a>,</div>
<div class="line">        .initialize                       = <a class="code" href="group___p_l_a___m_e_m_o_r_y.html#ga84493442a9b2278e1b8442cd31e7733b">flash_XXX_initialize</a>,</div>
<div class="line">        .sys_clk_cfg                      = <a class="code" href="group___p_l_a___m_e_m_o_r_y.html#gae08612f2868e8c19042cced1ea6f1408">flash_XXX_sys_clock_cfg</a>,</div>
<div class="line">        .get_dummy_bytes                  = <a class="code" href="group___p_l_a___m_e_m_o_r_y.html#gaca7ed880e0f577fc1cf08ccb9d4370b7">flash_XXX_get_dummy_bytes</a>,</div>
<div class="line">        .break_seq_size                   = <a class="code" href="group___h_w___q_s_p_i.html#ggaac307a660e5a28c297e4c29bd93f69caa75d28bb2bc33dedd443b2af6f44fde0e">HW_QSPI_BREAK_SEQ_SIZE_1B</a>,</div>
<div class="line">        .address_size                     = <a class="code" href="group___h_w___q_s_p_i.html#gga7b31012e4ee1a0afdb3bc394f0d97743a9bd039cd2cf1bfa5f6b025828c273af8">HW_QSPI_ADDR_SIZE_24</a>,</div>
<div class="line">        .fast_read_opcode                 = CMD_FAST_READ_QUAD,</div>
<div class="line">        .page_program_opcode              = CMD_QUAD_PAGE_PROGRAM,</div>
<div class="line">        .page_qpi_program_opcode          = CMD_QPI_PAGE_PROGRAM,</div>
<div class="line">        .quad_page_program_address        = <span class="keyword">true</span>,</div>
<div class="line">        .erase_opcode                     = CMD_SECTOR_ERASE,</div>
<div class="line">        .read_erase_progress_opcode       = CMD_READ_STATUS_REGISTER,</div>
<div class="line">        .erase_suspend_opcode             = XXX_ERASE_PROGRAM_SUSPEND,</div>
<div class="line">        .erase_resume_opcode              = XXX_ERASE_PROGRAM_RESUME,</div>
<div class="line">        .erase_in_progress_bit            = FLASH_STATUS_BUSY_BIT,</div>
<div class="line">        .erase_in_progress_bit_high_level = <span class="keyword">true</span>,</div>
<div class="line">        .send_once                        = 1,</div>
<div class="line">        .extra_byte                       = 0xA0,</div>
<div class="line">        .ucode_wakeup                     = {<a class="code" href="group___p_l_a___m_e_m_o_r_y.html#ga5ab3fff9d91d1281dc9ce0acd0879a8b">XXX_ucode_wakeup</a>, <span class="keyword">sizeof</span>(<a class="code" href="group___p_l_a___m_e_m_o_r_y.html#ga5ab3fff9d91d1281dc9ce0acd0879a8b">XXX_ucode_wakeup</a>)},</div>
<div class="line">        .power_down_delay                 = XXX_POWER_DOWN_DELAY_US,</div>
<div class="line">        .power_up_delay                   = XXX_POWER_UP_DELAY_US,</div>
<div class="line">        .release_power_down_delay         = XXX_RELEASE_POWER_DOWN_DELAY_US,</div>
<div class="line">        .qpi_mode                         = <span class="keyword">false</span>,</div>
<div class="line">        .is_ram                           = <span class="keyword">false</span>,</div>
<div class="line">        .memory_size                      = MEMORY_SIZE_XXXMb,</div>
<div class="line">}</div>
<div class="ttc" id="group___p_l_a___m_e_m_o_r_y_html_ga6f22a9fb53cdeabb03c8b173b93822ab"><div class="ttname"><a href="group___p_l_a___m_e_m_o_r_y.html#ga6f22a9fb53cdeabb03c8b173b93822ab">XXXXX_SIZE</a></div><div class="ttdeci">#define XXXXX_SIZE</div><div class="ttdoc">The Flash density JEDEC ID. </div><div class="ttdef"><b>Definition:</b> qspi_XXX_template.h:45</div></div>
<div class="ttc" id="group___h_w___q_s_p_i_html_ggaac307a660e5a28c297e4c29bd93f69caa75d28bb2bc33dedd443b2af6f44fde0e"><div class="ttname"><a href="group___h_w___q_s_p_i.html#ggaac307a660e5a28c297e4c29bd93f69caa75d28bb2bc33dedd443b2af6f44fde0e">HW_QSPI_BREAK_SEQ_SIZE_1B</a></div><div class="ttdef"><b>Definition:</b> hw_qspi.h:151</div></div>
<div class="ttc" id="group___p_l_a___m_e_m_o_r_y_html_gaca7ed880e0f577fc1cf08ccb9d4370b7"><div class="ttname"><a href="group___p_l_a___m_e_m_o_r_y.html#gaca7ed880e0f577fc1cf08ccb9d4370b7">flash_XXX_get_dummy_bytes</a></div><div class="ttdeci">static uint8_t flash_XXX_get_dummy_bytes(void)</div><div class="ttdoc">This must return the number of dummy bytes required. </div><div class="ttdef"><b>Definition:</b> qspi_XXX_template.h:245</div></div>
<div class="ttc" id="group___p_l_a___m_e_m_o_r_y_html_ga84493442a9b2278e1b8442cd31e7733b"><div class="ttname"><a href="group___p_l_a___m_e_m_o_r_y.html#ga84493442a9b2278e1b8442cd31e7733b">flash_XXX_initialize</a></div><div class="ttdeci">static void flash_XXX_initialize(uint8_t device_type, uint8_t device_density)</div><div class="ttdoc">This is called to initialize the flash. </div><div class="ttdef"><b>Definition:</b> qspi_XXX_template.h:229</div></div>
<div class="ttc" id="group___h_w___q_s_p_i_html_gga7b31012e4ee1a0afdb3bc394f0d97743a9bd039cd2cf1bfa5f6b025828c273af8"><div class="ttname"><a href="group___h_w___q_s_p_i.html#gga7b31012e4ee1a0afdb3bc394f0d97743a9bd039cd2cf1bfa5f6b025828c273af8">HW_QSPI_ADDR_SIZE_24</a></div><div class="ttdef"><b>Definition:</b> hw_qspi.h:54</div></div>
<div class="ttc" id="group___p_l_a___m_e_m_o_r_y_html_ga4c7e73735115eff9ad6a926ec9a38f4e"><div class="ttname"><a href="group___p_l_a___m_e_m_o_r_y.html#ga4c7e73735115eff9ad6a926ec9a38f4e">flash_XXX_is_suspended</a></div><div class="ttdeci">static bool flash_XXX_is_suspended(void)</div><div class="ttdoc">This returns true if the flash is in write/erase suspend mode. </div><div class="ttdef"><b>Definition:</b> qspi_XXX_template.h:221</div></div>
<div class="ttc" id="group___p_l_a___m_e_m_o_r_y_html_ga8e4a1a837d547365760bd32ebc664e84"><div class="ttname"><a href="group___p_l_a___m_e_m_o_r_y.html#ga8e4a1a837d547365760bd32ebc664e84">XXXXX</a></div><div class="ttdeci">#define XXXXX</div><div class="ttdoc">The Flash type JEDEC ID. </div><div class="ttdef"><b>Definition:</b> qspi_XXX_template.h:38</div></div>
<div class="ttc" id="group___p_l_a___m_e_m_o_r_y_html_gae08612f2868e8c19042cced1ea6f1408"><div class="ttname"><a href="group___p_l_a___m_e_m_o_r_y.html#gae08612f2868e8c19042cced1ea6f1408">flash_XXX_sys_clock_cfg</a></div><div class="ttdeci">static void flash_XXX_sys_clock_cfg(sys_clk_t sys_clk)</div><div class="ttdoc">This is called each time the system clock is changed. </div><div class="ttdef"><b>Definition:</b> qspi_XXX_template.h:234</div></div>
<div class="ttc" id="group___p_l_a___m_e_m_o_r_y_html_ga5ab3fff9d91d1281dc9ce0acd0879a8b"><div class="ttname"><a href="group___p_l_a___m_e_m_o_r_y.html#ga5ab3fff9d91d1281dc9ce0acd0879a8b">XXX_ucode_wakeup</a></div><div class="ttdeci">const uint32_t XXX_ucode_wakeup[]</div><div class="ttdoc">uCode for handling the QSPI FLASH exit from the "Continuous Read Mode". </div><div class="ttdef"><b>Definition:</b> qspi_XXX_template.h:121</div></div>
<div class="ttc" id="group___p_l_a___m_e_m_o_r_y_html_ga230871cbef94a3328fdcda1f87dd2bde"><div class="ttname"><a href="group___p_l_a___m_e_m_o_r_y.html#ga230871cbef94a3328fdcda1f87dd2bde">XXXXX_ID</a></div><div class="ttdeci">#define XXXXX_ID</div><div class="ttdoc">The Flash vendor JEDEC ID. </div><div class="ttdef"><b>Definition:</b> qspi_XXX_template.h:31</div></div>
</div><!-- fragment -->
<p>This structs configures the system for the specific flash. </p>
<dl class="section note"><dt>Note</dt><dd>This struct MUST be const for this to work. Therefore, assignments must not change (must be read-only) </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jul 7 2020 07:10:51 for SmartSnippets DA1469x SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>

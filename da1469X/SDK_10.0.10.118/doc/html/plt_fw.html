<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>SmartSnippets DA1469x SDK: Production Line Tool Firmware</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1469x SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Board&#160;and&#160;Applications&#160;General&#160;Info</span></a></li>
      <li><a href="modules.html"><span>SDK&#160;Architecture</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Production Line Tool Firmware </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>UART configuration </h2>
<p>The application can be controlled using the serial console exposed over UART2.</p>
<p>GPIO pins configuration is as follows:</p>
<table class="doxtable">
<tr>
<th>DA1469x GPIO pin </th><th>DA1468x GPIO pin </th><th>Function  </th></tr>
<tr>
<td>P0.9 </td><td>P1.3 </td><td>UART2 TX </td></tr>
<tr>
<td>P0.8 </td><td>P2.3 </td><td>UART2 RX </td></tr>
</table>
<p>UART settings are as follows:</p>
<table class="doxtable">
<tr>
<th>Setting </th><th>Value  </th></tr>
<tr>
<td>Baudrate </td><td>115200 </td></tr>
<tr>
<td>Data bits </td><td>8 </td></tr>
<tr>
<td>Stop bits </td><td>1 </td></tr>
<tr>
<td>Parity </td><td>None </td></tr>
<tr>
<td>Flow control </td><td>None </td></tr>
</table>
<p>This configuration can be changed, by modifying plt_fw.bin binary at specific offsets:</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Description </th><th>Format  </th></tr>
<tr>
<td>0x0200 </td><td>TX port number </td><td>(4 bytes LE) </td></tr>
<tr>
<td>0x0204 </td><td>TX pin number </td><td>(4 bytes LE) </td></tr>
<tr>
<td>0x0208 </td><td>RX port number </td><td>(4 bytes LE) </td></tr>
<tr>
<td>0x020C </td><td>RX pin number </td><td>(4 bytes LE) </td></tr>
<tr>
<td>0x0210 </td><td>UART's baudrate value </td><td>(4 bytes LE) </td></tr>
</table>
<blockquote class="doxtable">
<p><em>Note</em>: By default, all values are set to 0xFFFFFFFF in the plt_fw.bin binary. </p>
</blockquote>
<h2>Bluetooth HCI (Host Controller Interface) protocol background </h2>
<blockquote class="doxtable">
<p><em>Note</em>: For more details please reference to Bluetooth SIG Core v5.1, Vol 2, Part E, section 5.4 "EXCHANGE OF HCI-SPECIFIC INFORMATION" [ <a href="https://www.bluetooth.com/specifications/bluetooth-core-specification/">https://www.bluetooth.com/specifications/bluetooth-core-specification/</a> ] </p>
</blockquote>
<p>Host controls the Bluetooth module and monitors its status using HCI commands. The commands are transferred using HCI command packets. If a command can be executed, it will be and an HCI status event with error code 'no error' will be returned. If a command can not be executed it will be not, and an HCI status event will be returned with the respective error code. The format of the HCI Event Packets is similar to the HCI Command Packets. They carry an event code identifying the event.</p>
<blockquote class="doxtable">
<p><em>Note</em>: For details about HCI commands error code please reference to Bluetooth SIG Core v5.1, Vol 2, Part D, section 2 "ERROR CODE DESCRIPTIONS". </p>
</blockquote>
<ul>
<li>HCI communication flow between Host and Controller</li>
</ul>
<table class="doxtable">
<tr>
<th align="center">Module </th><th align="center">direction </th><th align="center">transport </th><th align="center">direction </th><th align="center">Module  </th></tr>
<tr>
<td align="center">[ BT HOST ] </td><td align="center">&gt;&gt;&gt;&gt; </td><td align="center">[ Transport Layer payload (HCI command packet) ] </td><td align="center">&gt;&gt;&gt;&gt; </td><td align="center">[ BT CONTROLLER ] </td></tr>
<tr>
<td align="center">[ BT HOST ] </td><td align="center">&lt;&lt;&lt;&lt; </td><td align="center">[ Transport Layer payload (HCI event packet) ] </td><td align="center">&lt;&lt;&lt;&lt; </td><td align="center">[ BT CONTROLLER ] </td></tr>
</table>
<p><b>HCI command packet</b></p>
<p>Each command begins with a 2 byte OpCode which identifies the command type. The OpCode parameter is divided into two fields, called the OpCode Group Field (OGF) and OpCode Command Field (OCF). The OGF occupies the upper 6 bits of the OpCode, while the OCF occupies the remaining 10 bits. The OGF of 0x3F is reserved for vendor-specific debug commands. </p><blockquote class="doxtable">
<p><em>Note</em>: The OGF composed of all ‘ones’ has been reserved for vendor-specific debug commands. These commands are vendor-specific and are used during manufacturing, for a possible method for updating firmware, and for debugging. </p>
</blockquote>
<ul>
<li>HCI command packet as bits map layout</li>
</ul>
<table class="doxtable">
<tr>
<th align="left">bits </th><th align="left">[0-15] </th><th align="left">[16-23] </th><th align="left">[24-31] </th><th align="left">[32....N]  </th></tr>
<tr>
<td align="left">item </td><td align="left">Command OpCode: [ <b><code>OCF</code></b> (bits: 0-9) <b><code>OGF</code></b> (bits: 10-15) ] </td><td align="left">Parameter Total Length </td><td align="left">Command Parameter 0 </td><td align="left">... Command Parameter N </td></tr>
</table>
<ul>
<li>Detailed description:</li>
</ul>
<table class="doxtable">
<tr>
<th align="left">Packet item </th><th align="left">Description  </th></tr>
<tr>
<td align="left"><b><code>OpCode</code></b> (Size: 2 octets) </td><td align="left">OGF Range (6bits): 0x00 to 0x3F (0x3F reserved for vendor-specific debug commands; OCF Range (10 bits): 0x0000 to 0x03FF </td></tr>
<tr>
<td align="left"><b><code>Parameter Total Length</code></b> (Size: 1 octet) </td><td align="left">Length of all of the parameters contained in this packet measured in octets. (N.B.: total length of parameters, not number of parameters) </td></tr>
<tr>
<td align="left"><b><code>Command Parameter 0 - N</code></b> (Size: Parameter Total Length octets) </td><td align="left">Each command has a specific number of parameters associated with it. These parameters and the size of each of the parameters are predefined for each command. Each parameter is an integer number of octets in size. </td></tr>
</table>
<p><b>HCI event packet</b></p>
<p>The HCI Event packets are used by the Controller to notify the Host that an event has occured. If the Controller sends an HCI Event Packet containing an Event Code or an LE subevent code that the Host has not masked out and does not support, the Host shall ignore that packet. The Host shall be able to accept HCI Event packets with up to 255 octets of data excluding the HCI Event packet header.</p>
<ul>
<li>HCI event packet as bits map layout</li>
</ul>
<table class="doxtable">
<tr>
<th align="left">bits </th><th align="left">[0-7] </th><th align="left">[8-15] </th><th align="left">[16-31] </th><th align="left">[32....N]  </th></tr>
<tr>
<td align="left">item </td><td align="left">Event Code </td><td align="left">Parameter Total Length </td><td align="left">Event Parameter 0 </td><td align="left">... Event Parameter N </td></tr>
</table>
<ul>
<li>Detailed description:</li>
</ul>
<table class="doxtable">
<tr>
<th align="left">Packet item </th><th align="left">Description  </th></tr>
<tr>
<td align="left"><b><code>EventCode</code></b> (Size: 1 octet) </td><td align="left">Each event is assigned a 1-Octet event code used to uniquely identify different types of events. Range: 0x00 to 0xFF (The event code 0xFF is reserved for the event code used for vendor-specific debug events.) </td></tr>
<tr>
<td align="left"><b><code>Parameter Total Length</code></b> (Size: 1 octet) </td><td align="left">Length of all of the parameters contained in this packet, measured in octets </td></tr>
<tr>
<td align="left"><b><code>Event Parameter 0 - N</code></b> (Size: Parameter Total Length octets) </td><td align="left">Each event has a specific number of parameters associated with it. These parameters and the size of each of the parameter are predefined for each event. Each parameter is an integer number of octets in size. </td></tr>
</table>
<h2>Commands overview </h2>
<p>PLT FW application supports the following commands:</p><ul>
<li>BLE</li>
</ul>
<table class="doxtable">
<tr>
<th>OP code </th><th>Name </th><th>Chip support </th><th>Handled by </th><th>Description  </th></tr>
<tr>
<td>0x201E </td><td>cont_pkt_tx </td><td>DA1468x <br />
 DA1469x </td><td>BLE stack </td><td>Start test - generates BLE test reference packets at a fixed interval </td></tr>
<tr>
<td>0x2034 </td><td>TX_TEST_ENH </td><td>DA1469x </td><td>BLE stack </td><td>Starts continuous Tx at 1 or 2Mbps </td></tr>
<tr>
<td>0x201D </td><td>start_pkt_rx </td><td>DA1468x <br />
 DA1469x </td><td>BLE stack </td><td>Start test - receive BLE test reference packets at a fixed interval </td></tr>
<tr>
<td>0x2033 </td><td>RX_TEST_ENH </td><td>DA1469x </td><td>BLE stack </td><td>Starts continuous Rx at 1 or 2Mbps </td></tr>
<tr>
<td>0x201F </td><td>stoptest </td><td>DA1468x <br />
 DA1469x </td><td>BLE stack </td><td>Stop any BLE test which is in progress </td></tr>
<tr>
<td>0x0C03 </td><td>reset </td><td>DA1468x <br />
 DA1469x </td><td>BLE stack </td><td>Reset BLE Link Layer </td></tr>
<tr>
<td>0xFC81 </td><td>start_pkt_rx_stats </td><td>DA1468x </td><td>BLE adapter </td><td>Start receive test mode. </td></tr>
<tr>
<td>0xFC82 </td><td>stop_pkt_rx_stats </td><td>DA1468x </td><td>BLE adapter </td><td>Stop the activity of a RF test mode </td></tr>
<tr>
<td>0xFC83 </td><td>unmodulated OFF / TX / RX </td><td>DA1468x </td><td>BLE adapter </td><td>Start/stop transmitting or start reception a continuous wave (unmodulated transmission) </td></tr>
<tr>
<td>0xFC84 </td><td>start_cont_tx </td><td>DA1468x </td><td>BLE adapter </td><td>Start transmit test mode </td></tr>
<tr>
<td>0xFC85 </td><td>stop_cont_tx </td><td>DA1468x </td><td>BLE adapter </td><td>Stop the activity of a RF test mode </td></tr>
<tr>
<td>0xFC90 </td><td>pkt_tx_interval </td><td>DA1468x </td><td>BLE adapter </td><td>Start transmit test mode </td></tr>
<tr>
<td>0xFC16 </td><td>DBG_RX_TEST_STATS_GET </td><td>DA1469x </td><td>BLE stack </td><td>Gets the extra Rx test results </td></tr>
<tr>
<td>0xFC17 </td><td>DBG_START_CALIBRATION </td><td>DA1469x </td><td>BLE stack </td><td>Starts calibration </td></tr>
<tr>
<td>0xFC18 </td><td>DBG_GET_CAL_RESULT </td><td>DA1469x </td><td>BLE stack </td><td>Gets the result of the calibration via a Command Complete event </td></tr>
<tr>
<td>0xFC14 </td><td>DBG_TX_TEST_ENH </td><td>DA1469x </td><td>BLE stack </td><td>Starts continuous Tx at 1 or 2Mbps and sends a burst of N packets </td></tr>
<tr>
<td>0xFC15 </td><td>DBG_RX_TEST_ENH </td><td>DA1469x </td><td>BLE stack </td><td>Starts continuous Rx at 1 or 2 Mbps (enhanced) </td></tr>
<tr>
<td>0xFC3B </td><td>DBG_SET_TX_PW </td><td>DA1469x </td><td>BLE stack </td><td>Sets the Tx power </td></tr>
<tr>
<td>0xFC13 </td><td>DBG_TEST_SET_TX_PW </td><td>DA1469x </td><td>BLE stack </td><td>Sets the Tx power in Test mode </td></tr>
<tr>
<td>0xFC19 </td><td>DBG_SET_EVT_RPRT_STAT </td><td>DA1469x </td><td>BLE stack </td><td>Enables / Disables the reporting after each test 'event' </td></tr>
</table>
<blockquote class="doxtable">
<p><em>Note</em>: BLE stack supports also other typical BLE HCI commands. </p>
</blockquote>
<ul>
<li>non-BLE</li>
</ul>
<table class="doxtable">
<tr>
<th>OP code </th><th>Name </th><th>Chip support </th><th>Handled by </th><th>Description  </th></tr>
<tr>
<td>0xFE01 </td><td>hci_cmd_sleep </td><td>DA1468x <br />
 DA1469x </td><td>PLT app </td><td>Set platform sleep mode </td></tr>
<tr>
<td>0xFE02 </td><td>xtal_trim </td><td>DA1468x <br />
 DA1469x </td><td>PLT app </td><td>Manage XTAL calibration </td></tr>
<tr>
<td>0xFE04 </td><td>hci_cmd_otp_read </td><td>DA1468x <br />
 DA1469x </td><td>PLT app </td><td>Read from OTP memory </td></tr>
<tr>
<td>0xFE05 </td><td>hci_cmd_otp_write </td><td>DA1468x <br />
 DA1469x </td><td>PLT app </td><td>Write to OTP memory </td></tr>
<tr>
<td>0xFE06 </td><td>hci_cmd_rw_reg </td><td>DA1468x <br />
 DA1469x </td><td>PLT app </td><td>Read/write register </td></tr>
<tr>
<td>0xFE08 </td><td>fw_version_get </td><td>DA1468x <br />
 DA1469x </td><td>PLT app </td><td>Get PLT FW version </td></tr>
<tr>
<td>0xFE0A </td><td>hci_custom_action </td><td>DA1468x <br />
 DA1469x </td><td>PLT app </td><td>Echo back the custom action </td></tr>
<tr>
<td>0xFE0B </td><td>hci_read_adc </td><td>DA1468x <br />
 DA1469x </td><td>PLT app </td><td>Read ADC value </td></tr>
<tr>
<td>0xFE0C </td><td>hci_sensor_test </td><td>DA1468x <br />
 DA1469x </td><td>PLT app </td><td>Perform sensor test </td></tr>
<tr>
<td>0xFE0D </td><td>hci_gpio_set </td><td>DA1468x <br />
 DA1469x </td><td>PLT app </td><td>Set GPIO pin state </td></tr>
<tr>
<td>0xFE0E </td><td>hci_gpio_read </td><td>DA1468x <br />
 DA1469x </td><td>PLT app </td><td>Read GPIO pin state </td></tr>
<tr>
<td>0xFE0F </td><td>hci_uart_loop </td><td>DA1468x <br />
 DA1469x </td><td>PLT app </td><td>Echo received message </td></tr>
<tr>
<td>0xFE10 </td><td>hci_uart_baud </td><td>DA1468x <br />
 DA1469x </td><td>PLT app </td><td>Change communication UART's baudrate </td></tr>
<tr>
<td>0xFE16 </td><td>hci_ext32khz_test </td><td>DA1468x <br />
 DA1469x </td><td>PLT app </td><td>Check that external 32Khz clock is connected </td></tr>
<tr>
<td>0xFE17 </td><td>hci_gpio_wd </td><td>DA1468x <br />
 DA1469x </td><td>PLT app </td><td>Enable external watchdog notifying </td></tr>
</table>
<h2>Commands mapped to PLT FW app's function handler (no-BLE) </h2>
<h3>hci_cmd_sleep</h3>
<p>Set platform sleep mode: active, extended sleep, hibernation (DA1468x) or deep sleep (DA1469x). <br />
Command handler: <code>hci_cmd_sleep()</code> <br />
Platform: DA1468x / DA1469x <br />
Handled by: PLT app</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Parameter Length </td><td>0x03 </td></tr>
<tr>
<td>Sleep mode </td><td>0x00: active mode, 0x01: extended sleep, 0x02: hibernation (DA1468x) or deep sleep (DA1469x) </td></tr>
<tr>
<td>Sleep time (min) </td><td>0x00 - 0xFF [minutes] </td></tr>
<tr>
<td>Sleep time (sec) </td><td>0x00 - 0xFF [seconds] </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0F </td></tr>
<tr>
<td>Parameter Length </td><td>0x04 </td></tr>
<tr>
<td>Status </td><td>0x00: Command succeeded. <br />
 0x01 – 0xFF: Command failed. <br />
 See Volume 2, Part D -Error Codes in Bluetooth 4.0 specification for a list of error codes and descriptions. </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFE </td></tr>
</table>
<blockquote class="doxtable">
<p>Note: If sleep time is 0 then platform will perform sleep without future wakeup. DA1468x will not wake up after hibernation - platform reboot is required. </p>
</blockquote>
<hr/>
<h3>xtrim</h3>
<p>Manage XTAL calibration: write/increase/decrese trim value, enable/disable XTAL output on GPIO pin, perform auto calibration test. <br />
Command handler: <code>xtal_trim()</code> <br />
Platform: DA1468x / DA1469x <br />
 </p><h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value </th><th>Notes  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01   </td><td></td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x02 </td><td></td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFE </td><td></td></tr>
<tr>
<td>Parameter Length </td><td>0x03 </td><td></td></tr>
<tr>
<td>Operation </td><td>0x00: read trim val <br />
 0x01: write trim val <br />
 0x02: enable output xtal on P1_2 <br />
 0x03: increase trim value by delta <br />
 0x04: decrease trim value by delta <br />
 0x05: disable XTAL output on P1_2 <br />
 0x06: auto calibration test </td><td></td></tr>
<tr>
<td>Trim value or delta LSB </td><td>0x00-0xFF </td><td>trim value LSB when operation=1 <br />
 delta value LSB when operation=3,4 <br />
 GPIO when operation = 6 <br />
 0x00 otherwise. </td></tr>
<tr>
<td>Trim value or delta MSB </td><td>0x00-0xFF </td><td>trim value MSB when operation=1 <br />
 delta value MSB when operation=3,4 <br />
 0=16MHz, 1=32MHz when DA1468x and operation=6 <br />
 0x00 otherwise. </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value </th><th>Notes  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td><td></td></tr>
<tr>
<td>Event Code </td><td>0x0E </td><td></td></tr>
<tr>
<td>Parameter Length </td><td>0x05 </td><td></td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td><td></td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x02 </td><td></td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFE </td><td></td></tr>
<tr>
<td>Trim value LSB </td><td>0xXX </td><td>Trim value for operation=0 status code 2 for operation=6 0x0000. </td></tr>
<tr>
<td>Trim value MSB </td><td>0xXX </td><td>Trim value for operation=0 status code 2 for operation=6 0x0000. </td></tr>
</table>
<blockquote class="doxtable">
<p>Note: GPIO Px_y is encoded as (<code>x</code> &lt;&lt; 5) + <code>y</code>. E.g. P1_5 is encoded as 37 (0x25 in hex). 5...7 bits store a port number and 0...4 bits store pin number. </p>
</blockquote>
<blockquote class="doxtable">
<p>Note: XTAL trim value calibration returns zero on success. A non zero value indicates failure. </p>
</blockquote>
<hr/>
<h3>hci_otp_read</h3>
<p>Read data from OTP memory. <br />
Command handler: <code>hci_cmd_otp_read()</code> <br />
Platform: DA1468x / DA1469x <br />
Handled by: PLT app</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x04 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Parameter Length </td><td>0x03 </td></tr>
<tr>
<td>Start word address (LSB) </td><td>The 32-bits word's address </td></tr>
<tr>
<td>Start word address (MSB) </td><td></td></tr>
<tr>
<td>Words to read </td><td>Number of words to read [min=1 - max=60] </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x05 + 4 * (n words returned) </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x04 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Status </td><td>0x00 = Succeeded 0xFF = Not Succeeded </td></tr>
<tr>
<td>Words Returned </td><td>Number of words returned [min=1 - max=60] </td></tr>
<tr>
<td>Word 1 byte 0 (LSB) </td><td>Word number 1 </td></tr>
<tr>
<td>Word 1 byte 1 </td><td></td></tr>
<tr>
<td>Word 1 byte 2 </td><td></td></tr>
<tr>
<td>Word 1 byte 3 </td><td></td></tr>
<tr>
<td>... </td><td></td></tr>
<tr>
<td>Word n byte 0 (LSB) </td><td>Word number n </td></tr>
<tr>
<td>Word n byte 1 </td><td></td></tr>
<tr>
<td>Word n byte 2 </td><td></td></tr>
<tr>
<td>Word n byte 3 </td><td></td></tr>
</table>
<blockquote class="doxtable">
<p>Note: DA1468x OTP memory contains 0x4000 32-bits words. DA1469x OTP memory contains 0x400 32-bits words. </p>
</blockquote>
<hr/>
<h3>hci_otp_write</h3>
<p>Write data to OTP memory. <br />
Command handler: <code>hci_cmd_otp_write()</code> <br />
Platform: DA1468x / DA1469x <br />
Handled by: PLT app</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x05 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Parameter Length </td><td>0x03 + 4 * (n word to write) </td></tr>
<tr>
<td>Start word address (LSB) </td><td>The 32-bits word's address (must be even for DA1468x) </td></tr>
<tr>
<td>Start word address (MSB) </td><td></td></tr>
<tr>
<td>Words to write </td><td>Number of words to write [min=1 - max=60] </td></tr>
<tr>
<td>Word 1 byte 0 (LSB) </td><td>Word number 1 </td></tr>
<tr>
<td>Word 1 byte 1 </td><td></td></tr>
<tr>
<td>Word 1 byte 2 </td><td></td></tr>
<tr>
<td>Word 1 byte 3 </td><td></td></tr>
<tr>
<td>... </td><td></td></tr>
<tr>
<td>Word n byte 0 (LSB) </td><td>Word number n </td></tr>
<tr>
<td>Word n byte 1 </td><td></td></tr>
<tr>
<td>Word n byte 2 </td><td></td></tr>
<tr>
<td>Word n byte 3 </td><td></td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x05 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x05 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Status </td><td>0x00 = Succeeded 0xFF = Not Succeeded </td></tr>
<tr>
<td>Words Written </td><td>Number of words written [max=60] </td></tr>
</table>
<blockquote class="doxtable">
<p>Note: DA1468x OTP memory contains 0x4000 32-bits words. DA1469x OTP memory contains 0x400 32-bits words. </p>
</blockquote>
<hr/>
<h3>hci_cmd_read_write_reg</h3>
<p>Write/read 16-bits or 32-bits register. <br />
Command handler: <code>hci_cmd_rw_reg()</code> <br />
Platform: DA1468x / DA1469x <br />
Handled by: PLT app</p>
<h4>Command</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x06 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Parameter Length </td><td>0x09 </td></tr>
<tr>
<td>Operation </td><td>0x00=read_reg32, 0x01=write_reg32, 0x02=read_reg16, 0x03=write_reg16 </td></tr>
<tr>
<td>Address[0] (LSB) </td><td>register address byte 0 </td></tr>
<tr>
<td>Address[1] </td><td>register address byte 1 </td></tr>
<tr>
<td>Address[2] </td><td>register address byte 2 </td></tr>
<tr>
<td>Address[3] </td><td>register address byte 3 </td></tr>
<tr>
<td>Data[0] (LSB) </td><td>data byte 0 (16/32 bit mode) </td></tr>
<tr>
<td>Data[1] </td><td>data byte 1 (16/32 bit mode) </td></tr>
<tr>
<td>Data[2] </td><td>data byte 2 (32 bit mode) </td></tr>
<tr>
<td>Data[3] </td><td>data byte 3 (32 bit mode) </td></tr>
</table>
<h4>Return message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x09 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x06 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Operation </td><td>0x00=read_reg32, 0x01=write_reg32, 0x02=read_reg16, 0x03=write_reg16 </td></tr>
<tr>
<td>Status </td><td>0x00=Succeeded 0xFF=Not Succeeded </td></tr>
<tr>
<td>Data[0] (LSB) </td><td>data byte 0 (16/32 bit mode) </td></tr>
<tr>
<td>Data[1] </td><td>data byte 1 (16/32 bit mode) </td></tr>
<tr>
<td>Data[2] </td><td>data byte 2 (32 bit mode) </td></tr>
<tr>
<td>Data[3] </td><td>data byte 3 (32 bit mode) </td></tr>
</table>
<hr/>
<h3>hci_firmware_version_get</h3>
<p>Get the Bluetooth controller version and PLT FW version strings. <br />
Command handler: <code>fw_version_get()</code> <br />
Platform: DA1468x / DA1469x <br />
Handled by: PLT app</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x08 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Parameter Length </td><td>0x00 </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x45 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x08 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>BLE_version_length </td><td>0xXX (Max value 32). </td></tr>
<tr>
<td>Application_version_length (Max value 32) </td><td>0xXX (Max value 32). </td></tr>
<tr>
<td>BLE_common firmware_version (32 bytes) </td><td>32 bytes string containing the BLE common firmware version. </td></tr>
<tr>
<td>BLE_application_firmware_version (32 bytes) </td><td>32 bytes string containing the BLE application firmware version. </td></tr>
</table>
<hr/>
<h3>hci_custom_action</h3>
<p>Perform a custom action - echo one byte from command payload. <br />
Command handler: <code>hci_custom_action()</code> <br />
Platform: DA1468x / DA1469x <br />
 </p><h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x0A </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Parameter Length </td><td>0x01 </td></tr>
<tr>
<td>Custom action </td><td>0xXX </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x0A </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Return Data </td><td>0xXX (echos back the Custom action byte received) </td></tr>
</table>
<hr/>
<h3>hci_read_adc</h3>
<p>Read value from analog input (battery voltage). <br />
Command handler: <code>hci_read_adc()</code> <br />
Platform: DA1468x / DA1469x <br />
 </p><h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x0B </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Parameter Length </td><td>0x00 </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Val  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x05 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x0B </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Result (LSB) </td><td>GP_ADC_RESULT_REG (LSB) </td></tr>
<tr>
<td>Result (MSB) </td><td>GP_ADC_RESULT_REG (MSB) </td></tr>
</table>
<hr/>
<h3>hci_sensor_test</h3>
<p>Perform a write or read using master I2C or SPI interface. <br />
Command handler: <code>hci_sensor_test()</code> <br />
Platform: DA1468x / DA1469x <br />
 </p><h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x0C </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Parameter Length </td><td>0x11 </td></tr>
<tr>
<td>Iface </td><td>0=SPI, 1=I2C </td></tr>
<tr>
<td>Read/Write </td><td>0=Read, 1=Write </td></tr>
<tr>
<td>spi_clk_port or i2c_scl_port </td><td>P0=0, P1=1, … </td></tr>
<tr>
<td>spi_clk_pin or i2c_scl_pin </td><td>Px_0=0, Px_1=1, … </td></tr>
<tr>
<td>spi_di_pin or i2c_sda_pin </td><td>P0=0, P1=1, … </td></tr>
<tr>
<td>spi_di_pin or i2c_sda_pin </td><td>Px_0=0, Px_1=1, … </td></tr>
<tr>
<td>spi_do_port </td><td>P0=0, P1=1, … </td></tr>
<tr>
<td>spi_do_pin </td><td>Px_0=0, Px_1=1, … </td></tr>
<tr>
<td>spi_cs_port </td><td>P0=0, P1=1, … </td></tr>
<tr>
<td>spi_cs_pin </td><td>Px_0=0, Px_1=1, … </td></tr>
<tr>
<td>Register address </td><td>A sensor register address </td></tr>
<tr>
<td>Register data to write </td><td>Data to write to the sensor register if Read/Write=1 </td></tr>
<tr>
<td>I2C slave address </td><td>The sensor I2C slave address used if Iface=1 </td></tr>
<tr>
<td>int_gpio_check </td><td>0=Do nothing. 1=Set the following GPIO to input pull-down after the interface (SPI or I2C) has been initialized </td></tr>
<tr>
<td>int_port </td><td>P0=0, P1=1, … </td></tr>
<tr>
<td>int_pin </td><td>Px_0=0, Px_1=1, … </td></tr>
<tr>
<td>Pins voltage level </td><td>0=3.3V, 1=1.8V </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x0C </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Sensor register data or INT GPIO level </td><td>0xXX. Byte read from address specified in byte “Register address” shown in the command format above, or the INT GPIO level (high=0x01 or low=0x00) if int_gpio_check=1 </td></tr>
</table>
<hr/>
<h3>hci_gpio_set</h3>
<p>Configure GPIO pin. <br />
Command handler: <code>hci_gpio_set()</code> <br />
Platform: DA1468x / DA1469x <br />
 </p><h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x0D </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Parameter Length </td><td>0x06 </td></tr>
<tr>
<td>GPIO </td><td>An enumeration of all available GPIOs. GPIO Px_y is encoded as (<code>x</code> &lt;&lt; 5) + <code>y</code>. 5…7 bits store a port number and 0…4 bits store pin number </td></tr>
<tr>
<td>Mode </td><td>0=Input, 1=Input pullup, 2=Input pulldown, 3=Output, 4=Output Push Pull, 5= Output Open Drain </td></tr>
<tr>
<td>Voltage level </td><td>0=3.3V, 1=1.8V </td></tr>
<tr>
<td>Reset/Set </td><td>0=Reset, 1=Set. Valid in output modes. If PWM&gt;0 then Reset=PWM stop. Set=PWM start </td></tr>
<tr>
<td>PWM </td><td>0=No PWM, Other=PWM frequency (multiply of 1kHz) </td></tr>
<tr>
<td>PWM duty cycle </td><td>0x00 - 0x64 (in percentages) </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>Byte Description </td><td>Value </td></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x0D </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Status </td><td>0=Succeeded, 0xFF=Error </td></tr>
</table>
<blockquote class="doxtable">
<p>Note: DA1468x support 3 LED drivers which can be used as GPIO: 0xF1-&gt;LED1, 0xF2-&gt;LED2, 0xF3-&gt;LED3. DA1469x support 2 LED drivers which can be used as GPIO: 0xF1-&gt;LED1, 0xF2-&gt;LED2. </p>
</blockquote>
<blockquote class="doxtable">
<p>Note: If the GPIO pin is used by UART then the error is returned. </p>
</blockquote>
<blockquote class="doxtable">
<p>Note: If GPIO is a JTAG pin, then debugger is disabled. </p>
</blockquote>
<hr/>
<h3>hci_gpio_read</h3>
<p>Get GPIO pin state (low/high). <br />
Command handler: <code>hci_gpio_read()</code> <br />
Platform: DA1468x / DA1469x <br />
 </p><h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x0E </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Parameter Length </td><td>0x01 </td></tr>
<tr>
<td>GPIO </td><td>An enumeration of all available GPIOs. GPIO Px_y is encoded as (<code>x</code> &lt;&lt; 5) + <code>y</code>. 5…7 bits store a port number and 0…4 bits store pin number. </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x0E </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Reset/Set </td><td>0=Low, 1=High </td></tr>
</table>
<hr/>
<h3>hci_uart_loop</h3>
<p>Send back received data. <br />
Command handler: <code>hci_uart_loop()</code> <br />
Platform: DA1468x / DA1469x <br />
 </p><h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x0F </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Parameter Length </td><td>Variable </td></tr>
<tr>
<td>Data[XX] </td><td>Data to be echoed back in UART. Variable length. </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x0F </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Data[XX] </td><td>Loop back UART data. Variable length. </td></tr>
</table>
<hr/>
<h3>hci_uart_baud</h3>
<p>Change communication UART baudrate. <br />
Command handler: <code>hci_uart_baud()</code> <br />
Platform: DA1468x / DA1469x <br />
 </p><h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x10 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Parameter Length </td><td>0x01 </td></tr>
<tr>
<td>Data </td><td>Baud Rate: <br />
 0 ==&gt; 9600 <br />
 1 ==&gt; 19200 <br />
 2 ==&gt; 57600 <br />
 3 ==&gt; 115200 <br />
 4 ==&gt; 1000000 </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x10 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Status </td><td>0x0=Succeeded, 0x1=Error </td></tr>
</table>
<blockquote class="doxtable">
<p>Note: Response message is sent using the previous baudrate. </p>
</blockquote>
<hr/>
<h3>hci_ext32khz_test</h3>
<p>Check that external 32Khz clock is connected by performing clock calibration. <br />
Command handler: <code>hci_ext32khz_test()</code> <br />
Platform: DA1468x / DA1469x <br />
Handled by: PLT app</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x16 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Parameter Length </td><td>0x00 </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x16 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Status </td><td>0x00=Succeeded, 0xFF=Not Succeeded </td></tr>
</table>
<hr/>
<h3>hci_gpio_wd</h3>
<p>Enable external watchdog notifying. Start square wave on QPIO pin: 15ms high state, 2s low state. <br />
Command handler: <code>hci_gpio_wd()</code> <br />
Platform: DA1468x / DA1469x <br />
Handled by: PLT app</p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x17 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Parameter Length </td><td>0x02 </td></tr>
<tr>
<td>gpio_pad </td><td>An enumeration of all available GPIOs. GPIO Px_y is encoded as (<code>x</code> &lt;&lt; 5) + <code>y</code>. 5…7 bits store a port number and 0…4 bits store pin number. </td></tr>
<tr>
<td>gpio_lvl </td><td>0x00=3.3[V] 0x01=1.8[V] </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x17 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFE </td></tr>
<tr>
<td>Status </td><td>0x00=Succeeded, 0xFF=Not Succeeded </td></tr>
</table>
<blockquote class="doxtable">
<p>Note: The state of the pin is not changed during sleep. </p>
</blockquote>
<hr/>
<h2>Commands NOT mapped to a function handler (BLE) </h2>
<h3>cont_pkt_tx</h3>
<p>Start test - generates BLE test reference packets at a fixed interval. <br />
Platform: DA1468x / DA1469x <br />
Handled by: <code>BLE stack</code></p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x1E </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0x20 </td></tr>
<tr>
<td>Parameter Length </td><td>0x03 </td></tr>
<tr>
<td>Frequency </td><td><code>= (F – 2402) / 2</code>, where F ranges from 2402 MHz to 2480 MHz. <br />
 Range: 0x00 – 0x27. </td></tr>
<tr>
<td>Data Length </td><td>0x01-0x25: Length in bytes of payload data in each packet </td></tr>
<tr>
<td>Payload Type </td><td>0x00: Pseudo-Random bit sequence 9 <br />
 0x01: Pattern of alternating bits ‘11110000’ <br />
 0x02: Pattern of alternating bits ‘10101010’ <br />
 0x03: Pseudo-Random bit sequence 15 <br />
 0x04: Pattern of All ‘1’ bits <br />
 0x05: Pattern of All ‘0’ bits <br />
 0x06: Pattern of alternating bits ‘00001111’ <br />
 0x07: Pattern of alternating bits ‘0101’ </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x1E </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0x20 </td></tr>
<tr>
<td>Status </td><td>0x00: command succeeded. <br />
 0x01 – 0xFF: command failed. <br />
 See Volume 2, Part D -Error Codes in Bluetooth 4.0 specification for a list of error codes and descriptions. </td></tr>
</table>
<hr/>
<h3>TX_TEST_ENH</h3>
<p>Starts continuous Tx at 1 or 2Mbps. <br />
Platform: DA1469x <br />
Handled by: <code>BLE stack</code></p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x34 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0x20 </td></tr>
<tr>
<td>Parameter Length </td><td>0x04 </td></tr>
<tr>
<td>TX_Channel </td><td><code>= (F – 2402) / 2</code>, where F ranges from 2402 MHz to 2480 MHz. <br />
 Range: 0x00 – 0x27. </td></tr>
<tr>
<td>Length_Of_Test_Data </td><td>Length in bytes of payload data in each packet. <br />
 0 is not accepted </td></tr>
<tr>
<td>Packet_Payload </td><td>0x00: Pseudo-Random bit sequence 9 <br />
 0x01: Pattern of alternating bits ‘11110000’ <br />
 0x02: Pattern of alternating bits ‘10101010’ <br />
 0x03: Pseudo-Random bit sequence 15 <br />
 0x04: Pattern of All ‘1’ bits <br />
 0x05: Pattern of All ‘0’ bits <br />
 0x06: Pattern of alternating bits ‘00001111’ <br />
 0x07: Pattern of alternating bits ‘0101’ </td></tr>
<tr>
<td>PHY </td><td>0x01: Transmitter set to use the LE 1M PHY. <br />
 0x02: Transmitter set to use the LE 2M PHY. </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x34 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0x20 </td></tr>
<tr>
<td>Status </td><td>0x00: command succeeded. <br />
 0x01 – 0xFF: command failed. <br />
 See Volume 2, Part D -Error Codes in Bluetooth 4.0 specification for a list of error codes and descriptions. </td></tr>
</table>
<hr/>
<h3>start_pkt_rx</h3>
<p>Start test - receive BLE test reference packets at a fixed interval. <br />
Platform: DA1468x / DA1469x <br />
Handled by: <code>BLE stack</code></p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x1D </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0x20 </td></tr>
<tr>
<td>Parameter Length </td><td>0x01 </td></tr>
<tr>
<td>Frequency </td><td><code>= (F – 2402) / 2</code>, where F ranges from 2402 MHz to 2480 MHz. <br />
 Range: 0x00 – 0x27. </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x1D </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0x20 </td></tr>
<tr>
<td>Status </td><td>0x00: Command succeeded. <br />
 0x01 – 0xFF: Command failed. <br />
 See Volume 2, Part D -Error Codes in Bluetooth 4.0 specification for a list of error codes and descriptions. </td></tr>
</table>
<hr/>
<h3>RX_TEST_ENH</h3>
<p>Starts continuous Rx at 1 or 2Mbps. <br />
Platform: DA1469x <br />
Handled by: <code>BLE stack</code></p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x33 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0x20 </td></tr>
<tr>
<td>Parameter Length </td><td>0x03 </td></tr>
<tr>
<td>RX_Channel </td><td><code>= (F – 2402) / 2</code>, where F ranges from 2402 MHz to 2480 MHz. <br />
 Range: 0x00 – 0x27. </td></tr>
<tr>
<td>PHY </td><td>0x01: Receiver set to use the LE 1M PHY. <br />
 0x02: Receiver set to use the LE 2M PHY. </td></tr>
<tr>
<td>Modulation_Index </td><td>This parameter is currently ignored. </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x33 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0x20 </td></tr>
<tr>
<td>Status </td><td>0x00: command succeeded. <br />
 0x01 – 0xFF: command failed. <br />
 See Volume 2, Part D -Error Codes in Bluetooth 4.0 specification for a list of error codes and descriptions. </td></tr>
</table>
<hr/>
<h3>stoptest</h3>
<p>Stop any BLE test which is in progress. <br />
Platform: DA1468x / DA1469x <br />
Handled by: <code>BLE stack</code></p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x1F </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0x20 </td></tr>
<tr>
<td>Parameter Length </td><td>0x00 </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x06 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x1F </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0x20 </td></tr>
<tr>
<td>Status </td><td>0x00: Command succeeded. <br />
 0x01-0xFF: Command failed. <br />
 See Volume 2, Part D -Error Codes in Bluetooth 4.0 specification for a list of error codes and descriptions. </td></tr>
<tr>
<td>Number of packets received / transmitted LSB </td><td>0xXX </td></tr>
<tr>
<td>Number of packets received / transmitted MSB </td><td>0xXX </td></tr>
</table>
<hr/>
<h3>reset</h3>
<p>Reset BLE Link Layer. <br />
After the reset is completed, the current operational state will be lost. <br />
The Controller will enter standby mode. <br />
The Controller will automatically revert to the default values for the parameters for which default values are defined in the specification. <br />
Platform: DA1468x \ DA1469x <br />
Handled by: <code>BLE stack</code></p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x03 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0x0C </td></tr>
<tr>
<td>Parameter Length </td><td>0x00 </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x03 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0x0c </td></tr>
<tr>
<td>Status </td><td>0x00: Reset command succeeded, was received and will be executed. <br />
 0x01-0xFF: Reset command failed. <br />
 See Volume 2, Part D -Error Codes in Bluetooth 4.0 specification for a list of error codes and descriptions." </td></tr>
</table>
<hr/>
<h3>start_pkt_rx_stats</h3>
<p>Start receive test mode: checks the parameters, set the receive mode parameters, turn on the mode and set the LLM state. <br />
Platform: DA1468x <br />
Handled by: <code>BLE adapter</code></p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x81 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Parameter Length </td><td>0x01 </td></tr>
<tr>
<td>Frequency </td><td><code>= (F – 2402) / 2</code>, where F ranges from 2402 MHz to 2480 MHz. <br />
 Range: 0x00 – 0x27. </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x81 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Status </td><td>0x00: Command succeeded. <br />
 0x01 – 0xFF: Command failed. <br />
 See Volume 2, Part D -Error Codes in Bluetooth 4.0 specification for a list of error codes and descriptions. </td></tr>
</table>
<hr/>
<h3>stop_pkt_rx_stats</h3>
<p>Stop the activity of a RF test mode and flushes all the RX data for this event. <br />
Platform: DA1468x <br />
Handled by: <code>BLE adapter</code></p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x82 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Parameter Length </td><td>0x00 </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x0C </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x82 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Status </td><td>0x00: Command succeeded. <br />
 0x01 – 0xFF: Command failed. <br />
 See Volume 2, Part D -Error Codes in Bluetooth 4.0 specification for a list of error codes and descriptions. </td></tr>
<tr>
<td>Number of received packets LSB </td><td>0xXX </td></tr>
<tr>
<td>Number of received packets MSB </td><td>0xXX </td></tr>
<tr>
<td>Number of received packets with sync errors LSB </td><td>0xXX </td></tr>
<tr>
<td>Number of received packets with sync errors MSB </td><td>0xXX </td></tr>
<tr>
<td>Number of received packets with CRC errors LSB </td><td>0xXX </td></tr>
<tr>
<td>Number of received packets with CRC errors MSB </td><td>0xXX </td></tr>
<tr>
<td>RSSI LSB </td><td>0xXX </td></tr>
<tr>
<td>RSSI MSB </td><td>0xXX </td></tr>
</table>
<hr/>
<h3>unmodulated OFF / TX / RX</h3>
<p>Start transmitting (TX), stop transmitting (OFF) or start reception (RX) a continuous wave (unmodulated transmission). <br />
Platform: DA1468x <br />
Handled by: <code>BLE adapter</code></p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x83 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Parameter Length </td><td>0x02 </td></tr>
<tr>
<td>Operation </td><td>0x4F: OFF <br />
 0x54: unmodulated TX <br />
 0x52: unmodulated RX </td></tr>
<tr>
<td>Frequency </td><td><code>= (F – 2402) / 2</code>, where F ranges from 2402 MHz to 2480 MHz. <br />
 Range: 0x00 – 0x27. </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x03 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x83 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFC </td></tr>
</table>
<hr/>
<h3>start_cont_tx</h3>
<p>Start transmit test mode: checks the parameters, set the transmit mode parameters, turn on the mode and set the LLM state. <br />
Platform: DA1468x <br />
Handled by: <code>BLE adapter</code></p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x84 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Parameter Length </td><td>0x02 </td></tr>
<tr>
<td>Frequency </td><td><code>= (F – 2402) / 2</code>, where F ranges from 2402 MHz to 2480 MHz. <br />
 Range: 0x00 – 0x27. </td></tr>
<tr>
<td>Payload Type </td><td>0x00: Pseudo-Random bit sequence 9 <br />
 0x01: Pattern of alternating bits ‘11110000’ <br />
 0x02: Pattern of alternating bits ‘10101010’ <br />
 0x03: Pseudo-Random bit sequence 15 <br />
 0x04: Pattern of All ‘1’ bits <br />
 0x05: Pattern of All ‘0’ bits <br />
 0x06: Pattern of alternating bits ‘00001111’ <br />
 0x07: Pattern of alternating bits ‘0101’ </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x84 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Status </td><td>0x00: Command succeeded. <br />
 0x01 – 0xFF: Command failed. <br />
 See Volume 2, Part D -Error Codes in Bluetooth 4.0 specification for a list of error codes and descriptions. </td></tr>
</table>
<hr/>
<h3>stop_cont_tx</h3>
<p>Stop the activity of a RF test mode and flushes all the TX data for this event. <br />
Platform: DA1468x <br />
Handled by: <code>BLE adapter</code></p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x85 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Parameter Length </td><td>0x00 </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x85 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Status </td><td>0x00: Command succeeded. <br />
 0x01 – 0xFF: Command failed. <br />
 See Volume 2, Part D -Error Codes in Bluetooth 4.0 specification for a list of error codes and descriptions. </td></tr>
</table>
<hr/>
<h3>pkt_tx_interval</h3>
<p>Start transmit test mode: checks the parameters, set the transmit mode parameters, turn on the mode and set the LLM state. <br />
Platform: DA1468x <br />
Handled by: <code>BLE adapter</code></p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x90 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Parameter Length </td><td>0x09 </td></tr>
<tr>
<td>Frequency </td><td><code>= (F – 2402) / 2</code>, where F ranges from 2402 MHz to 2480 MHz. <br />
 Range: 0x00 – 0x27. </td></tr>
<tr>
<td>Data Length </td><td>0x01-0x25 Length in bytes of payload data in each packet </td></tr>
<tr>
<td>Payload Type </td><td>0x00: Pseudo-Random bit sequence 9 <br />
 0x01: Pattern of alternating bits ‘11110000’ <br />
 0x02: Pattern of alternating bits ‘10101010’ <br />
 0x03: Pseudo-Random bit sequence 15 <br />
 0x04: Pattern of All ‘1’ bits <br />
 0x05: Pattern of All ‘0’ bits <br />
 0x06: Pattern of alternating bits ‘00001111’ <br />
 0x07: Pattern of alternating bits ‘0101’ </td></tr>
<tr>
<td>Number of packets to transmit LSB </td><td>0xXX </td></tr>
<tr>
<td>Number of packets to transmit MSB </td><td>0xXX </td></tr>
<tr>
<td>Interval in us byte 0 (LSB) </td><td>0xXX </td></tr>
<tr>
<td>Interval in us byte 1 </td><td>0xXX </td></tr>
<tr>
<td>Interval in us byte 2 </td><td>0xXX </td></tr>
<tr>
<td>Interval in us byte 3 (MSB) </td><td>0xXX </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0F </td></tr>
<tr>
<td>Parameter Length </td><td>0x04 </td></tr>
<tr>
<td>Status </td><td>0x00: Command succeeded. <br />
 0x01 – 0xFF: Command failed. <br />
 See Volume 2, Part D -Error Codes in Bluetooth 4.0 specification for a list of error codes and descriptions. </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x90 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFC </td></tr>
</table>
<h4>Message returned when transmission is completed</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Parameter Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x90 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Status </td><td>0x00: Command successfully completed <br />
 0x01: Illegal params </td></tr>
</table>
<hr/>
<h3>DBG_RX_TEST_STATS_GET</h3>
<p>Gets the extra Rx test results. <br />
Platform: DA1469x <br />
Handled by: <code>BLE stack</code></p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x16 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Parameter Length </td><td>0x00 </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Length </td><td>0x0E </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x16 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Status </td><td>0x00: Command succeeded. <br />
 0x01 – 0xFF: Command failed. </td></tr>
<tr>
<td>RX packets total LSB </td><td>0xXX </td></tr>
<tr>
<td>RX packets total MSB </td><td>0xXX </td></tr>
<tr>
<td>RX packets SYNCERR LSB </td><td>0xXX </td></tr>
<tr>
<td>RX packets SYNCERR MSB </td><td>0xXX </td></tr>
<tr>
<td>RX packets LENERR LSB </td><td>0xXX </td></tr>
<tr>
<td>RX packets LENERR MSB </td><td>0xXX </td></tr>
<tr>
<td>RX packets CRCERR LSB </td><td>0xXX </td></tr>
<tr>
<td>RX packets CRCERR MSB </td><td>0xXX </td></tr>
<tr>
<td>RSSI LSB </td><td>0xXX </td></tr>
<tr>
<td>RSSI MSB </td><td>0xXX </td></tr>
</table>
<hr/>
<h3>DBG_START_CALIBRATION</h3>
<p>Starts RF calibration. <br />
Platform: DA1469x <br />
Handled by: <code>BLE stack</code></p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x17 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Parameter Length </td><td>0x01 </td></tr>
<tr>
<td>Calibration type </td><td>0x01: FULL <br />
 0x02: DCOFF <br />
 0x03: IFF <br />
 0x04: KDCO ADPLL <br />
 0x06: TX DIV2 <br />
 0x09: TEMPERATURE </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x17 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Status </td><td>0x00: Command succeeded. <br />
 0x01 – 0xFF: Command failed. </td></tr>
</table>
<hr/>
<h3>DBG_GET_CAL_RESULT</h3>
<p>Gets the result of the calibration via a Command Complete event. <br />
The event is returned when the calibration completes. <br />
Platform: DA1469x <br />
Handled by: <code>BLE stack</code></p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x18 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Parameter Length </td><td>0x00 </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Length </td><td>0x31 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x18 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Status </td><td>0x00: Command succeeded. <br />
 0x1F: Command failed. </td></tr>
<tr>
<td>DC-offset result </td><td>0xXX </td></tr>
<tr>
<td>IFF result LSB </td><td>0xXX </td></tr>
<tr>
<td>IFF result </td><td>0xXX </td></tr>
<tr>
<td>IFF result </td><td>0xXX </td></tr>
<tr>
<td>IFF result MSB </td><td>0xXX </td></tr>
<tr>
<td>KDCO result [0] </td><td>0xXX </td></tr>
<tr>
<td>KDCO result [1] </td><td>0xXX </td></tr>
<tr>
<td>KDCO result [2] </td><td>0xXX </td></tr>
<tr>
<td>KDCO result [3] </td><td>0xXX </td></tr>
<tr>
<td>KDCO result [4] </td><td>0xXX </td></tr>
<tr>
<td>KDCO result [5] </td><td>0xXX </td></tr>
<tr>
<td>KDCO result [6] </td><td>0xXX </td></tr>
<tr>
<td>KDCO result [7] </td><td>0xXX </td></tr>
<tr>
<td>KDTC result [0] LSB </td><td>0xXX </td></tr>
<tr>
<td>KDTC result [0] MSB </td><td>0xXX </td></tr>
<tr>
<td>KDTC result [1] LSB </td><td>0xXX </td></tr>
<tr>
<td>KDTC result [1] MSB </td><td>0xXX </td></tr>
<tr>
<td>KDTC result [2] LSB </td><td>0xXX </td></tr>
<tr>
<td>KDTC result [2] MSB </td><td>0xXX </td></tr>
<tr>
<td>KDTC result [3] LSB </td><td>0xXX </td></tr>
<tr>
<td>KDTC result [3] MSB </td><td>0xXX </td></tr>
<tr>
<td>KDTC result [4] LSB </td><td>0xXX </td></tr>
<tr>
<td>KDTC result [4] MSB </td><td>0xXX </td></tr>
<tr>
<td>KDTC result [5] LSB </td><td>0xXX </td></tr>
<tr>
<td>KDTC result [5] MSB </td><td>0xXX </td></tr>
<tr>
<td>KDTC result [6] LSB </td><td>0xXX </td></tr>
<tr>
<td>KDTC result [6] MSB </td><td>0xXX </td></tr>
<tr>
<td>KDTC result [7] LSB </td><td>0xXX </td></tr>
<tr>
<td>KDTC result [7] MSB </td><td>0xXX </td></tr>
<tr>
<td>Tx-Div2 result [0] </td><td>0xXX </td></tr>
<tr>
<td>Tx-Div2 result [1] </td><td>0xXX </td></tr>
<tr>
<td>Tx-Div2 result [2] </td><td>0xXX </td></tr>
<tr>
<td>Tx-Div2 result [3] </td><td>0xXX </td></tr>
<tr>
<td>Tx-Div2 result [4] </td><td>0xXX </td></tr>
<tr>
<td>Tx-Div2 result [5] </td><td>0xXX </td></tr>
<tr>
<td>Tx-Div2 result [6] </td><td>0xXX </td></tr>
<tr>
<td>Tx-Div2 result [7] </td><td>0xXX </td></tr>
<tr>
<td>IQ-Div2 result [0] </td><td>0xXX </td></tr>
<tr>
<td>IQ-Div2 result [1] </td><td>0xXX </td></tr>
<tr>
<td>IQ-Div2 result [2] </td><td>0xXX </td></tr>
<tr>
<td>IQ-Div2 result [3] </td><td>0xXX </td></tr>
<tr>
<td>IQ-Div2 result [4] </td><td>0xXX </td></tr>
<tr>
<td>IQ-Div2 result [5] </td><td>0xXX </td></tr>
<tr>
<td>IQ-Div2 result [6] </td><td>0xXX </td></tr>
<tr>
<td>IQ-Div2 result [7] </td><td>0xXX </td></tr>
</table>
<hr/>
<h3>DBG_TX_TEST_ENH</h3>
<p>Starts continuous Tx at 1 or 2 Mbps and sends a burst of N packets. <br />
Platform: DA1469x <br />
Handled by: <code>BLE stack</code></p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x14 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Parameter Length </td><td>0x0B </td></tr>
<tr>
<td>TX Freq </td><td>As defined in 5.0/Vol.2/Part E/7.8.51 </td></tr>
<tr>
<td>Test Data Len </td><td>0xXX, Length in bytes of payload data in each packet. It must hold N &gt; 0. </td></tr>
<tr>
<td>PK Payload type </td><td>As defined in 5.0/Vol.2/Part E/7.8.51 </td></tr>
<tr>
<td>TX Phy </td><td>0x01: transmitter set to use the LE 1M PHY, 0x02: transmitter set to use the LE 2M PHY </td></tr>
<tr>
<td>Test Type </td><td>0x01: MODULATED_INFINITE_PACK_TEST, <br />
 0x02: MODULATED_INFINITE_NONPACK_TEST, <br />
 0x03: MODULATED_FINITE_PACK_TEST, <br />
 0x04: UNMODULATED_INFINITE_NONPACK_TEST </td></tr>
<tr>
<td>TX Packet Num LSB </td><td>0xXX, Number of packets to be transmitted. </td></tr>
<tr>
<td>TX Packet Num MSB </td><td></td></tr>
<tr>
<td>TX Interval us LSB </td><td>0: The packet interval is computed as specified in Core Specification 5.0 volume 6, part F, section 4.1.6, 1 to 149: Forbidden, &gt;=150: The packet IFS in microseconds. </td></tr>
<tr>
<td>TX Interval us </td><td></td></tr>
<tr>
<td>TX Interval us </td><td></td></tr>
<tr>
<td>TX Interval us MSB </td><td></td></tr>
</table>
<blockquote class="doxtable">
<p>Note: In MODULATED_INFINITE_PACK_TEST (0x01): TX Packet Num value is ignored. </p>
</blockquote>
<blockquote class="doxtable">
<p>Note: In MODULATED_INFINITE_NONPACK_TEST (0x02): TX Packet Num and TX Interval us values are ignored. Test Data Len is not applicable but it must be set to a value &gt; 1. </p>
</blockquote>
<blockquote class="doxtable">
<p>Note: In MODULATED_FINITE_PACK_TEST (0x03): if TX Packet Num is 0 then an error is returned. </p>
</blockquote>
<blockquote class="doxtable">
<p>Note: In UNMODULATED_INFINITE_NONPACK_TEST (0x04): Test Data Len, PK Payload type, TX Phy, TX Packet Num and TX Interval us values are ignored. </p>
</blockquote>
<blockquote class="doxtable">
<p>Note: There is no upper bound for the IFS so we accept any value up to 0xFFFFFFFF. However huge values are of no practical value. </p>
</blockquote>
<blockquote class="doxtable">
<p>Note: If Tx Phy = 2, then Test Data Length should be &gt; 1. </p>
</blockquote>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x14 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Status </td><td>0x00: Command succeeded. <br />
 0x01 – 0xFF: Command failed. </td></tr>
</table>
<hr/>
<h3>DBG_RX_TEST_ENH</h3>
<p>Starts continuous Rx at 1 or 2 Mbps (enhanced). <br />
Platform: DA1469x <br />
Handled by: <code>BLE stack</code></p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x15 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Parameter Length </td><td>0x0C </td></tr>
<tr>
<td>RX Freq </td><td>Rx channel. As defined in 5.0/Vol.2/Part E/7.8.50 </td></tr>
<tr>
<td>RX Phy </td><td>0x01: receiver set to use the LE 1M PHY, 0x02: receiver set to use the LE 2M PHY </td></tr>
<tr>
<td>RX Mod </td><td>Modulation index. This parameter is currently ignored. </td></tr>
<tr>
<td>Test Data Len </td><td>Transmitter side data length </td></tr>
<tr>
<td>RX Interval us LSB </td><td>Transmitter side packet interval. </td></tr>
<tr>
<td>RX Interval us </td><td></td></tr>
<tr>
<td>RX Interval us </td><td></td></tr>
<tr>
<td>RX Interval us MSB </td><td></td></tr>
<tr>
<td>Normal Winsz LSB </td><td>Rx window size applied at "event interval", Units: microseconds </td></tr>
<tr>
<td>Normal Winsz MSB </td><td></td></tr>
<tr>
<td>First Winsz LSB </td><td>Rx window size applied to the 1st reception ("scan" mode), Units: slots (1 slot = 625 microseconds) </td></tr>
<tr>
<td>First Winsz MSB </td><td></td></tr>
</table>
<blockquote class="doxtable">
<p>Note: If another test is running or if any parameter is wrong, then an error status is returned. </p>
</blockquote>
<blockquote class="doxtable">
<p>Note: If RX Interval us &gt; 0, then the following must hold: First Winsz &gt; 0, 0 &lt; Normal Winsz &lt;= 8171, 0 &lt; Test Data Len &lt;= 251, RX Interval us &gt;= 150, RX Interval us &gt;= Normal Winsz + 100. </p>
</blockquote>
<blockquote class="doxtable">
<p>Note: The Normal Winsz is in usec or slots and is 14-bits wide counting up to 8171 usec. </p>
</blockquote>
<blockquote class="doxtable">
<p>Note: The actual Rx window will open for 2*Normal Winsz + SYNC_WORD_duration (16382 usec maximum). </p>
</blockquote>
<blockquote class="doxtable">
<p>Note: The First Winsz is in 625usec slots and is 14-bits wide. </p>
</blockquote>
<blockquote class="doxtable">
<p>Note: The actual Rx window in this case opens for First Winsz duration. </p>
</blockquote>
<blockquote class="doxtable">
<p>Note: The RX Interval us must be the same as the TX Interval us that has been passed to the Tx side. </p>
</blockquote>
<blockquote class="doxtable">
<p>Note: The report counters are reset whenever an Rx test is started. </p>
</blockquote>
<blockquote class="doxtable">
<p>Note: The Test Data Len is mandatory and must match the payload length transimitted by the Tx side. </p>
</blockquote>
<blockquote class="doxtable">
<p>Note: In case of a SYNC error, the Rx window will not be increased. </p>
</blockquote>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x15 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Status </td><td>0x00: Command succeeded. <br />
 0x01 – 0xFF: Command failed. </td></tr>
</table>
<hr/>
<h3>DBG_SET_TX_PW</h3>
<p>Sets the Tx power. <br />
Platform: DA1469x <br />
Handled by: <code>BLE stack</code></p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x3B </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Parameter Length </td><td>0x02 </td></tr>
<tr>
<td>AIROP </td><td>Bit field, bits description: 0 - Advertising, 1 - Scanning, 2 - Initiation, 3 - RF test </td></tr>
<tr>
<td>PW Lvl </td><td>0x00 - 0x11, 0x01: the lowest TX power level. <br />
 0x11: the maximum TX power level. </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x3B </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Status </td><td>0x00: Command succeeded. <br />
 0x01 – 0xFF: Command failed. </td></tr>
</table>
<hr/>
<h3>DBG_TEST_SET_TX_PW</h3>
<p>Sets the Tx power in Test mode. <br />
Platform: DA1469x <br />
Handled by: <code>BLE stack</code></p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x13 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Parameter Length </td><td>0x03 </td></tr>
<tr>
<td>Pwr Level </td><td>0x00 - 0x0F </td></tr>
<tr>
<td>Coarse Atten </td><td>0x00 - 0x02, valid only if Pwr Level = 0x01 </td></tr>
<tr>
<td>Femonly Fine Atten </td><td>0x00 - 0x06 </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x13 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Status </td><td>0x00: Command succeeded. <br />
 0x01 – 0xFF: Command failed. </td></tr>
</table>
<hr/>
<h3>DBG_SET_EVT_RPRT_STAT</h3>
<p>Enables / Disables the reporting after each test 'event'. <br />
When Enable is a non-zero value after each test 'event', an HCI Event will be sent via the Mailbox containing information about the current status. <br />
Platform: DA1469x <br />
Handled by: <code>BLE stack</code></p>
<h4>Command Format</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Command Packet </td><td>0x01 </td></tr>
<tr>
<td>Command Opcode LSB </td><td>0x19 </td></tr>
<tr>
<td>Command Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Parameter Length </td><td>0x01 </td></tr>
<tr>
<td>Enable </td><td>0x00: Disable, 0x01 - 0xFF: Enable </td></tr>
</table>
<h4>Return Message</h4>
<table class="doxtable">
<tr>
<th>Byte Description </th><th>Value  </th></tr>
<tr>
<td>HCI Event Packet </td><td>0x04 </td></tr>
<tr>
<td>Event Code </td><td>0x0E </td></tr>
<tr>
<td>Length </td><td>0x04 </td></tr>
<tr>
<td>Num_HCI_Command_Packets </td><td>0x01 </td></tr>
<tr>
<td>Command_Opcode LSB </td><td>0x19 </td></tr>
<tr>
<td>Command_Opcode MSB </td><td>0xFC </td></tr>
<tr>
<td>Status </td><td>0x00: Command succeeded. <br />
 0x01 – 0xFF: Command failed. </td></tr>
</table>
<hr/>
 </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jul 7 2020 07:10:51 for SmartSnippets DA1469x SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
